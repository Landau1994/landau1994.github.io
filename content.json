{"meta":{"title":"Coding for Life Sciences","subtitle":"ä»æ•°æ®ï¼Œæ¨¡å‹ä¸­è·å–ç”Ÿç‰©çŸ¥è¯†","description":"å…³æ³¨ä»æ•°æ®å’Œæ¨¡å‹ä¸­è·å–ç”Ÿç‰©çŸ¥è¯†çš„åšå®¢","author":"Longteng Wang","url":"https://landau1994.github.io"},"pages":[{"title":"å­¦ä¹ ï¼Œç ”ç©¶ï¼Œåˆ›æ–°ï¼Œåˆ†äº«","date":"2020-04-08T13:50:00.000Z","updated":"2025-01-11T17:16:31.892Z","comments":false,"path":"about/index.html","permalink":"https://landau1994.github.io/about/index.html","excerpt":"","text":"ä¸ºä½•å»ºç«™ ç§‘ç ”ä»å…´è¶£å‡ºå‘ï¼Œç”¨è‰¯å¥½çš„ä¹ æƒ¯åšæŒå’Œæˆé•¿ã€‚æœ¬ç«™æ—¨åœ¨è®°å½•æˆé•¿ç‚¹æ»´ã€‚ ä¸ºä½•å†™ä½œ å†™ä½œå¯ä»¥æŠµæŠ—é—å¿˜å’Œè¡°æœ½ï¼Œå¤äººäº‘ï¼š ç›–æ–‡ç« ï¼Œç»å›½ä¹‹å¤§ä¸šï¼Œä¸æœ½ä¹‹ç››äº‹ã€‚å¹´å¯¿æœ‰æ—¶è€Œå°½ï¼Œè£ä¹æ­¢ä¹å…¶èº«ï¼ŒäºŒè€…å¿…è‡³ä¹‹å¸¸æœŸï¼Œæœªè‹¥æ–‡ç« ä¹‹æ— ç©·ã€‚ â€”â€”æ›¹ä¸•ã€Šå…¸è®ºÂ·è®ºæ–‡ã€‹èŠ‚é€‰ è€Œåœ¨ç§‘ç ”ä¸­ï¼Œå†™ä½œå¯ä»¥æ•´ç†æ–‡çŒ®ç»¼è¿°ã€ææ–™æ–¹æ³•ï¼Œå·²ç»å–å¾—çš„æ•°æ®ç»“æœã€‚æ›´é‡è¦çš„æ˜¯ç†æ¸…ä¸‹ä¸€æ­¥ç ”ç©¶æ€è·¯å’ŒæŠ€æœ¯è·¯çº¿ã€‚ æ­¤å¤–ï¼Œå‹¤ç»ƒå†™ä½œï¼Œå¯ä»¥æé«˜ç ”ç©¶è€…è¡¨è¾¾å’Œæ¨å¹¿è‡ªå·±è§‚ç‚¹å’Œç ”ç©¶æˆæœçš„èƒ½åŠ›ã€‚ æ¶µç›–ä¸»é¢˜ æœ¬ç«™æœ€å…³æ³¨çš„æ˜¯åŸºå› ç»„å­¦å’Œç”Ÿç‰©ä¿¡æ¯å­¦çš„å„é¡¹ç ”ç©¶ä»¥åŠç›¸å…³çš„ç”Ÿç‰©å­¦ï¼Œä¿¡æ¯å­¦ï¼Œæ•°å­¦å’Œç»Ÿè®¡å­¦ï¼ˆå°†æ¥å¯èƒ½è¿˜ä¼šæœ‰ç‰©ç†å­¦å’ŒåŒ–å­¦ï¼‰çš„åŸºç¡€çŸ¥è¯†çš„å­¦ä¹ ã€‚æ›´å¤šè§è¯é¢˜æ ‡ç­¾ å…³äºä½œè€… ç”Ÿç‰©ä¿¡æ¯å­¦åšå£«ç ”ç©¶ç”Ÿåœ¨è¯»ã€‚çŸ¥ä¹ä¸»é¡µ[https://www.zhihu.com/people/landau1994]ã€‚"},{"title":"QA","date":"2020-04-08T13:32:22.000Z","updated":"2025-01-11T17:16:32.274Z","comments":false,"path":"help/index.html","permalink":"https://landau1994.github.io/help/index.html","excerpt":"","text":"Q: è¿™ç½‘ç«™æ€ä¹ˆå¼„çš„ï¼Œè¿˜æŒºå¥½çœ‹çš„å•Šï¼Ÿ A: æœ¬ç«™æ˜¯é™æ€åšå®¢ï¼Œé€šè¿‡hexoç”Ÿæˆï¼Œä¸»é¢˜ä¸ºjsimple,åšäº†ä¸ªæ€§åŒ–çš„å®šåˆ¶ï¼ˆæ¢äº†ç™½å¤©å’Œæ™šä¸Šçš„å›¾ç‰‡ï¼Œä¿®æ”¹äº†é…ç½®æ”¯æŒæ•°å­¦å…¬å¼ï¼‰ã€‚ Q: ä¸ºä»€ä¹ˆåšå®¢æœ‰æ—¶å€™æ‰“å¼€é€Ÿåº¦å¾ˆæ…¢ï¼Œä¸€ç›´åœ¨åŠ è½½ï¼Œæˆ–è€…æœ‰æ—¶å‹æ ¹æ‰“ä¸å¼€å‘¢ï¼Ÿ A: æœ¬ç«™å°šæ— ç‹¬ç«‹åŸŸåï¼Œæš‚æ—¶ä½¿ç”¨Github Pageã€‚æ‰€ä»¥githubå¡æˆ–è€…å´©çš„æ—¶å€™å°±ggäº†ã€‚ä¸è¿‡è¿™éƒ½æ˜¯å°æ¦‚ç‡äº‹ä»¶ã€‚å¼€æºä¸‡å²ï¼Œgithubä¸‡å²,æ‹¥æŠ±å¼€æºçš„å¾®è½¯ä¸‡å²ã€‚ Q: æˆ‘ä¹Ÿæƒ³æ­ä¸ªåšå®¢ï¼Œä¸çŸ¥é“æ€ä¹ˆå¼„ï¼Ÿ A: å‚è€ƒé—®é¢˜1ï¼Œå­¦ä¼šçœ‹å®˜ç½‘æ•™ç¨‹ï¼Œä»¥åŠè‡ªå·±åŠ¨æ‰‹ä¿®æ”¹å’Œè°ƒè¯•é…ç½®æ–‡æ¡£ã€‚ Q: æœ¬ç«™æ˜¯å¦æ¥å—æŠ•ç¨¿æˆ–è½¬è½½ï¼Ÿ ç«™é•¿æœ¬äººä¹‹å¤–çš„æŠ•ç¨¿å’Œè½¬è½½æš‚ä¸æ”¯æŒã€‚ Q: å…¶ä»–çš„... æœ¬ç«™ä¸ºç«™é•¿è‡ªå·±çš„å­¦ä¹ è®°å½•ï¼Œå› ä¸ªäººçŸ¥è¯†æ°´å¹³æ‰€é™ï¼Œå¦‚æœ‰é”™è¯¯ï¼Œè¿˜æœ›æ‰¹è¯„æŒ‡æ­£ã€‚"},{"title":"tags","date":"2020-04-05T14:04:00.000Z","updated":"2025-01-11T17:16:32.280Z","comments":false,"path":"tags/index.html","permalink":"https://landau1994.github.io/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2020-04-08T14:33:55.000Z","updated":"2025-01-11T17:16:32.289Z","comments":false,"path":"timeline/index.html","permalink":"https://landau1994.github.io/timeline/index.html","excerpt":"","text":"æš‚æ—¶æ²¡æœ‰ï¼Œå¯ä»¥çœ‹æ ‡ç­¾å’Œå½’æ¡£ã€‚"},{"title":"links","date":"2020-04-08T14:20:45.000Z","updated":"2025-01-11T17:16:32.276Z","comments":false,"path":"links/index.html","permalink":"https://landau1994.github.io/links/index.html","excerpt":"","text":"ä»¥ä¸‹æ‘˜å½•æœ‰è¶£ã€æœ‰æ„ä¹‰ã€æœ‰å½±å“åŠ›çš„é“¾æ¥ æŒç»­æ›´æ–°ä¸­ã€‚ æ­¤å¤„ä¸åšç½‘å€å¯¼èˆªï¼Œæ’åºä¸åˆ†å…ˆå... åŸºæœ¬èµ„æºç¯‡ github; google; PubMed; CNSçš„å®˜ç½‘ï¼› stackoverflow ä¸€äº›ç«™ç‚¹ç¯‡ å®ç”¨ç”Ÿç‰©ä¿¡æ¯æŠ€æœ¯ CBI forum ç”Ÿä¿¡æŠ€èƒ½æ ‘ ç”Ÿä¿¡å‘ å¾®ä¿¡å…¬ä¼—å·ç¯‡ biobabble"}],"posts":[{"title":"artin_review","slug":"artin-review","date":"2025-01-11T17:37:44.000Z","updated":"2025-01-11T17:41:18.906Z","comments":true,"path":"2025/01/12/artin-review/","link":"","permalink":"https://landau1994.github.io/2025/01/12/artin-review/","excerpt":"","text":"2024.03-2025.01 # ç¼˜èµ· è§ï¼šèƒ½è¯´ä¸€æœ¬æˆ–å‡ æœ¬åœ¨ä½ åœ¨å­¦æ•°å­¦è·¯ä¸Šå¯¹ä½ å½±å“æœ€å¤§çš„ä¸€æœ¬ä¹¦å—ï¼Ÿ - ä¸‡ç‰©çš†æ•°æ•°æµ·æ‹¾è´çš„å›ç­” - çŸ¥ä¹ https://www.zhihu.com/question/555672024/answer/3418569722 å¦‚ä½•ä»ç¾¤ï¼Œç¯ï¼Œåˆ°ï¼Œå†åˆ°Galoisç†è®ºã€‚ä½ å¯ä»¥å°†è¿™ç¯‡ä¹¦è¯„è§†ä¸ºå…³äºArtinä¸€ä¹¦çš„ä¸€ä¸ªå­¦ä¹ çº²é¢†ï¼Œç‰¹åˆ«æ˜¯åœ¨è¿™ç¯‡ä¹¦è¯„çš„æœ«å°¾ï¼Œæˆ‘ä»¬è¿˜é™„ä¸Šä¸€äº›è¿‘å¹´æ¥å‡ºç°åœ¨å›½å†…å¤–çš„æ•°å­¦è€ƒè¯•ä¸­çš„ä¹ é¢˜ä»¥åŠè§£ç­”ï¼Œè¿™äº›ä¹ é¢˜æ²¡æœ‰è¶…è¿‡Artinä¸€ä¹¦åŒ…å«çš„å†…å®¹ã€‚ Artinçš„ç¼–æ’å¯¹åˆå­¦è€…ä¸æ˜¯ç‰¹åˆ«å‹å¥½ï¼Œæ¯”å¦‚ç¬¬äºŒç‰ˆä¸€å¼€å§‹å°±æ˜¯çº¿æ€§ä»£æ•°ï¼Œæˆ–è®¸ä¼šè®©ä¸€äº›å·²ç»è¢«çº¿æ€§ä»£æ•°äº§ç”Ÿå®¡ç¾ç–²åŠ³çš„è¯»è€…åŠé€€ï¼Œä½†æ˜¯ç­‰ä»”ç»†è€ç€æ€§å­è¯»å®Œä¹‹åï¼Œä½ ä¼šå‘ç°ï¼Œè¿™äº›çº¿æ€§ä»£æ•°çš„çŸ¥è¯†ï¼Œå…¶å®ä¸åé¢çš„æŠ½è±¡ä»£æ•°çš„çŸ¥è¯†å¹¶ä¸æ˜¯å‰²è£‚çš„ã€‚ç¬”è€…åœ¨å°†Artinçš„ä¹¦é€šè¯»äº†ä¸‰éä¹‹åï¼Œå‘ˆç°ç»™ä¸€ä¸ªç¬”è€…è®¤ä¸ºè¾ƒä¸ºå®¹æ˜“ç†è§£çš„ç›®æ¬¡ã€‚ç¬”è€…è§‰å¾—Artinè¿™æœ¬ä¹¦ï¼Œä»…ç®¡ç¼ºç‚¹è¯¸å¤šï¼Œä¸Artiné£æ ¼ç±»ä¼¼çš„ï¼Œå¦‚Dummitï¼Œæˆ‘è§‰å¾—ä¹Ÿå¾ˆå¥½ã€‚ä½†æ˜¯Artinè¿™æœ¬ä¹¦æœ€å¤§çš„ä¼˜ç‚¹ï¼Œæ˜¯å°†çº¿æ€§ä»£æ•°å’ŒæŠ½è±¡ä»£æ•°èåˆä¸ºä¸€ä½“ï¼Œå…·ä½“å°±æ˜¯é€šè¿‡è¡¨ç¤ºè®ºçš„çŸ¥è¯†ç©¿æ’å°†ä¸¤è€…ç»“åˆèµ·æ¥ï¼Œå‡ ä¹æ²¡æœ‰ä¸€æœ¬é¢å‘æœ¬ç§‘çš„æ•™æï¼Œèƒ½å¤Ÿåšçš„è¿™ä¹ˆå¥½ã€‚","categories":[{"name":"math","slug":"math","permalink":"https://landau1994.github.io/categories/math/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"learn_python_001","slug":"learn-python-001","date":"2021-12-04T13:19:59.000Z","updated":"2025-01-11T17:16:31.837Z","comments":true,"path":"2021/12/04/learn-python-001/","link":"","permalink":"https://landau1994.github.io/2021/12/04/learn-python-001/","excerpt":"","text":"Learn_python_001 Top K problem ğŸŸ§â“ The problem Top K question: è¾“å…¥æ•´æ•°æ•°ç»„ arr ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„ k ä¸ªæ•°ã€‚ä¾‹å¦‚ï¼Œè¾“å…¥4ã€5ã€1ã€6ã€2ã€7ã€3ã€8è¿™8ä¸ªæ•°å­—ï¼Œåˆ™æœ€å°çš„4ä¸ªæ•°å­—æ˜¯1ã€2ã€3ã€4ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šarr = [3,2,1], k = 2 è¾“å‡ºï¼š[1,2] æˆ–è€… [2,1] ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šarr = [0,1,2,1], k = 1 è¾“å‡ºï¼š[0] é™åˆ¶ï¼š 0 &lt;= k &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 10000 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜ ğŸ“„ code æœ‰ä¸‰ç§è§£æ³•ï¼Œè§£æ³•äºŒï¼Œä¸‰ï¼Œæ˜¯ç¬¦åˆé¢˜ç›®è¦æ±‚çš„ä¸¤ç§ï¼ˆå› ä¸ºé¢˜ç›®ä¹Ÿè€ƒå¯Ÿäº†æ’åºç®—æ³•ï¼‰ã€‚è¯¦è§£è§https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/ class Solution1: def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]: lstStd = arr lstStd.sort() res = lstStd[:k] return res ### solution2: ### wirte your own quick sort ### This was taken from https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/ class Solution2: def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]: def quick_sort(arr, l, r): if l &gt;= r: return i, j = l, r while i &lt; j: while i &lt; j and arr[j] &gt;= arr[l]: j -= 1 while i &lt; j and arr[i] &lt;= arr[l]: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] quick_sort(arr, l, i - 1) quick_sort(arr, i + 1, r) quick_sort(arr, 0, len(arr) - 1) return arr[:k] class Solution3: def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]: if k &gt;= len(arr): return arr def quick_sort(l, r): i, j = l, r while i &lt; j: while i &lt; j and arr[j] &gt;= arr[l]: j -= 1 while i &lt; j and arr[i] &lt;= arr[l]: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] if k &lt; i: return quick_sort(l, i - 1) if k &gt; i: return quick_sort(i + 1, r) return arr[:k] return quick_sort(0, len(arr) - 1) ğŸ“ æµ‹è¯• æˆ‘ä»¬ç”¨å¦‚ä¸‹ä»£ç æµ‹è¯•ï¼š ### import require package import numpy as np import random import matplotlib.pyplot as plt import time import seaborn as sns from typing import List, Dict, Tuple, Sequence def ProgramTime(N,func): lst = [random.randrange(10**7) for n in range(N)] start = time.perf_counter() func(lst,10) runtime = (time.perf_counter() - start) return runtime ProgramTimeVec = np.vectorize(ProgramTime) ### define theory function def f1(n, k): return k*n def f2(n, k): return k*n*np.log(n) ### plot test curve n = np.arange(1, 2000) colors = sns.color_palette(\"Set1\") plt.plot(n, f1(n, 1e-7), c=colors[0]) plt.plot(n, f2(n, 1e-7), c=colors[1]) plt.plot(n, ProgramTimeVec(n,sol1.getLeastNumbers),c=colors[2]) plt.plot(n, ProgramTimeVec(n,sol2.getLeastNumbers),c=colors[3]) plt.plot(n, ProgramTimeVec(n,sol3.getLeastNumbers),c=colors[4]) plt.xlabel('Size of input (n)', fontsize=16) plt.ylabel('Time', fontsize=16) #plt.legend(['$\\mathcal{O}(n^2)$', '$\\mathcal{O}(n \\log n)$'], loc='best', fontsize=20) plt.legend(['$\\mathcal{O}(n)$', '$\\mathcal{O}(n \\log n)$','sol1', 'sol2','sol3'], loc='best', fontsize=20) fig = plt.gcf() fig.set_size_inches(8, 6) plt.savefig(\"../fig/test.png\",dpi=300) ç»“æœå¦‚ä¸‹, å¯ä»¥çœ‹å‡ºï¼Œä½¿ç”¨è§£æ³•ä¸‰ï¼Œä¹Ÿå°±æ˜¯åŸºäºå¿«é€Ÿæ’åºçš„æ•°ç»„åˆ’åˆ†ï¼Œå¯ä»¥å®ç°çº¿æ€§æ—¶é—´ï¼š figure","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"Python","slug":"Python","permalink":"https://landau1994.github.io/tags/Python/"}]},{"title":"Epigenome_track_plot","slug":"Epigenome-track-plot","date":"2021-10-27T11:06:50.000Z","updated":"2025-01-11T17:16:31.806Z","comments":true,"path":"2021/10/27/Epigenome-track-plot/","link":"","permalink":"https://landau1994.github.io/2021/10/27/Epigenome-track-plot/","excerpt":"","text":"Epigenome track visulalization by R Recently, I create a new repo to visulizaiton Epigenome track by ggplot2() ecosytem. Details can be found at https://github.com/Landau1994/PlotEpiTrackByR","categories":[{"name":"genomics","slug":"genomics","permalink":"https://landau1994.github.io/categories/genomics/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"reading_note_20201206","slug":"reading-note-20201206","date":"2020-12-06T12:49:41.000Z","updated":"2025-01-11T17:16:31.856Z","comments":true,"path":"2020/12/06/reading-note-20201206/","link":"","permalink":"https://landau1994.github.io/2020/12/06/reading-note-20201206/","excerpt":"","text":"é¢˜ç›®ï¼š[3D] bioRxiv 2020 3D Genome Contributes to Protein-Protein Interactome - ç”Ÿç‰©é—®é¢˜ï¼š3D åŸºå› ç»„çš„ä¸è›‹ç™½è´¨äº’ä½œæ˜¯å¦å­˜åœ¨å…³ç³»ï¼Ÿ å®éªŒè®¾è®¡ï¼š PPIæ•°æ®ï¼šæ”¶é›†ä¸åŒæ•°æ®åº“è›‹ç™½è´¨äº’ä½œæ•°æ®ï¼Œä½œä¸ºæ­£æ ·æœ¬ï¼›ä»ä¸åŒäºšç»†èƒå®šä½çš„éPPIäº’ä½œè›‹ç™½ä¸­æŠ½æ ·ï¼Œä½œä¸ºè´Ÿæ ·æœ¬ï¼› HiCæ•°æ®ï¼šä¸åŒç»†èƒç³»çš„HiCæ•°æ®ï¼Œé‡‡ç”¨ç›¸åŒæ–¹æ³•é‡æ–°å¤„ç†ï¼Œä½¿å¾—äº’ä½œçŸ©é˜µåˆ†è¾¨ç‡ç›¸åŒï¼› ä»3DåŸºå› ç»„ä¿¡æ¯ä¸­ï¼Œé‡å»ºåŸºå› çš„ç©ºé—´ä¿¡æ¯ï¼Œé‡‡ç”¨ä¸åŒçš„æœºå™¨å­¦ä¹ æ–¹æ³•é¢„æµ‹PPIæ•°æ® åˆ†ææ€è·¯ï¼š åˆ†ç»„æ¯”è¾ƒPPI gene counterparts ç»„å’Œ Non-PPIç»„çš„åˆ†å¸ƒå›¾ï¼ŒHiCHeatmapï¼ŒGene-gene pair projections of PPIs overlaid on Hi-C heatmaps.ï¼Œå‘ç°äº†PPI gene counterparts åœ¨ç©ºé—´æ›´ä¸ºé‚»è¿‘ï¼›ï¼ˆFigure2,3,4ï¼‰ï¼› åˆ†æè‡³å°‘ä¸€ä¸ªè›‹ç™½æœ‰ä¿¡å·è‚½çš„PPIï¼ˆSigPep PPIï¼‰ä¸æ— ä¿¡å·è‚½PPI(Non-SigPep PPI)çš„å…³ç³»ï¼Œå¾—åˆ°ç»“è®ºæ˜¯ï¼šâ€œThis can be explained that for the interacting proteins that are brought together by signal peptides, their gene counterparts can be more freely located on the 3D genome, with larger spatial distancesâ€œ ç”¨3ç»´åŸºå› ç»„çš„ä¿¡æ¯åœ¨ä¸åŒçš„æ¨¡å‹ä¸­é¢„æµ‹PPIï¼Œå‘ç°å¼•å…¥3ç»´åŸºå› ç»„çš„ä¿¡æ¯ä¹‹åï¼Œâ€ the prediction accuracy in terms of AUC can be significantly improved if 3D genome information is employedâ€œï¼ˆTable1)ï¼Œç”±äºæ˜¯é¢„å°æœ¬ï¼Œç‰¹å¾å·¥ç¨‹çš„é‚£ä¸€éƒ¨åˆ†ä½œè€…å¹¶æ²¡æœ‰è¯¦ç»†å†™ï¼› è¯„è®ºï¼š ç›®å‰æœ‰å¾ˆå¤šç ”ç©¶ç»„è‡´åŠ›äºè§£æ3DåŸºå› ç»„ç»“æ„å’Œç–¾ç—…çš„å…³ç³»ï¼ŒæŠ¥é“äº†ä¸€äº›3DåŸºå› ç»„ç»“æ„æ”¹å˜ï¼Œå½±å“è½¬å½•ï¼Œä»è€Œå½±å“ç–¾ç—…çš„æ¡ˆä¾‹ï¼›æœ¬æ–‡çš„åˆ†æè™½ç„¶ç®€å•ï¼Œä½†æ˜¯ç»™å‡ºäº†3DåŸºå› ç»„ç»“æ„å¯¹äºæ›´ä¸ºä¸‹æ¸¸çš„è›‹ç™½è´¨äº’ä½œæœ‰å½±å“çš„å¯èƒ½æ€§ã€‚ä½†æ˜¯è¿™ç§å¯èƒ½æ€§ï¼Œè¿˜éœ€è¦æ›´ä¸ºsolidçš„æŠ€æœ¯ï¼Œæ•°æ®å’Œåˆ†ææ–¹æ³•æ¥è¯æ˜ï¼› alphafoldæ˜¯åŸºäºåºåˆ—ä¿¡æ¯æ¥é¢„æµ‹è›‹ç™½è´¨ç»“æ„ï¼Œç›®å‰å·²ç»å–å¾—é‡å¤§çªç ´ã€‚ç›®å‰ä¹Ÿé™†ç»­æœ‰åŸºäºæœºå™¨å­¦ä¹ çš„æ–¹æ³•ï¼Œæ•´åˆä¸åŒåŸºå› ç»„å­¦çš„æ•°æ®è¿›è¡ŒåŠŸèƒ½åŸºå› ç»„å­¦ç ”ç©¶çš„æŠ¥é“ã€‚å¯èƒ½åœ¨æœªæ¥çš„ç ”ç©¶ä¸­ï¼Œç»“åˆå¤šç»„å­¦æ•°æ®ï¼Œåƒalphafoldè¿™æ ·çš„AIæ¡†æ¶ï¼Œæ‰èƒ½å®ç°æ›´ä¸ºæ·±åˆ»çš„è›‹ç™½åŠ¨æ€åŠŸèƒ½çš„é¢„æµ‹ï¼›","categories":[{"name":"reference","slug":"reference","permalink":"https://landau1994.github.io/categories/reference/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"mmet 2020 Age-related loss of gene-to-gene transcriptional coordination among single-cells","slug":"readnote","date":"2020-12-06T03:07:29.000Z","updated":"2025-01-11T17:16:31.858Z","comments":true,"path":"2020/12/06/readnote/","link":"","permalink":"https://landau1994.github.io/2020/12/06/readnote/","excerpt":"","text":"åœ¨HSCä¸­æ²¡æœ‰è§‚å¯Ÿåˆ°cell-cell variationéšç€è¡°è€çš„æ”¹å˜ï¼›For example, despite observations of genetic and epigenteic damage in ageing haematopoietic stem cells(HSCs); cell to cell transcriptional variability is not observed. åŸºå› å…±è¡¨è¾¾æ–¹æ³•çš„ç¼ºé™·ï¼š First, co-expression networks estimates the direct or indirect correlations between pairs of genes, while an individual gene may be controlled by multiple regulators. Second, each co-expression measure is designed to capture a specific feature that is not necessarily optimal for depicting all types of gene-to-gene transcriptional interrelations ( PCC, linear relatiosnhips) Third, large calculated coexpresion matrices contain a considerable amount of noise, which raises an additional difficulty in explporing their differentiation across cohorts Gcl æœ¬è´¨ä¸Šæ˜¯å¯¹bcdcorrçš„bootstrap. ä¸€ä¸ªé‡è¦çš„è§‚å¯Ÿå’Œå»ºè®¾ï¼š As an illustration of the coordination measured by the GCL, consider the expression profiles of cells with N genes, that are represented as points in an N-dimensional space. If the gene expression levels are not independent, the set of points do not fill the N- dimensional space but are rather located near lower-dimensional manifold. The GCL measures has two main advantages. The dependency level is defined with respect to a general dependency form, not specific relations ( such as linear) It can include high-order dependencies between multiple variables","categories":[{"name":"reference","slug":"reference","permalink":"https://landau1994.github.io/categories/reference/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"Learn-igraph-More about igraph","slug":"Learnigraph-2-MoreOnIgraph","date":"2020-07-29T15:23:30.000Z","updated":"2025-01-11T17:16:31.826Z","comments":true,"path":"2020/07/29/Learnigraph-2-MoreOnIgraph/","link":"","permalink":"https://landau1994.github.io/2020/07/29/Learnigraph-2-MoreOnIgraph/","excerpt":"","text":"0. è¯´æ˜ æˆ‘ä»¬æ¥ç€è®²æ›´å¤šå…³äºå¯¹igraphå¯¹è±¡çš„æ“ä½œï¼Œå‚è€ƒStatistical Network Analysis with igraphç¬¬ä¸€ç« ã€‚ 1. åˆ›å»ºigraph å¯¹è±¡ ä½¿ç”¨ç®¡é“ library(igraph) library(igraphdata) library(magrittr) library(tidyverse) library(ggraph) library(ggnetwork) # Notable graphs # make_graph can create some notable graphs. The name of the graph (case insensitive), a character scalar must be suppliced as the edges argument, and other arguments are ignored. (A warning is given is they are specified.) # eg. # Cubical # The Platonic graph of the cube. A convex regular polyhedron with 8 vertices and 12 edges. g &lt;- make_graph(\"Cubical\") %&gt;% set_vertex_attr(\"name\",value = LETTERS[1:4]) g %&gt;% add_layout_(with_fr()) %&gt;% plot() è¡¥å……ï¼šæ›´ä¸ºå®é™…çš„æ¡ˆä¾‹ä¸­ï¼Œéœ€è¦ä½¿ç”¨æ•°æ®é›†æ¥åˆ›å»ºå›¾ã€‚igraphä½œè€…æä¾›äº†ä¸€äº›æ ¹æ®æ•°æ®é›†åˆ›å»ºå¥½çš„igraphå¯¹è±¡ï¼š library(igraphdata) ### data:Loads specified data sets, or list the available data sets. data(package=\"igraphdata\") # Data sets in package â€˜igraphdataâ€™: # # Koenigsberg Bridges of Koenigsberg from Euler's times # UKfaculty Friendship network of a UK university faculty # USairports US airport network, 2010 December # enron Enron Email Network # foodwebs A collection of food webs # immuno Immunoglobulin interaction network # karate Zachary's karate club network # kite Krackhardt's kite # macaque Visuotactile brain areas and connections # rfid Hospital encounter network data # yeast Yeast protein interaction network 2. ä½¿ç”¨iraphå¯¹è±¡æŸ¥çœ‹è¾¹å’Œç‚¹çš„ä¿¡æ¯ ### already data(\"macaque\") macaque ## IGRAPH f7130f3 DN-- 45 463 -- ## + attr: Citation (g/c), Author (g/c), shape (v/c), name (v/c) ## + edges from f7130f3 (vertex names): ## [1] V1 -&gt;V2 V1 -&gt;V3 V1 -&gt;V3A V1 -&gt;V4 V1 -&gt;V4t V1 -&gt;MT ## [7] V1 -&gt;PO V1 -&gt;PIP V2 -&gt;V1 V2 -&gt;V3 V2 -&gt;V3A V2 -&gt;V4 ## [13] V2 -&gt;V4t V2 -&gt;VOT V2 -&gt;VP V2 -&gt;MT V2 -&gt;MSTd/p V2 -&gt;MSTl ## [19] V2 -&gt;PO V2 -&gt;PIP V2 -&gt;VIP V2 -&gt;FST V2 -&gt;FEF V3 -&gt;V1 ## [25] V3 -&gt;V2 V3 -&gt;V3A V3 -&gt;V4 V3 -&gt;V4t V3 -&gt;MT V3 -&gt;MSTd/p ## [31] V3 -&gt;PO V3 -&gt;LIP V3 -&gt;PIP V3 -&gt;VIP V3 -&gt;FST V3 -&gt;TF ## [37] V3 -&gt;FEF V3A-&gt;V1 V3A-&gt;V2 V3A-&gt;V3 V3A-&gt;V4 V3A-&gt;VP ## [43] V3A-&gt;MT V3A-&gt;MSTd/p V3A-&gt;MSTl V3A-&gt;PO V3A-&gt;LIP V3A-&gt;DP ## + ... omitted several edges åŸä½œè€…æ˜¯è¿™ä¹ˆè§£é‡Šçš„ï¼š This is the standard way of showing (printing) an igraph graph object on the screen. The top line of the output declares that the object is an igraph graph, and also lists its most important properties. A four-character long code is printed first: â€˜D/Uâ€™ The first character is either â€˜Dâ€™ or â€˜Uâ€™ and encodes whether the graph is directed or undireted. â€˜Nâ€™ The second letter is â€˜Nâ€™ for named graphs (see Section 1.2.5). A dash here means that the graph is not named. â€˜Wâ€™ The third letter is â€˜Wâ€™ if the graph is weighted (in other words, if the graph is a valued graph, Section 2.4). Unweighted graphs have a dash in this position. â€˜Bâ€™ Finally, the fourth is â€˜Bâ€™ if the graph is bipartite (two-mode, Section ??). For unipartite (one-mode) graphs a dash is printed here. This notation might seem quite dense at first, but it is easy to get used to and conveys much information in a small space. Then two numbers are printed, these are the number of vertices and the number of edges in the graph, 45 and 463 in our case. At the end of the line the name of the graph is printed, if there is any. The next line(s) list attributes, meta-data that belong to the vertices, edges or the graph itself. Finally, the edges of the graph are listed. Except for very small graphs, this list is truncated, so that it fits to the screen. ä¸€äº›åŸºæœ¬é‡çš„å±•ç¤ºï¼Œä¹‹å‰è®²è¿‡ï¼Œæ­¤å¤–ï¼Œè¿˜æœ‰æ›´å¤šå…³äºè¾¹çš„æ“ä½œï¼š ###|V| gorder(macaque) ###[1] 45 ###|E| gsize(macaque) ###[1] 463 V(macaque) # + 45/45 vertices, named, from f7130f3: # [1] V1 V2 V3 V3A V4 V4t VOT VP MT MSTd/p MSTl # [12] PO LIP PIP VIP DP 7a FST PITd PITv CITd CITv # [23] AITd AITv STPp STPa TF TH FEF 46 3a 3b 1 # [34] 2 5 Ri SII 7b 4 6 SMA Ig Id 35 # [45] 36 E(macaque) # + 463/463 edges from f7130f3 (vertex names): # [1] V1 -&gt;V2 V1 -&gt;V3 V1 -&gt;V3A V1 -&gt;V4 V1 -&gt;V4t V1 -&gt;MT # [7] V1 -&gt;PO V1 -&gt;PIP V2 -&gt;V1 V2 -&gt;V3 V2 -&gt;V3A V2 -&gt;V4 # [13] V2 -&gt;V4t V2 -&gt;VOT V2 -&gt;VP V2 -&gt;MT V2 -&gt;MSTd/p V2 -&gt;MSTl # [19] V2 -&gt;PO V2 -&gt;PIP V2 -&gt;VIP V2 -&gt;FST V2 -&gt;FEF V3 -&gt;V1 # [25] V3 -&gt;V2 V3 -&gt;V3A V3 -&gt;V4 V3 -&gt;V4t V3 -&gt;MT V3 -&gt;MSTd/p # [31] V3 -&gt;PO V3 -&gt;LIP V3 -&gt;PIP V3 -&gt;VIP V3 -&gt;FST V3 -&gt;TF # [37] V3 -&gt;FEF V3A-&gt;V1 V3A-&gt;V2 V3A-&gt;V3 V3A-&gt;V4 V3A-&gt;VP # [43] V3A-&gt;MT V3A-&gt;MSTd/p V3A-&gt;MSTl V3A-&gt;PO V3A-&gt;LIP V3A-&gt;DP # [49] V3A-&gt;FST V3A-&gt;FEF V4 -&gt;V1 V4 -&gt;V2 V4 -&gt;V3 V4 -&gt;V3A # [55] V4 -&gt;V4t V4 -&gt;VOT V4 -&gt;VP V4 -&gt;MT V4 -&gt;LIP V4 -&gt;PIP # + ... omitted several edges macaque %&gt;% ends(\"V1|V2\") # # [,1] [,2] # [1,] \"V1\" \"V2\" macaque %&gt;% tail_of(\"V1|V2\") # + 1/45 vertex, named, from f7130f3: # [1] V1 macaque %&gt;% head_of(\"V1|V2\") # + 1/45 vertex, named, from f7130f3: # [1] V2 macaque %&gt;% neighbors(\"V1\",mode = \"out\") # + 8/45 vertices, named, from f7130f3: # [1] V2 V3 V3A V4 V4t MT PO PIP macaque %&gt;% neighbors(\"V1\",mode = \"in\") # + 8/45 vertices, named, from f7130f3: # [1] V2 V3 V3A V4 V4t MT PO PIP E(macaque)[.from(\"V1\")] 3. å­å›¾ åˆ›å»ºå­å›¾ V(macaque)[\"V1\",\"V2\",.nei(\"V1\"),.nei(\"V2\")] %&gt;% induced_subgraph(graph = macaque) %&gt;% summary() ## IGRAPH cb88d15 DN-- 16 156 -- ## + attr: Citation (g/c), Author (g/c), shape (v/c), name (v/c) è¿é€š is_connected(macaque,mode = \"weak\") ## [1] TRUE is_connected(macaque,mode = \"strong\") ## [1] TRUE è¾¹å’Œç‚¹çš„ç­›é€‰ï¼š V(macaque)[1:4] # + 4/45 vertices, named, from f7130f3: # [1] V1 V2 V3 V3A V(macaque)[c(\"V1\",\"V2\",\"V3\",\"V3A\")] # + 4/45 vertices, named, from f7130f3: # [1] V1 V2 V3 V3 å»ºç«‹è¾¹æˆ–è€…ç‚¹çš„ç´¢å¼•å‘é‡ï¼š E(macaque)[1:10] %&gt;% as_ids() # [1] \"V1|V2\" \"V1|V3\" \"V1|V3A\" \"V1|V4\" \"V1|V4t\" \"V1|MT\" \"V1|PO\" \"V1|PIP\" # [9] \"V2|V1\" \"V2|V3\" V(macaque)[1:10] %&gt;% as_ids() # [1] \"V1\" \"V2\" \"V3\" \"V3A\" \"V4\" \"V4t\" \"VOT\" \"VP\" # [9] \"MT\" \"MSTd/p\" ç±»ä¼¼äºç®—æ•°æ“ä½œï¼Œå…³äºç‚¹çš„æ“ä½œæ±‡æ€»ï¼š data(\"kite\") V(kite) # + 10/10 vertices, named, from 6b7ddad: # [1] A B C D E F G H I J V(kite)[1:3,7:10] # + 7/10 vertices, named, from 6b7ddad: # [1] A B C G H I J V(kite)[degree(kite) &lt; 2] # + 1/10 vertex, named, from 6b7ddad: # [1] J V(kite)[.nei(\"D\")] # + 6/10 vertices, named, from 6b7ddad: # [1] A B C E F G V(kite)[.innei(\"D\")] # + 6/10 vertices, named, from 6b7ddad: # [1] A B C E F G V(kite)[.outnei(\"D\")] # + 6/10 vertices, named, from 6b7ddad: # [1] A B C E F G V(kite)[.inc(\"A|D\")] # + 2/10 vertices, named, from 6b7ddad: # [1] A D c(V(kite)[\"A\"],V(kite)[\"D\"]) # + 2/10 vertices, named, from 6b7ddad: # [1] A D rev(V(kite)) # + 10/10 vertices, named, from 6b7ddad: # [1] J I H G F E D C B A unique(V(kite)[\"A\",\"A\",\"C\",\"C\"]) # + 2/10 vertices, named, from 6b7ddad: # [1] A C ### Set operation union(V(kite)[1:5],v(kite)[6:10]) # + 2/10 vertices, named, from 6b7ddad: # [1] A C intersection(V(kite)[1:7],V(kite)[5:10]) # + 3/10 vertices, named, from 6b7ddad: # [1] E F G difference(V(kite),V(kite)[1:5]) # + 5/10 vertices, named, from 6b7ddad: # [1] F G H I J E(kite) # + 18/18 edges from 6b7ddad (vertex names): # [1] A--B A--C A--D A--F B--D B--E B--G C--D C--F D--E D--F D--G E--G F--G F--H G--H # [17] H--I I--J E(kite,path = c(\"A\",\"D\",\"C\")) # + 2/18 edges from 6b7ddad (vertex names): # [1] A--D C--D E(kite)[ V(kite)[1:2] %--% V(kite)[3:4] ] # + 3/18 edges from 6b7ddad (vertex names): # [1] A--C A--D B--D E(kite)[1:3,7:10] # + 7/18 edges from 6b7ddad (vertex names): # [1] A--B A--C A--D B--G C--D C--F D--E E(kite)[seq_len(gsize(kite))[seq_len(gsize(kite)) %%2 == 0]] # + 9/18 edges from 6b7ddad (vertex names): # [1] A--C A--F B--E C--D D--E D--G F--G G--H I--J E(kite)[seq_len(gsize(kite)) %%2 == 0] # + 9/18 edges from 6b7ddad (vertex names): # [1] A--C A--F B--E C--D D--E D--G F--G G--H I--J E(kite)[seq_len(gsize(kite)) %%2] # + 9/18 edges from 6b7ddad (vertex names): # [1] A--B A--B A--B A--B A--B A--B A--B A--B A--B E(kite)[.inc(\"D\")] # + 6/18 edges from 6b7ddad (vertex names): # [1] A--D B--D C--D D--E D--F D--G E(macaque)[.from(\"V1\")] # + 8/463 edges from f7130f3 (vertex names): # [1] V1-&gt;V2 V1-&gt;V3 V1-&gt;V3A V1-&gt;V4 V1-&gt;V4t V1-&gt;MT V1-&gt;PO V1-&gt;PIP E(macaque)[.to(\"V1\")] # + 8/463 edges from f7130f3 (vertex names): # [1] V2 -&gt;V1 V3 -&gt;V1 V3A-&gt;V1 V4 -&gt;V1 V4t-&gt;V1 MT -&gt;V1 PO -&gt;V1 PIP-&gt;V1 ### The remains are same as Vertices operations","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://landau1994.github.io/tags/Graph/"},{"name":"Network","slug":"Network","permalink":"https://landau1994.github.io/tags/Network/"}]},{"title":"LearnSeurat_Intergrate","slug":"LearnSeurat-Intergrate","date":"2020-05-27T03:44:09.000Z","updated":"2025-01-11T17:16:31.816Z","comments":true,"path":"2020/05/27/LearnSeurat-Intergrate/","link":"","permalink":"https://landau1994.github.io/2020/05/27/LearnSeurat-Intergrate/","excerpt":"","text":"0. è¯´æ˜ æ›´ä¸ºè¯¦ç»†çš„ä½¿ç”¨ï¼Œå¯ä»¥å‚è€ƒSeuratå®˜æ–¹æ•™ç¨‹ï¼Œæˆ–è€…Seuratè¿›è¡Œå•ç»†èƒRNA-seqæ•°æ®æ•´åˆã€‚ 1. å¿«é€Ÿè¿›è¡Œ å®é™…åˆ†æä¸­ï¼Œå¦‚æœç»†èƒæ•°ç›®å¾ˆå¤šçš„è¯ï¼Œè¿›è¡Œæ•´åˆåˆ†æçš„æ—¶å€™å°±ä¼šå¾ˆæ…¢ï¼Œä¸€ç§æ–¹å¼æ˜¯å°†ä»»åŠ¡æäº¤é€šè¿‡å‘½ä»¤è¡Œæäº¤åˆ°æœåŠ¡å™¨æˆ–è€…é›†ç¾¤ä¸Šè¿è¡Œï¼Œå¹¶è¾“å‡ºã€‚ ä¼ é€’å‘½ä»¤è¡Œçš„å‚æ•°çš„è„šæœ¬å¯ä»¥è¿™ä¹ˆå†™ï¼š #### reference base Integration .libPaths(\"/home/user/lib/R/library\") library(Seurat) args = commandArgs(trailingOnly=TRUE) # test if there is at least one argument: if not, return an error if (length(args)==0) { stop(\"At least one argument must be supplied (input file).n\", call.=FALSE) } ###args[1] seu.list.rds ###args[2] seu.intergrated.rds ###args[3] UMAPplot.pdf ## program... seu.list &lt;- readRDS(file = args[1]) for (i in names(seu.list)) { seu.list[[i]] &lt;- SCTransform(seu.list[[i]], verbose = FALSE) } seu.list.features &lt;- SelectIntegrationFeatures(object.list = seu.list, nfeatures = 3000) seu.list &lt;- PrepSCTIntegration(object.list = seu.list, anchor.features = seu.list.features) reference_dataset &lt;- 1 names(seu.list)[1] seu.list.anchors &lt;- FindIntegrationAnchors(object.list = seu.list, normalization.method = \"SCT\", anchor.features = seu.list.features, reference = reference_dataset) seu.list.integrated &lt;- IntegrateData(anchorset = seu.list.anchors, normalization.method = \"SCT\") seu.list.integrated &lt;- RunPCA(object = seu.list.integrated, verbose = FALSE) seu.list.integrated &lt;- RunUMAP(object = seu.list.integrated, umap.method = \"umap-learn\", dims = 1:30) saveRDS(seu.list.integrated,file = args[2]) #### show Integrated result plots &lt;- DimPlot(seu.list.integrated, group.by = c(\"orig.ident\", \"cell.type\")) plots &amp; theme(legend.position = \"top\") &amp; guides(color = guide_legend(nrow = 4, byrow = TRUE, override.aes = list(size = 2.5))) ggsave(filename = args[3],width = 12,height = 6) å°†å…¶å‘½åä¸ºIntegrated_ref_based.R ç„¶ååœ¨ç»ˆç«¯è¾“å…¥nohup Rscript Integrated_ref_based.R seu.list.rds seu.intergrated.rds UMAPplot.pdf &gt; log.txt &amp;æäº¤å³å¯ï¼› 2. è¯„è®º å½“ç„¶ï¼Œè¿™ä¸ªè„šæœ¬è¯»è€…è¿˜å¯ä»¥æ ¹æ®è‡ªå·±éœ€æ±‚åŠ ä»¥å®Œå–„ã€‚","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"},{"name":"scRNA-seq","slug":"scRNA-seq","permalink":"https://landau1994.github.io/tags/scRNA-seq/"}]},{"title":"å¦‚ä½•å®šä¹‰ç»†èƒç±»å‹","slug":"å¦‚ä½•å®šä¹‰ç»†èƒç±»å‹","date":"2020-05-16T06:20:28.000Z","updated":"2025-01-11T17:16:31.874Z","comments":true,"path":"2020/05/16/å¦‚ä½•å®šä¹‰ç»†èƒç±»å‹/","link":"","permalink":"https://landau1994.github.io/2020/05/16/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"ç”Ÿç‰©å­¦å®¶çš„ä¼ ç»Ÿè‰ºèƒ½æ˜¯è¿›è¡Œåˆ†ç±»ï¼Œå³ä½¿åœ¨è¿›å…¥äº†21ä¸–çºªï¼Œç ”ç©¶çš„å°ºåº¦å’Œç ”ç©¶çš„æ‰‹æ®µå’Œæ—å¥ˆå·²ç»æœ‰äº†å¾ˆå¤§çš„ä¸åŒï¼Œä½†æ˜¯åˆ†ç±»è¿™ä¸ªå¤è€çš„é—®é¢˜ä¾ç„¶æ˜¯ä¼—å¤šç”Ÿç‰©ç ”ç©¶é¢†åŸŸçš„åŸºç¡€ã€‚ä½œä¸ºåˆ†ç±»è¿™ä¸ªå¤§é—®é¢˜ä¸­çš„å­é—®é¢˜ï¼Œç»†èƒç±»å‹çš„é‰´å®šæ˜¯å½“å‰ç»†èƒç”Ÿç‰©å­¦ç ”ç©¶çš„ä¸€ä¸ªåŸºç¡€é—®é¢˜å’Œå‰æ²¿é—®é¢˜ã€‚ æ¯”å¦‚å‘è‚²ç”Ÿç‰©å­¦å’Œå¹²ç»†èƒç”Ÿç‰©å­¦çš„ç ”ç©¶ï¼Œç¡®å®šç»†èƒçš„è°±ç³»æ˜¯ç ”ç©¶ç»†èƒå‘½è¿å†³å®šå› ç´ ç­‰åŸºç¡€ç ”ç©¶ä»¥åŠç›¸å…³ä¸´åºŠè½¬åŒ–çš„åŸºç¡€ã€‚è¿™ä¸ªåŸºç¡€æœ‰å¤šé‡è¦çš„å‘¢ï¼Œå‡å¦‚æŸä¸ªå¤§ç‰›å£°ç§°è‡ªå·±å‘ç°äº†æŸç§ç¥å¥‡çš„ç»†èƒï¼Œè¿™ä¸ªç»†èƒå¯ä»¥å¸¦æ¥åŒ»å­¦é©å‘½ï¼Œç„¶è€Œè¿™ç§ç±»å‹çš„ç»†èƒå¾ˆå¯èƒ½å°±ä¸å­˜åœ¨ï¼Œæ‰€ä¸ºçš„å¸¦æ¥é©å‘½çš„å®£ä¼ éƒ½æ˜¯å¿½æ‚ å’Œéª—å±€,åŸºäºè¿™ç§ç±»å‹çš„ç»†èƒçš„ç ”ç©¶éƒ½æ˜¯å»ºåœ¨æ²™å­ä¸Šçš„é«˜æ¥¼å¤§å¦ã€‚ä»¥ä¸Šä¸æ˜¯æˆ‘ä»¬çš„æƒ³è±¡ï¼Œè€Œæ˜¯ç¡®å®å‘ç”Ÿçš„ç°å®æ¡ˆä¾‹å“ˆä½›å¤§å­¦ç”±äºå¿ƒè‚Œå¹²ç»†èƒä¸å­˜åœ¨è€Œå¤§é‡æ’¤ç¨¿ï¼Œå›½å†…æ‰€æœ‰é˜³æ€§æŒ‡æ ‡è®ºæ–‡æ˜¯å¦éƒ½æ¶‰å«Œé€ å‡ï¼Ÿ æœ€è¿‘ï¼ŒCell Stem Cellæ‚å¿—ä¸Šå‘è¡¨äº†ä¸€ç¯‡ç»¼è¿°ï¼Œé˜è¿°äº†ç»†èƒèº«ä»½(Cellular Identity)ç ”ç©¶çš„ç›®çš„ï¼Œä»¥åŠåŸºäºé«˜é€šé‡æµ‹åºï¼ˆç‰¹åˆ«æ˜¯å•ç»†èƒæµ‹åºï¼‰ï¼Œæˆåƒä»¥åŠé—ä¼ å­¦ç­‰æ–°æ–¹æ³•æ¥ç¡®å®šç»†èƒèº«ä»½çš„æ–¹æ³•ã€‚ åœ¨ä½œè€…çœ‹æ¥ï¼Œç»†èƒç±»å‹é‰´å®šç ”ç©¶çš„ç›®çš„åˆ†ä¸ºä¸‰æ¡ï¼šï¼ˆå›¾ç‰‡å’Œå¼•ç”¨çš„è¯å‡æ¥è‡ªäºæ–‡çŒ®ï¼‰ Detecting features assoicated with a cell type from a pre-defined list of candidates; Identifying new features and cell types through unbiased approaches; Defining Cellular Relationships ä»åŸç†ä¸Šï¼Œé‰´å®šç»†èƒèº«ä»½çš„ä¸åŒfeatureå¯ä»¥æ¦‚æ‹¬å¦‚ä¸‹ï¼š Figure 1. Defining Cell Types æŸä¸ªç»†èƒç±»å‹çš„featureå¯ä»¥å¦‚ä½•ç ”ç©¶å‘¢ï¼Œè§ä¸‹ï¼š Figure 2. Strategies to Detect Molecular Features Associated with a Cell Type ä¸åŒç±»å‹ä¹‹é—´çš„ç»†èƒä¹‹é—´çš„å…³ç³»çš„ç ”ç©¶è§ä¸‹ï¼š Figure 3. Strategies to Define Cellular Relationships å½“ç„¶åŒä¸€ç±»å‹çš„ç»†èƒåœ¨ä¸åŒç»„ç»‡æˆ–è€…ç”Ÿç†æ¡ä»¶ä¸‹ä¼šå‘ˆç°ä¸åŒçš„åŠŸèƒ½ã€‚ Figure 4. Cellular Functions Vary with Context è®¨è®ºéƒ¨åˆ†æœ€å–œæ¬¢çš„ä¸€æ®µè¯æ˜¯ï¼š &gt; Together, our rapidly expanding capability to detect features and functions are revealing that \"cell type\" that were percevied as monolithic and stable in fact represent composites of multiple cells with distinguishable molecular signatures and have teh capability to adopt new features and functions in new contexts æ›´å¤šå†…å®¹è¯·é˜…è¯»åŸæ–‡ã€‚","categories":[{"name":"reference","slug":"reference","permalink":"https://landau1994.github.io/categories/reference/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"scRNA-seq","slug":"scRNA-seq","permalink":"https://landau1994.github.io/tags/scRNA-seq/"},{"name":"cell biology","slug":"cell-biology","permalink":"https://landau1994.github.io/tags/cell-biology/"},{"name":"sc-seq","slug":"sc-seq","permalink":"https://landau1994.github.io/tags/sc-seq/"}]},{"title":"Learn-SciBet","slug":"Learn-scibet","date":"2020-05-15T14:16:52.000Z","updated":"2025-01-11T17:16:31.815Z","comments":true,"path":"2020/05/15/Learn-scibet/","link":"","permalink":"https://landau1994.github.io/2020/05/15/Learn-scibet/","excerpt":"","text":"1. èƒŒæ™¯ä»‹ç» ç»†èƒç±»å‹æ³¨é‡Šæ˜¯scRNA-seqé‡Œéå¸¸åŸºç¡€çš„ä¸€æ­¥ï¼Œå¸¸è§çš„ç­–ç•¥æ˜¯å°†åŸºäºæ— ç›‘ç£åˆ†ç¾¤ç»“æœçš„åŸºå› å·®å¼‚è¡¨è¾¾åˆ†æç»“æœä½œä¸ºmarker,ç»“åˆå…ˆéªŒçŸ¥è¯†ï¼Œåˆ¤æ–­è¯¥åˆ†ç¾¤ä¸ºä½•ç§ç±»å‹ã€‚ è¿‘å¹´æ¥ï¼Œéšç€scRNA-seqçš„æ•°æ®é›†çš„é€æ¸ç§¯ç´¯ï¼Œä¹Ÿæœ‰å¾ˆå¤šç ”ç©¶ç»„æå‡ºäº†ä¸€äº›åŸºäºå·²æœ‰åˆ†ç¾¤ç»“æœè¿›è¡Œæœ‰ç›‘ç£çš„ç»†èƒç±»å‹æ³¨é‡Šçš„æ–¹æ³•ï¼Œæ¯”å¦‚scmapï¼Œæˆ–è€…Seuraté‡Œçš„TransferDataã€‚æ­¤å¤–ï¼Œä¹Ÿæœ‰è¯„ä¼°ç›¸å…³æ–¹æ³•çš„benchmarkç ”ç©¶ï¼š SciBetæ˜¯å¼ æ³½æ°‘è€å¸ˆç»„æœ€è¿‘æ–°å‘è¡¨çš„ä¸€ä¸ªå¿«æ·ï¼ˆå®æµ‹çœŸçš„æ¯”Seuratçš„TransferDataå¿«ï¼Œè€Œä¸”æ•ˆæœç¡®å®å·®ä¸å¤šï¼‰ï¼Œæ–¹ä¾¿çš„è¿›è¡Œæœ‰ç›‘ç£çš„ç»†èƒç±»å‹æ³¨é‡Šçš„æ–¹æ³•ã€‚è®ºæ–‡è§SciBet as a portable and fast single cell type identifierï¼Œç›¸å…³æŠ¥é“è§Nature Communications | å¼ æ³½æ°‘è¯¾é¢˜ç»„å‘è¡¨å•ç»†èƒè½¬å½•ç»„æ•°æ®å¿«é€Ÿæ³¨é‡Šæ–°æ–¹æ³• 2. æ–¹æ³•åŸç†ç®€ä»‹ å¦‚æœè¯»è€…åªå¯¹è½¯ä»¶ä½¿ç”¨æ„Ÿå…´è¶£çš„æœ¬èŠ‚å¯ä»¥ç•¥è¿‡ã€‚ æ ¹æ®ä¸Šé¢æåˆ°çš„é‚£ç¯‡æŠ¥é“ï¼Œå¦‚æœç”¨ä¸€å¥è¯æ¦‚æ‹¬SciBetçš„åŸç†ï¼Œåº”è¯¥æ˜¯è¿™æ ·çš„ï¼š å¼ æ³½æ°‘å®éªŒå®¤çš„åšå£«ç”Ÿæè¾°å¨ã€åˆ˜å®ç³è”åˆä»»ä»™æ–‡å‰¯ç ”ç©¶å‘˜å¼€å‘çš„SciBetåˆ™æœ‰æ•ˆåœ°è§£å†³äº†è¿™ä¸€é—®é¢˜ï¼šä»–ä»¬ä»â€œåŒä¸€ç±»å‹çš„å•ç»†èƒè¡¨è¾¾è°±æœä»åŒä¸€å¤šé¡¹åˆ†å¸ƒâ€è¿™ä¸€åŸºæœ¬å‡è®¾å‡ºå‘ï¼Œå¯¹è®­ç»ƒé›†æ•°æ®ä¸­ä¸åŒç»†èƒç±»å‹åˆ†åˆ«è¿›è¡Œå»ºæ¨¡ï¼Œè¿›è€Œé€šè¿‡æå¤§ä¼¼ç„¶ä¼°è®¡æ¥å¯¹æµ‹è¯•é›†ç»†èƒè¿›è¡Œæœ‰ç›‘ç£æ³¨é‡Šã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬æ ¹æ®ä½œè€…è®ºæ–‡çš„æ–¹æ³•éƒ¨åˆ†å’Œè¡¥å……ææ–™ï¼Œå­¦ä¹ ä¸€ä¸‹è¿™ä¸ªå·§å¦™åœ°æ€è·¯ã€‚åˆ†ä¸ºå¦‚ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š é¢„å¤‡çŸ¥è¯† å•ç»†èƒè¡¨è¾¾è°±çš„ç»Ÿè®¡æ¨¡å‹ æ ¹æ®è¡¨è¾¾è°±è®¡ç®—ä¿¡æ¯ç†µ E-test æ„å»ºæœ‰ç›‘ç£çš„ç»†èƒç±»å‹åˆ†ç±»æ¨¡å‹ æˆ‘ä»¬å‡å®šè¯»è€…å·²ç»ä¿®è¿‡æ¦‚ç‡è®ºç­‰ç›¸å…³è¯¾ç¨‹ã€‚ 2.1 é¢„å¤‡çŸ¥è¯† é¢„å¤‡çŸ¥è¯†1ï¼š æˆ‘ä»¬éœ€è¦å‘è¯»è€…å›é¡¾å…³äºè´ŸäºŒé¡¹åˆ†å¸ƒçš„çŸ¥è¯†ï¼Œå¦‚æœä¸€ä¸ªç¦»æ•£éšæœºå˜é‡çš„pmf(probability mass function)ä¸º: é‚£ä¹ˆæˆ‘ä»¬ç§°å…¶æœä»è´ŸäºŒé¡¹åˆ†å¸ƒã€‚è®°ä¸ºã€‚ é¢„å¤‡çŸ¥è¯†2ï¼š å¯¹äºä¸¤ä¸ªéšæœºå˜é‡å’Œï¼Œåœ¨ç»™å®šä¸‹ï¼ŒYçš„æ¡ä»¶pmfä¸ºï¼š é¢„å¤‡çŸ¥è¯†3ï¼š å…³äºè´ŸäºŒé¡¹åˆ†å¸ƒï¼Œæœ‰å¦‚ä¸‹ç»“è®ºï¼š å¯¹äºéšæœºå˜é‡ï¼Œè‹¥, åˆ™ å…¶ä¸­ è¯æ˜ï¼š å› ä¸ºï¼š æ‰€ä»¥ æ ¹æ®é¢„å¤‡çŸ¥è¯†3ï¼Œæˆ‘ä»¬æœ‰ï¼š é¢„å¤‡çŸ¥è¯†4ï¼š è´ŸäºŒé¡¹åˆ†å¸ƒæ˜¯æ³Šæ¾åˆ†å¸ƒå’Œä¼½é©¬åˆ†å¸ƒçš„æ··åˆåˆ†å¸ƒã€‚ é¢„å¤‡çŸ¥è¯†5(è¯¥ç»“è®ºä¸ºæ¦‚ç‡è®ºå’Œæ•°ç†ç»Ÿè®¡çš„å¸¸è¯†)ï¼š å¯¹äºéšæœºå˜é‡çš„pdfä¸ºï¼Œåšå˜æ¢,å…¶ä¸­ä¸ºå•è°ƒå‡½æ•°ï¼ŒXå’ŒYå„è‡ªæ ·æœ¬ç©ºé—´çš„å’Œåˆ†åˆ«æ»¡è¶³ï¼š è‹¥åœ¨ä¸­è¿ç»­ä¸”é€†å˜æ¢åœ¨ä¸­è¿ç»­å¯å¾®ï¼Œåˆ™æ–°çš„éšæœºå˜é‡çš„pdfä¸ºï¼š è¯¥ç»“è®ºä¸ºStatistical Inference(Casella Bergerè‘—)ä¸­çš„å®šç†2.1.5ï¼Œè¯æ˜è§è¯¥ä¹¦ã€‚ é¢„å¤‡çŸ¥è¯†6ï¼ˆåªæœ‰è¿™ä¸ªç»“è®ºä½œè€…åœ¨è¡¥å……ææ–™é‡Œç»™äº†è¯æ˜ï¼‰ï¼š The scaling property of the Gamma distribution è‹¥ , åˆ™ è¯æ˜: ç”±é¢˜è®¾ï¼š æ ¹æ®é¢˜è®¾ï¼Œç”±é¢„å¤‡çŸ¥è¯†5,æœ‰ï¼š æ•… é¢„å¤‡çŸ¥è¯†6ï¼š è‹¥ç‹¬ç«‹åŒåˆ†å¸ƒæ ·æœ¬æœä», ä¸”è§‚æµ‹å€¼åˆ†åˆ«ä¸ºï¼Œåˆ™å‚æ•°çš„çŸ©ä¼°è®¡é‡å’Œæå¤§ä¼¼ç„¶ä¼°è®¡é‡ç›¸ç­‰ï¼Œå‡ä¸º è¯æ˜å¾ˆç®€å•ï¼Œåœ¨å¾ˆå¤šæ•™æä¹Ÿèƒ½æ‰¾åˆ°ï¼Œæ•…ä»ç•¥ã€‚ é¢„å¤‡çŸ¥è¯†7ï¼š è‹¥ç‹¬ç«‹åŒåˆ†å¸ƒæ ·æœ¬æœä», ä¸”è§‚æµ‹å€¼åˆ†åˆ«ä¸ºï¼Œåˆ™å‚æ•°çš„æå¤§ä¼¼ç„¶ä¼°è®¡æ»¡è¶³ï¼š è¯æ˜ï¼š ç”±é¢˜è®¾ï¼š æ•…å–å¯¹æ•°åæå¤§ä¼¼ç„¶å‡½æ•°ä¸ºï¼š ç”± è§£å¾— é¢„å¤‡çŸ¥è¯†8ï¼š è‹¥éšæœºå˜é‡çš„pdfä¸º,æ ·æœ¬ç©ºé—´ä¸º, å®šä¹‰information generating function: åˆ™ï¼š è¯æ˜ï¼š(ä¸¥æ ¼è¯æ˜çš„è¯ï¼Œå¾—è¦è€ƒè™‘å‡½æ•°å’Œæœ¬èº«çš„æ€§è´¨ï¼Œæˆ‘ä»¬è¿™é‡Œå‡å®šå®ƒä»¬å¯ä»¥æ»¡è¶³ç§¯åˆ†å·ä¸‹æ±‚å¯¼ï¼Œå¦‚æœè¦ä¸¥æ ¼çš„è¯ï¼Œè¯·å‚è€ƒæµ‹åº¦è®ºç›¸å…³æ•™æ) è€Œéšæœºå˜é‡çš„ä¿¡æ¯ç†µçš„å®šä¹‰ä¸ºï¼š æ•… é¢„å¤‡çŸ¥è¯†9ï¼š è‹¥ï¼Œåˆ™å…¶ä¿¡æ¯ç†µä¸º ç”±é¢„å¤‡çŸ¥è¯†8ç»è¿‡è®¡ç®—å³å¯è¯æ˜ï¼Œä»ç•¥ã€‚ é¢„å¤‡çŸ¥è¯†10ï¼š å¤šé¡¹åˆ†å¸ƒ æ³¨ï¼šæ›´å¤šå…³äºä¼½é©¬åˆ†å¸ƒçš„çŸ¥è¯†å¯è§ï¼šç†è§£Gammaåˆ†å¸ƒã€Betaåˆ†å¸ƒä¸Dirichletåˆ†å¸ƒ 2.2 å•ç»†èƒè¡¨è¾¾è°±çš„ç»Ÿè®¡æ¨¡å‹ ç»è¿‡å¤§é‡çš„ç»Ÿè®¡åˆ†æå’Œåç»­çš„å®éªŒéªŒè¯ï¼ˆç›¸å…³è¯æ®å¯å‚è€ƒè¿™ç¯‡æ–‡çŒ®ï¼‰æœ‰è¿™æ ·ä¸€ä¸ªç»éªŒæ€§çš„ç»“è®ºï¼š è§‚å¯Ÿåˆ°å•ç»†èƒåŸºå› è¡¨è¾¾çš„count(æ¯”å¦‚UMI count)çš„åˆ†å¸ƒå¯ä»¥ç”¨è´ŸäºŒé¡¹åˆ†å¸ƒå¾ˆå¥½çš„æ‹Ÿåˆ,ä¸”ç›¸åŒç»†èƒç±»å‹çš„å•ç»†èƒè¡¨è¾¾è°±æœä»åŒä¸€ä¸ªåˆ†å¸ƒã€‚ ç»“åˆ2.1ä¸­çš„é¢„å¤‡çŸ¥è¯†ï¼Œæˆ‘ä»¬å¯ä»¥å°†å•ç»†èƒåŸºå› è¡¨è¾¾çš„countè¡¨ç¤ºä¸ºæ³Šæ¾åˆ†å¸ƒçš„ä¼½é©¬åˆ†å¸ƒçš„æ··åˆåˆ†å¸ƒã€‚æ‰€ä»¥ä½œè€…å‚è€ƒäº†SAVERå¯ä»¥è¿›è¡Œå¦‚ä¸‹å»ºæ¨¡ï¼š å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰ä¸ªç»†èƒï¼Œä¸ªåŸºå› çš„åŸå§‹è¡¨è¾¾è°±æ•°æ®ï¼Œé‡Œé¢çš„æ•°å€¼ä¸ºreads countæˆ–è€…æ˜¯UMI countã€‚å¦‚æœæˆ‘ä»¬è®°è§‚å¯Ÿå¾—åˆ°ç»†èƒcçš„æŸä¸ªåŸºå› içš„UMI countä¸ºï¼Œé‚£ä¹ˆå¯¹äºåŒä¸€ç±»å‹çš„ç»†èƒè€Œè¨€ï¼Œæœ‰ï¼š å…¶ä¸­è¡¨ç¤ºåŸºå› åœ¨ç»†èƒä¸­çš„çœŸå®è¡¨è¾¾é‡ï¼Œè¡¨ç¤ºè¿™ä¸ªç»†èƒä¸­çš„UMIæ€»æ•°ï¼Œä¸æµ‹åºæ·±åº¦æœ‰å…³ã€‚è€Œåˆ™æ˜¯ä¸¤ä¸ªå‚æ•°è¡¨å¾æŸä¸ªç»†èƒç±»å‹ä¸­çš„åŸºå› çš„çœŸå®è¡¨è¾¾åˆ†å¸ƒçš„å‚æ•°ã€‚ æ¥ä¸‹æ¥çš„å¯ä»¥æ ¹æ®é¢„å¤‡çŸ¥è¯†é‡Œçš„ç»“è®ºè¿›è¡Œå‚æ•°ä¼°è®¡ï¼š ç”±é¢„å¤‡çŸ¥è¯†6ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“å¾—åˆ°è¿™ä¹Ÿä¸ºæˆ‘ä»¬å¸¸ç”¨çš„è¿›è¡Œnormalizedçš„ç­–ç•¥æä¾›äº†ä¸€ç§ä¾æ®ã€‚è€Œç”±é¢„å¤‡çŸ¥è¯†7ï¼Œæœ‰ã€‚ 2.3 æ ¹æ®è¡¨è¾¾æ•°æ®è®¡ç®—ä¿¡æ¯ç†µ ä¸æ˜¯æ‰€æœ‰çš„åŸºå› éƒ½æ˜¯å¯¹åç»­çš„ç»Ÿè®¡å­¦ä¹ æœ‰ç”¨çš„ï¼Œéœ€è¦è¿›è¡Œç‰¹å¾é€‰æ‹©ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒæŒ‘é€‰å‡ºé‚£äº›èƒ½è¡¨ç¤ºä¸åŒç¾¤ç»†èƒä¹‹é—´è¡¨è¾¾å·®å¼‚çš„åŸºå› ã€‚æœ¬æ–‡çš„æ–°æ„æ˜¯åŸºäºä¿¡æ¯ç†µ(ä¹Ÿå°±æ˜¯é¦™å†œç†µ)çš„æ¦‚å¿µå¼•å…¥äº†æ–°çš„è¿›è¡Œç‰¹å¾é€‰æ‹©çš„æ–¹æ³•ï¼šE-testã€‚åœ¨è®²E-testä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦çœ‹çœ‹ä½œè€…æ˜¯å¦‚ä½•å®ç°ä»è¡¨è¾¾é‡ä¸­è®¡ç®—ä¿¡æ¯ç†µçš„ã€‚ æ ¹æ®2.2æˆ‘ä»¬çŸ¥é“å¯ä»¥å°†è§‚æµ‹å¾—åˆ°å•ç»†èƒè¡¨è¾¾gene countè¡¨ç¤ºæˆä¸çœŸå®è¡¨è¾¾é‡çš„æ··åˆåˆ†å¸ƒï¼ŒçœŸæ­£èƒ½åæ˜ ä¸åŒç»†èƒä¹‹é—´è¡¨è¾¾å·®å¼‚çš„æ˜¯çš„åˆ†å¸ƒã€‚æ‰€ä»¥æ¥ä¸‹æ¥è¦è®¡ç®—çš„åˆ†å¸ƒçš„ä¿¡æ¯ç†µã€‚ å¯¹äºç›¸åŒç±»å‹çš„ç»†èƒè€Œè¨€ï¼Œæ ¹æ®2.1ä¸­çš„ç»“è®º9ï¼ŒçœŸå®è¡¨è¾¾é‡çš„ä¿¡æ¯ç†µä¸ºï¼š ç”¨ä»£å…¥ï¼ˆ1ï¼‰å¯å¾—ï¼š è®°ï¼š å¹¶ä¸”è®°ä¸ªç»†èƒçš„å¹³å‡normalizedè¡¨è¾¾é‡ä¸º, æ˜¾ç„¶æœ‰ æ ¹æ®ä¸Šè¿°è®°å·ï¼Œï¼ˆ1ï¼‰æœ€ç»ˆåŒ–ç®€ä¸ºï¼š æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è€ƒè™‘é“ä¸åŒçš„ç»†èƒç±»å‹ã€‚è‹¥ç»†èƒå±äºç»†èƒç±»å‹ï¼Œå®šä¹‰æ‰€æœ‰å±äºçš„ç»†èƒçš„å¹³å‡æ ‡å‡†åŒ–çš„è¡¨è¾¾é‡ä¸ºï¼Œæ ¹æ®ä¸Šé¢çš„ç»“è®ºï¼Œå¯å¾—ï¼š å…¶ä¸­ æ˜¯ç›´æ¥å¯ä»¥é€šè¿‡å®éªŒæ•°æ®è®¡ç®—çš„ï¼Œè€Œåˆ™éœ€è¦ä¼°è®¡ã€‚ä½œè€…å‡è®¾æ˜¯åªæ˜¯åŸºå› ç‰¹å¼‚çš„å‚æ•°ï¼Œä¹Ÿå°±æ˜¯ã€‚ç†ç”±å¦‚ä¸‹ï¼š è‹¥ä¸ºéšæœºå˜é‡çš„è§‚æµ‹å€¼ï¼Œå¦‚æœæˆ‘ä»¬è®°åŸºå› ä»ç»†èƒç±»å‹åˆ°ç»†èƒç±»å‹çš„è¡¨è¾¾é‡çš„fold changeä¸º, å¹¶ä¸”å‡è®¾ï¼Œé‚£ä¹ˆç”±2.1ä¸­çš„é¢„å¤‡çŸ¥è¯†6ï¼Œå¯çŸ¥ ã€‚ æ•…, ç»“åˆï¼ˆ6ï¼‰ï¼Œ æœ€ç»ˆï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° 2.4 E-test é¦–å…ˆï¼Œé›¶å‡è®¾ä¸ºæ‰€æœ‰ä¸åŒç±»å‹ç»†èƒéƒ½æ˜¯ä»åŒä¸€ä¸ªç»†èƒç±»å‹ï¼ˆè®°ä¸º group 0ï¼‰ä¸­å‡åŒ€éšæœºé‡‡æ ·ï¼Œé‚£ä¹ˆåŸºå› çš„å¹³å‡è¡¨è¾¾é‡ä¸º, åˆ™group 0 çš„ä¿¡æ¯ç†µå¯ä»¥è®¡ç®—ä¸ºï¼š æ¥ç€è®¡ç®—åŸºå› åœ¨æ‰€æœ‰ç»†èƒç±»å‹ä¸­ä¸group 0 çš„ä¿¡æ¯ç†µçš„å·®ä¹‹å’Œï¼š (8)-(7)å¹¶æ±‚å’Œï¼Œå¾—ï¼š å…¶ä¸­ åˆ©ç”¨Jesenä¸ç­‰å¼å¯ä»¥è¯æ˜ï¼Œæ•… è‹¥è¦è¿›è¡Œå‡è®¾æ£€éªŒï¼Œè¿˜éœ€è¦è®¡ç®—çš„æ˜¾è‘—æ€§ï¼Œä½œè€…çš„ç­–ç•¥æ˜¯åŸºäºç½®æ¢æ£€éªŒçš„ï¼š è‹¥æ‰€æœ‰é¢„å…ˆå®šä¹‰åˆ†ç¾¤çš„ç»†èƒç±»å‹çš„ç»†èƒå‡æ¥è‡ªåŒä¸€ä¸ªæ ·æœ¬ï¼Œåˆ™å¯¹ä»»æ„çš„æ ‡ç­¾ä¸ºç»†èƒç±»å‹çš„ç»†èƒçš„size-factor normalizedçš„è¡¨è¾¾é‡ï¼Œæ ¹æ®ä¸­å¿ƒæé™å®šç†ï¼Œå•ç»†èƒæ•°ç›®è¶³å¤Ÿå¤šçš„æ—¶å€™ï¼Œï¼Œå¾ˆå®¹æ˜“å¾—åˆ°å‚æ•°çš„æ— åä¼°è®¡ï¼Œæ‰€ä»¥ç½®æ¢è¢«ç®€åŒ–æˆäº†æ¯æ¬¡ä»åˆ†å¸ƒnä¸ªä¸åŒçš„éšæœºæ•°ã€‚æ¥ä¸‹æ¥å°±æ˜¯è¿™ä¹ˆç”Ÿæˆä¸€ä¸ªçš„åˆ†å¸ƒï¼Œç„¶åè®¡ç®—è¿™ä¸ªåˆ†å¸ƒä¸­å¤§äºä»çœŸå®æ•°æ®ä¸­æµ‹å¾—çš„æ¯”ä¾‹ï¼Œä½œä¸ºæ˜¾è‘—æ€§ã€‚ é»˜è®¤çš„Featureä¸º500ä¸ªåŸºå› ã€‚ 2.5 æ„å»ºæœ‰ç›‘ç£å­¦ä¹ çš„æ¨¡å‹ æ ¹æ®2.4ï¼Œåœ¨è®­ç»ƒé›†ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œç‰¹å¾é€‰æ‹©é€‰å‡ºä¸€äº›â€œinformative geneâ€è¿›è¡Œæ¨¡å‹è®­ç»ƒã€‚ ä½œè€…å‡è®¾ä»ç›¸åŒçš„è½¬å½•å‡ºçš„mRNAæ˜¯ä¸å¯åŒºåˆ†çš„ï¼Œè€Œä¸”æ¯ä¸ªmRNAçš„äº§ç”Ÿæ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œè®°å½•å¯¹äºç»†èƒç±»å‹ä¸ºçš„ç»†èƒï¼ŒåŸºå› äº§ç”Ÿä¸€ä¸ªmRNAçš„æ¦‚ç‡ä¸º,è‹¥æœ‰ä¸ªinformative gene åˆ™å¯¹ç»†èƒç±»å‹,æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªéšæœºå‘é‡å…¶ä¸­ä¸”å…¶æœä»å¤šé¡¹å¼åˆ†å¸ƒ,åˆ™ å¯¹äºå±äºç»†èƒç±»å‹çš„ç»†èƒï¼Œå…¶åéªŒè¡¨è¾¾è°±å¯ä»¥è®¡ç®—ä¸ºï¼š å…¶ä¸­æ¦‚ç‡å¯ä¼°è®¡ä¸º åŒæ ·çš„ï¼Œåœ¨æµ‹è¯•é›†ä¸­ï¼ŒæœªçŸ¥ç»†èƒç±»å‹çš„ç»†èƒå±äºç»†èƒç±»å‹çš„æ¦‚ç‡ä¹Ÿä¸º å…¶ä¸­æ˜¯è®­ç»ƒé›†ä¸­å­¦ä¹ åˆ°çš„å‚æ•°ã€‚ å¦‚æœï¼Œæˆ‘ä»¬å¼•å…¥,ç”±æå¤§ä¼¼ç„¶çš„åŸåˆ™å¯çŸ¥ï¼Œç»†èƒæœ€æœ‰å¯èƒ½çš„ç»†èƒç±»å‹ä¸º 2.6 æ–¹æ³•æ€»ç»“ å¯ä»¥ç”¨åŸæ–‡çŒ®ä¸­çš„æµå›¾å¯¹SciBetè¿›è¡Œæ€»ç»“ï¼š 3. è½¯ä»¶ä½¿ç”¨ 3.1 åœ¨çº¿ç‰ˆ åœ¨çº¿ç‰ˆä½¿ç”¨è¯·æŒ‰ç…§å®˜ç½‘çš„Online classificationæ•™ç¨‹ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œä½œè€…æä¾›äº†å¾ˆä»ä¸åŒç»„ç»‡ï¼Œä¸åŒå®éªŒæ¡ä»¶çš„å•ç»†èƒæµ‹åºæ•°æ®ä¸­è®­ç»ƒå¥½çš„Signatureï¼š è¿™äº›ä¸åŒçš„signatureå¯ä»¥ä¾›ä¸åŒç ”ç©¶è€…ç»“åˆè‡ªå·±çš„å…´è¶£ä½¿ç”¨ã€‚ 3.2 æœ¬åœ°ç‰ˆ 3.2.1 å®‰è£… if (!requireNamespace(\"devtools\", quietly = TRUE)) install.packages(\"devtools\") devtools::install_github(\"PaulingLiu/scibet\") å¦‚æœå‡ºç°é”™è¯¯ï¼Œè¯·çœ‹ç›¸å…³issue 3.2.2 ä½œè€…æä¾›çš„æµ‹è¯•æ•°æ® æŒ‰ç…§å®˜ç½‘çš„æ•™ç¨‹E-test and SciBetï¼›ä¸‹è½½æ‰€éœ€çš„æ•°æ®ï¼›ç„¶ååæŒ‰ç…§å…¶è¯´æ˜æ–‡æ¡£è¿›è¡Œå³å¯ã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬çœ‹å¦‚ä½•ç”¨ä½¿ç”¨SciBetç»“åˆSeuratè¿›è¡Œå•ç»†èƒåˆ†æã€‚ 3.2.3 SciBetç»“åˆSeurat ä¸ºäº†è¯´æ˜é—®é¢˜ï¼Œæˆ‘ä»¬é€‰æ‹©Seuratè‡ªå¸¦çš„pbmcscaæ•°æ®é›†, è¯¥æ•°æ®é›†å·²ç»æä¾›äº†é¢„å…ˆå®šä¹‰å¥½çš„ç»†èƒæ ‡ç­¾ï¼Œä»£ç å¦‚ä¸‹ï¼š library(Seurat) library(pbmcsca.SeuratData) library(ggplot2) library(scibet) library(tidyverse) library(viridis) ####0.---define utilized function-------- ####---Export expr data from 10x to tibble---- #' @param seuv3 a seuv3 object #' myGetExpr &lt;- function(seuv3,...){ expr &lt;- GetAssayData(object = seuv3, slot = \"data\") expr &lt;- as_tibble(t(as.matrix(expr)),rownames = NA) return(expr) } ###1.load data and preprocessing data(\"pbmcsca\") ###---avoid warning----- pbmcsca &lt;- UpdateSeuratObject(pbmcsca) ###---show predifined cell type------ table(pbmcsca$CellType) # B cell CD14+ monocyte # 5020 5550 # CD16+ monocyte CD4+ T cell # 804 7391 # Cytotoxic T cell Dendritic cell # 9071 433 # Megakaryocyte Natural killer cell # 977 1565 # Plasmacytoid dendritic cell Unassigned # 164 46 ###---split data----- pbmc.list &lt;- SplitObject(pbmcsca, split.by = \"Method\") ###---normalize------- for (i in names(pbmc.list)) { pbmc.list[[i]] &lt;- NormalizeData(pbmc.list[[i]], verbose = FALSE) } names(pbmc.list) [1] \"Smart-seq2\" \"CEL-Seq2\" \"10x Chromium (v2) A\" [4] \"10x Chromium (v2) B\" \"10x Chromium (v3)\" \"Drop-seq\" [7] \"Seq-Well\" \"inDrops\" \"10x Chromium (v2)\" æµ‹è¯• reference baseæ¨¡å¼çš„æ•ˆæœ ###----2. test scibet---- ###----define reference and query----- reference &lt;- pbmc.list[[1]] query &lt;- pbmc.list[[2]] ###----test query reference mode---- reference.expr &lt;- myGetExpr(reference) query.expr &lt;- myGetExpr(query) reference.label &lt;- as.character(reference$CellType) test.label &lt;- as.character(query$CellType) reference.expr &lt;- cbind(reference.expr,label=reference.label) prd.label &lt;- SciBet(train = reference.expr, test = query.expr) Confusion_heatmap(test.label, prd.label) ggsave(filename = \"res/fig/learn_scibet_confusionheatmap_refmode.pdf\", width = 6,height = 6) å‡†ç¡®ç‡ä¸º num1 &lt;- length(test.label) num2 &lt;- tibble( ori = test.label, prd = prd.label ) %&gt;% dplyr::filter(ori == prd) %&gt;% nrow(.) num2/num1 0.851711 æµ‹è¯•ç”¨ä½œè€…æä¾›çš„è®­ç»ƒå¥½çš„æ¨¡å‹ ###----test load_model mode----- ###using 30 major cell types signature---- model &lt;- readr::read_csv(file = \"http://scibet.cancer-pku.cn/major_human_cell_types.csv\") model &lt;- pro.core(model) prd &lt;- LoadModel(model) prd.label &lt;- prd(query.expr) Confusion_heatmap(test.label,prd.label) ggsave(filename = \"res/fig/learn_scibet_confusionheatmap_signaturemode.pdf\", width = 6,height = 6)","categories":[{"name":"genomics","slug":"genomics","permalink":"https://landau1994.github.io/categories/genomics/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"scRNA-seq","slug":"scRNA-seq","permalink":"https://landau1994.github.io/tags/scRNA-seq/"}]},{"title":"LearnSeurat_PBMC3k","slug":"LearnSeurat-PBMC3k","date":"2020-05-10T11:55:56.000Z","updated":"2025-01-11T17:16:31.818Z","comments":true,"path":"2020/05/10/LearnSeurat-PBMC3k/","link":"","permalink":"https://landau1994.github.io/2020/05/10/LearnSeurat-PBMC3k/","excerpt":"","text":"æœ¬ç³»åˆ—å‡å®šè¯»è€…å¯¹äºå•ç»†èƒæµ‹åºçš„æ•°æ®åˆ†æå’ŒSeuratçš„å®˜æ–¹æ•™ç¨‹æœ‰æ‰€äº†è§£ã€‚ æœ¬ç¯‡ç ”ç©¶æœ€åŸºç¡€çš„PBMC3kã€‚å…¶å®è¿™é‡Œåªæœ‰2700ä¸ªå¤–å‘¨è¡€çš„ç»†èƒã€‚æ³¨æ„åˆ°ï¼Œç”±äºå–æ ·æ˜¯å¤–å‘¨è¡€ï¼Œæ²¡æœ‰å¹²ç»†èƒçš„å­˜åœ¨ï¼Œæ‰€ä»¥å¯ä»¥è®¤ä¸ºæ ·å“å¤„äºç¨³æ€ã€‚è¿™ä¸ªæ•™ç¨‹å°±æ˜¯è®²ç¨³æ€ä¸‹çš„å•ç»†èƒæµ‹åºåˆ†ææ˜¯å¦‚ä½•è¿›è¡Œçš„ã€‚Seuratçš„å®˜æ–¹æ•™ç¨‹çš„ç¼ºç‚¹ä¹‹ä¸€å°±æ˜¯æ²¡æœ‰æ¶‰åŠåŠ¨æ€è¿‡ç¨‹çš„å•ç»†èƒåˆ†æå¦‚ä½•è¿›è¡Œã€‚ å¦‚æ— ç‰¹æ®Šè¯´æ˜ï¼Œæœ¬ç³»åˆ—çš„ä»£ç å‡å¯ä»¥åœ¨è‡ªå·±çš„ç¬”è®°æœ¬ç”µè„‘ä¸Šè¿è¡Œï¼› 1. æ„å»ºSeurat object ä½¿ç”¨ä½œè€…å·²ç»æ„å»ºå¥½çš„æ•°æ®è¿›è¡Œæ„å»ºã€‚å…³äºSeuratæ›´è¯¦ç»†çš„æ–‡æ¡£å¯è§satijalabçš„wiki library(Seurat) library(SeuratData) library(ggplot2) library(igraph) library(tidyverse) library(patchwork) ### AvailableData() check avaliable data: we choose cbmc ### InstallData('pbmc3k') library(pbmc3k.SeuratData) ### how this dataset generate? # ## Not run: # if (requireNamespace(Seurat, quietly = TRUE)) { # url &lt;- 'http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz' # curl::curl_download(url = url, destfile = basename(path = url)) # untar(tarfile = basename(path = url)) # pbmc.data &lt;- Seurat::Read10X(data.dir = 'filtered_gene_bc_matrices/hg19/') # pbmc3k &lt;- Seurat::CreateSeuratObject(counts = pbmc.data, project = 'pbmc3k', min.cells = 3, min.features = 200) # # Annotations come from Seurat's PBMC3k Guided Clustering Tutorial # # https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html # annotations &lt;- readRDS(file = system.file('extdata/annotations/annotations.Rds', package = 'pbmc3k.SeuratData')) # pbmc3k &lt;- Seurat::AddMetaData(object = pbmc3k, metadata = annotations) # # Clean up downloaded files # file.remove(basename(path = url)) # unlink(x = 'filtered_gene_bc_matrices/', recursive = TRUE) # } # # ## End(Not run) ### how Create Seurat object work? ### by run `Seurat::CreateSeuratObject` you can get the source function # ## Not run: # Seurat::CreateSeuratObject # function (counts, project = \"SeuratProject\", assay = \"RNA\", # min.cells = 0, min.features = 0, names.field = 1, names.delim = \"_\", # meta.data = NULL) # { # if (!is.null(x = meta.data)) { # if (is.null(x = rownames(x = meta.data))) { # stop(\"Row names not set in metadata. Please ensure that rownames of metadata match column names of data matrix\") # } # if (length(x = setdiff(x = rownames(x = meta.data), y = colnames(x = counts)))) { # warning(\"Some cells in meta.data not present in provided counts matrix.\") # meta.data &lt;- meta.data[intersect(x = rownames(x = meta.data), # y = colnames(x = counts)), ] # } # if (is.data.frame(x = meta.data)) { # new.meta.data &lt;- data.frame(row.names = colnames(x = counts)) # for (ii in 1:ncol(x = meta.data)) { # new.meta.data[rownames(x = meta.data), colnames(x = meta.data)[ii]] &lt;- meta.data[, # ii, drop = FALSE] # } # meta.data &lt;- new.meta.data # } # } # assay.data &lt;- CreateAssayObject(counts = counts, min.cells = min.cells, # min.features = min.features) # Key(object = assay.data) &lt;- paste0(tolower(x = assay), \"_\") # assay.list &lt;- list(assay.data) # names(x = assay.list) &lt;- assay # init.meta.data &lt;- data.frame(row.names = colnames(x = assay.list[[assay]])) # idents &lt;- factor(x = unlist(x = lapply(X = colnames(x = assay.data), # FUN = ExtractField, field = names.field, delim = names.delim))) # if (any(is.na(x = idents))) { # warning(\"Input parameters result in NA values for initial cell identities. Setting all initial idents to the project name\") # } # ident.levels &lt;- length(x = unique(x = idents)) # if (ident.levels &gt; 100 || ident.levels == 0 || ident.levels == # length(x = idents)) { # idents &lt;- rep.int(x = factor(x = project), times = ncol(x = assay.data)) # } # names(x = idents) &lt;- colnames(x = assay.data) # object &lt;- new(Class = \"Seurat\", assays = assay.list, # meta.data = init.meta.data, active.assay = assay, active.ident = idents, # project.name = project, version = packageVersion(pkg = \"Seurat\")) # object[[\"orig.ident\"]] &lt;- idents # n.calc &lt;- CalcN(object = assay.data) # if (!is.null(x = n.calc)) { # names(x = n.calc) &lt;- paste(names(x = n.calc), assay, # sep = \"_\") # object[[names(x = n.calc)]] &lt;- n.calc # } # if (!is.null(x = meta.data)) { # object &lt;- AddMetaData(object = object, metadata = meta.data) # } # return(object) # } # # Seurat:: CreateAssayObject # function (counts, data, min.cells = 0, min.features = 0) # { # if (missing(x = counts) &amp;&amp; missing(x = data)) { # stop(\"Must provide either 'counts' or 'data'\") # } # else if (!missing(x = counts) &amp;&amp; !missing(x = data)) { # stop(\"Either 'counts' or 'data' must be missing; both cannot be provided\") # } # else if (!missing(x = counts)) { # if (anyDuplicated(rownames(x = counts))) { # warning(\"Non-unique features (rownames) present in the input matrix, making unique\", # call. = FALSE, immediate. = TRUE) # rownames(x = counts) &lt;- make.unique(names = rownames(x = counts)) # } # if (anyDuplicated(colnames(x = counts))) { # warning(\"Non-unique cell names (colnames) present in the input matrix, making unique\", # call. = FALSE, immediate. = TRUE) # colnames(x = counts) &lt;- make.unique(names = colnames(x = counts)) # } # if (is.null(x = colnames(x = counts))) { # stop(\"No cell names (colnames) names present in the input matrix\") # } # if (any(rownames(x = counts) == \"\")) { # stop(\"Feature names of counts matrix cannot be empty\", # call. = FALSE) # } # if (nrow(x = counts) &gt; 0 &amp;&amp; is.null(x = rownames(x = counts))) { # stop(\"No feature names (rownames) names present in the input matrix\") # } # if (!inherits(x = counts, what = \"dgCMatrix\")) { # counts &lt;- as(object = as.matrix(x = counts), Class = \"dgCMatrix\") # } # if (min.features &gt; 0) { # nfeatures &lt;- Matrix::colSums(x = counts &gt; 0) # counts &lt;- counts[, which(x = nfeatures &gt;= min.features)] # } # if (min.cells &gt; 0) { # num.cells &lt;- Matrix::rowSums(x = counts &gt; 0) # counts &lt;- counts[which(x = num.cells &gt;= min.cells), # ] # } # data &lt;- counts # } # else if (!missing(x = data)) { # if (anyDuplicated(rownames(x = data))) { # warning(\"Non-unique features (rownames) present in the input matrix, making unique\", # call. = FALSE, immediate. = TRUE) # rownames(x = data) &lt;- make.unique(names = rownames(x = data)) # } # if (anyDuplicated(colnames(x = data))) { # warning(\"Non-unique cell names (colnames) present in the input matrix, making unique\", # call. = FALSE, immediate. = TRUE) # colnames(x = data) &lt;- make.unique(names = colnames(x = data)) # } # if (is.null(x = colnames(x = data))) { # stop(\"No cell names (colnames) names present in the input matrix\") # } # if (any(rownames(x = data) == \"\")) { # stop(\"Feature names of data matrix cannot be empty\", # call. = FALSE) # } # if (nrow(x = data) &gt; 0 &amp;&amp; is.null(x = rownames(x = data))) { # stop(\"No feature names (rownames) names present in the input matrix\") # } # if (min.cells != 0 | min.features != 0) { # warning(\"No filtering performed if passing to data rather than counts\", # call. = FALSE, immediate. = TRUE) # } # counts &lt;- new(Class = \"matrix\") # } # if (!is.vector(x = rownames(x = counts))) { # rownames(x = counts) &lt;- as.vector(x = rownames(x = counts)) # } # if (!is.vector(x = colnames(x = counts))) { # colnames(x = counts) &lt;- as.vector(x = colnames(x = counts)) # } # if (!is.vector(x = rownames(x = data))) { # rownames(x = data) &lt;- as.vector(x = rownames(x = data)) # } # if (!is.vector(x = colnames(x = data))) { # colnames(x = data) &lt;- as.vector(x = colnames(x = data)) # } # if (any(grepl(pattern = \"_\", x = rownames(x = counts))) || # any(grepl(pattern = \"_\", x = rownames(x = data)))) { # warning(\"Feature names cannot have underscores ('_'), replacing with dashes ('-')\", # call. = FALSE, immediate. = TRUE) # rownames(x = counts) &lt;- gsub(pattern = \"_\", replacement = \"-\", # x = rownames(x = counts)) # rownames(x = data) &lt;- gsub(pattern = \"_\", replacement = \"-\", # x = rownames(x = data)) # } # if (any(grepl(pattern = \"|\", x = rownames(x = counts), # fixed = TRUE)) || any(grepl(pattern = \"|\", x = rownames(x = data), # fixed = TRUE))) { # warning(\"Feature names cannot have pipe characters ('|'), replacing with dashes ('-')\", # call. = FALSE, immediate. = TRUE) # rownames(x = counts) &lt;- gsub(pattern = \"|\", replacement = \"-\", # x = rownames(x = counts), fixed = TRUE) # rownames(x = data) &lt;- gsub(pattern = \"|\", replacement = \"-\", # x = rownames(x = data), fixed = TRUE) # } # init.meta.features &lt;- data.frame(row.names = rownames(x = data)) # assay &lt;- new(Class = \"Assay\", counts = counts, data = data, # scale.data = new(Class = \"matrix\"), meta.features = init.meta.features) # return(assay) # } ###update object to avoid warning. data(\"pbmc3k\") pbmc &lt;- UpdateSeuratObject(pbmc3k) rm(pbmc3k) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features) 2. åŸºæœ¬é¢„å¤„ç† ä½œè€…åœ¨åŸæ•™ç¨‹è¯´ï¼š The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable features. 2.1 ç»†èƒè´¨æ§ ä¸‰ç§åŸºæœ¬çš„QC metrics The number of unique genes detected in each cell. Low-quality cells or empty droplets will often have very few genes Cell doublets or multiplets may exhibit an aberrantly high gene count Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes) The percentage of reads that map to the mitochondrial genome Low-quality / dying cells often exhibit extensive mitochondrial contamination We calculate mitochondrial QC metrics with the PercentageFeatureSet function, which calculates the percentage of counts originating from a set of features We use the set of all genes starting with MT- as a set of mitochondrial genes æ³¨æ„ï¼Œäººçš„çº¿ç²’ä½“åŸºå› æ˜¯â€œMT-â€å¼€å¤´ï¼Œè€Œå°é¼ çš„çº¿ç²’ä½“åŸºå› æ˜¯â€œmt-â€å¼€å¤´ # The [[ operator can add columns to object metadata. This is a great place to stash QC stats ### how does PercentageFeatureSet work # PercentageFeatureSet # function (object, pattern = NULL, features = NULL, col.name = NULL, # assay = NULL) # { # assay &lt;- assay %||% DefaultAssay(object = object) # if (!is.null(x = features) &amp;&amp; !is.null(x = pattern)) { # warning(\"Both pattern and features provided. Pattern is being ignored.\") # } # features &lt;- features %||% grep(pattern = pattern, x = rownames(x = object[[assay]]), # value = TRUE) # percent.featureset &lt;- colSums(x = GetAssayData(object = object, # assay = assay, slot = \"counts\")[features, , drop = FALSE])/object[[paste0(\"nCount_\", # assay)]] * 100 # if (!is.null(x = col.name)) { # object &lt;- AddMetaData(object = object, metadata = percent.featureset, # col.name = col.name) # return(object) # } # return(percent.featureset) # } pbmc[[\"percent.mt\"]] &lt;- PercentageFeatureSet(pbmc, pattern = \"^MT-\") # Show QC metrics for the first 5 cells head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA seurat_annotations percent.mt ## AAACATACAACCAC pbmc3k 2419 779 Memory CD4 T 3.0177759 ## AAACATTGAGCTAC pbmc3k 4903 1352 B 3.7935958 ## AAACATTGATCAGC pbmc3k 3147 1129 Memory CD4 T 0.8897363 ## AAACCGTGCTTCCG pbmc3k 2639 960 CD14+ Mono 1.7430845 ## AAACCGTGTATGCG pbmc3k 980 521 NK 1.2244898 ç”±äºæˆ‘ä»¬ç”¨çš„æ˜¯ä½œè€…ç»™äº†metadataçš„æ•°æ®ï¼Œé‡Œé¢å·²ç»å‡ºç°äº†ç»†èƒç±»å‹çš„æ³¨é‡Šï¼Œè§seurat_annotationè¿™ä¸€é¡¹ï¼› QC metricçš„å¯è§†åŒ–ï¼š # Visualize QC metrics as a violin plot VlnPlot(pbmc, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3) # FeatureScatter is typically used to visualize feature-feature relationships, but can be used # for anything calculated by the object, i.e. columns in object metadata, PC scores etc. plot1 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\") plot2 &lt;- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\") plot1 + plot2 æœ€ç»ˆé€‰æ‹©çš„è´¨æ§æ ‡å‡†ä¸ºï¼š We filter cells that have unique feature counts over 2,500 or less than 200 We filter cells that have &gt;5% mitochondrial counts pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) 2.2 æ ‡å‡†åŒ– After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method â€œLogNormalizeâ€ that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in pbmc[[â€œRNAâ€]]@data. pbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000) 2.3 ç‰¹å¾é€‰æ‹© å“ªäº›åŸºå› èƒ½ååº”ä¸åŒç»†èƒä¹‹é—´çš„å¼‚è´¨æ€§ï¼Ÿæ˜¯é‚£äº›è¡¨è¾¾å·®å¼‚å¤§çš„åŸºå› ï¼› æ³¨æ„FindVariableFeaturesæ˜¯S3 genericï¼Œæ³›å‹å‡½æ•°ã€‚ å¦‚ä½•æŸ¥çœ‹ä¸€ä¸ªæ³›å‹å‡½æ•°çš„æºä»£ç å‘¢ï¼Œæˆ‘ä»¬å…ˆç”¨methodså‡½æ•°åŒ¹é…è¯¥èŒƒå‹å‡½æ•°çš„åå­—ï¼š methods(FindVariableFeatures) ## [1] FindVariableFeatures.Assay* FindVariableFeatures.default* ## [3] FindVariableFeatures.Seurat* ## see '?methods' for accessing help and source code æ˜Ÿå·è¡¨æ˜æˆ‘ä»¬ä¸èƒ½ç›´æ¥é€šè¿‡è¿è¡Œå‡½æ•°åå­—æ¥æŸ¥çœ‹å…¶æºä»£ç ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿è¡Œ getAnywhereå‡½æ•°æ¥è·å–è¿™ä¸ªå‡½æ•°ï¼Œ getAnywhere(FindVariableFeatures.Seurat) ## A single object matching 'FindVariableFeatures.Seurat' was found ## It was found in the following places ## registered S3 method for FindVariableFeatures from namespace Seurat ## namespace:Seurat ## with value ## ## function (object, assay = NULL, selection.method = \"vst\", loess.span = 0.3, ## clip.max = \"auto\", mean.function = FastExpMean, dispersion.function = FastLogVMR, ## num.bin = 20, binning.method = \"equal_width\", nfeatures = 2000, ## mean.cutoff = c(0.1, 8), dispersion.cutoff = c(1, Inf), verbose = TRUE, ## ...) ## { ## assay &lt;- assay %||% DefaultAssay(object = object) ## assay.data &lt;- GetAssay(object = object, assay = assay) ## assay.data &lt;- FindVariableFeatures(object = assay.data, selection.method = selection.method, ## loess.span = loess.span, clip.max = clip.max, mean.function = mean.function, ## dispersion.function = dispersion.function, num.bin = num.bin, ## binning.method = binning.method, nfeatures = nfeatures, ## mean.cutoff = mean.cutoff, dispersion.cutoff = dispersion.cutoff, ## verbose = verbose, ...) ## object[[assay]] &lt;- assay.data ## object &lt;- LogSeuratCommand(object = object) ## return(object) ## } ## &lt;bytecode: 0x0000000022fa2410&gt; ## &lt;environment: namespace:Seurat&gt; æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œé»˜è®¤çš„FindVariableFeatures.Seuratmethodè°ƒç”¨äº†FindVariableFeatures.Assayï¼š getAnywhere(FindVariableFeatures.Assay) ## A single object matching 'FindVariableFeatures.Assay' was found ## It was found in the following places ## registered S3 method for FindVariableFeatures from namespace Seurat ## namespace:Seurat ## with value ## ## function (object, selection.method = \"vst\", loess.span = 0.3, ## clip.max = \"auto\", mean.function = FastExpMean, dispersion.function = FastLogVMR, ## num.bin = 20, binning.method = \"equal_width\", nfeatures = 2000, ## mean.cutoff = c(0.1, 8), dispersion.cutoff = c(1, Inf), verbose = TRUE, ## ...) ## { ## if (length(x = mean.cutoff) != 2 || length(x = dispersion.cutoff) != ## 2) { ## stop(\"Both 'mean.cutoff' and 'dispersion.cutoff' must be two numbers\") ## } ## if (selection.method == \"vst\") { ## data &lt;- GetAssayData(object = object, slot = \"counts\") ## if (IsMatrixEmpty(x = data)) { ## warning(\"selection.method set to 'vst' but count slot is empty; will use data slot instead\") ## data &lt;- GetAssayData(object = object, slot = \"data\") ## } ## } ## else { ## data &lt;- GetAssayData(object = object, slot = \"data\") ## } ## hvf.info &lt;- FindVariableFeatures(object = data, selection.method = selection.method, ## loess.span = loess.span, clip.max = clip.max, mean.function = mean.function, ## dispersion.function = dispersion.function, num.bin = num.bin, ## binning.method = binning.method, verbose = verbose, ...) ## object[[names(x = hvf.info)]] &lt;- hvf.info ## hvf.info &lt;- hvf.info[which(x = hvf.info[, 1, drop = TRUE] != ## 0), ] ## if (selection.method == \"vst\") { ## hvf.info &lt;- hvf.info[order(hvf.info$vst.variance.standardized, ## decreasing = TRUE), , drop = FALSE] ## } ## else { ## hvf.info &lt;- hvf.info[order(hvf.info$mvp.dispersion, decreasing = TRUE), ## , drop = FALSE] ## } ## selection.method &lt;- switch(EXPR = selection.method, mvp = \"mean.var.plot\", ## disp = \"dispersion\", selection.method) ## top.features &lt;- switch(EXPR = selection.method, mean.var.plot = { ## means.use &lt;- (hvf.info[, 1] &gt; mean.cutoff[1]) &amp; (hvf.info[, ## 1] &lt; mean.cutoff[2]) ## dispersions.use &lt;- (hvf.info[, 3] &gt; dispersion.cutoff[1]) &amp; ## (hvf.info[, 3] &lt; dispersion.cutoff[2]) ## rownames(x = hvf.info)[which(x = means.use &amp; dispersions.use)] ## }, dispersion = head(x = rownames(x = hvf.info), n = nfeatures), ## vst = head(x = rownames(x = hvf.info), n = nfeatures), ## stop(\"Unkown selection method: \", selection.method)) ## VariableFeatures(object = object) &lt;- top.features ## vf.name &lt;- ifelse(test = selection.method == \"vst\", yes = \"vst\", ## no = \"mvp\") ## vf.name &lt;- paste0(vf.name, \".variable\") ## object[[vf.name]] &lt;- rownames(x = object[[]]) %in% top.features ## return(object) ## } ## &lt;bytecode: 0x000000002dc5d050&gt; ## &lt;environment: namespace:Seurat&gt; åƒå±‚é¥¼çš„æœ€åä¸€å±‚ï¼› getAnywhere(FindVariableFeatures.default) ## A single object matching 'FindVariableFeatures.default' was found ## It was found in the following places ## registered S3 method for FindVariableFeatures from namespace Seurat ## namespace:Seurat ## with value ## ## function (object, selection.method = \"vst\", loess.span = 0.3, ## clip.max = \"auto\", mean.function = FastExpMean, dispersion.function = FastLogVMR, ## num.bin = 20, binning.method = \"equal_width\", verbose = TRUE, ## ...) ## { ## CheckDots(...) ## if (!inherits(x = object, \"Matrix\")) { ## object &lt;- as(object = as.matrix(x = object), Class = \"Matrix\") ## } ## if (!inherits(x = object, what = \"dgCMatrix\")) { ## object &lt;- as(object = object, Class = \"dgCMatrix\") ## } ## if (selection.method == \"vst\") { ## if (clip.max == \"auto\") { ## clip.max &lt;- sqrt(x = ncol(x = object)) ## } ## hvf.info &lt;- data.frame(mean = rowMeans(x = object)) ## hvf.info$variance &lt;- SparseRowVar2(mat = object, mu = hvf.info$mean, ## display_progress = verbose) ## hvf.info$variance.expected &lt;- 0 ## hvf.info$variance.standardized &lt;- 0 ## not.const &lt;- hvf.info$variance &gt; 0 ## fit &lt;- loess(formula = log10(x = variance) ~ log10(x = mean), ## data = hvf.info[not.const, ], span = loess.span) ## hvf.info$variance.expected[not.const] &lt;- 10^fit$fitted ## hvf.info$variance.standardized &lt;- SparseRowVarStd(mat = object, ## mu = hvf.info$mean, sd = sqrt(hvf.info$variance.expected), ## vmax = clip.max, display_progress = verbose) ## colnames(x = hvf.info) &lt;- paste0(\"vst.\", colnames(x = hvf.info)) ## } ## else { ## if (!inherits(x = mean.function, what = \"function\")) { ## stop(\"'mean.function' must be a function\") ## } ## if (!inherits(x = dispersion.function, what = \"function\")) { ## stop(\"'dispersion.function' must be a function\") ## } ## feature.mean &lt;- mean.function(object, verbose) ## feature.dispersion &lt;- dispersion.function(object, verbose) ## names(x = feature.mean) &lt;- names(x = feature.dispersion) &lt;- rownames(x = object) ## feature.dispersion[is.na(x = feature.dispersion)] &lt;- 0 ## feature.mean[is.na(x = feature.mean)] &lt;- 0 ## data.x.breaks &lt;- switch(EXPR = binning.method, equal_width = num.bin, ## equal_frequency = c(-1, quantile(x = feature.mean[feature.mean &gt; ## 0], probs = seq.int(from = 0, to = 1, length.out = num.bin))), ## stop(\"Unknown binning method: \", binning.method)) ## data.x.bin &lt;- cut(x = feature.mean, breaks = data.x.breaks) ## names(x = data.x.bin) &lt;- names(x = feature.mean) ## mean.y &lt;- tapply(X = feature.dispersion, INDEX = data.x.bin, ## FUN = mean) ## sd.y &lt;- tapply(X = feature.dispersion, INDEX = data.x.bin, ## FUN = sd) ## feature.dispersion.scaled &lt;- (feature.dispersion - mean.y[as.numeric(x = data.x.bin)])/sd.y[as.numeric(x = data.x.bin)] ## names(x = feature.dispersion.scaled) &lt;- names(x = feature.mean) ## hvf.info &lt;- data.frame(feature.mean, feature.dispersion, ## feature.dispersion.scaled) ## rownames(x = hvf.info) &lt;- rownames(x = object) ## colnames(x = hvf.info) &lt;- paste0(\"mvp.\", c(\"mean\", \"dispersion\", ## \"dispersion.scaled\")) ## } ## return(hvf.info) ## } ## &lt;bytecode: 0x0000000023f13fd0&gt; ## &lt;environment: namespace:Seurat&gt; å¿½ç•¥è¿™äº›æŠ€æœ¯ç»†èŠ‚ï¼Œè¿›è¡Œç‰¹å¾é€‰æ‹©ï¼› pbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(pbmc), 10) # plot variable features with and without labels plot1 &lt;- VariableFeaturePlot(pbmc) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot1 + plot2 2.4 Scaling the data è¿™æ­¥çš„ç›®çš„æ˜¯ä¸ºäº†åç»­çš„PCAï¼š Next, we apply a linear transformation (â€˜scalingâ€™) that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData function: + Shifts the expression of each gene, so that the mean expression across cells is 0 + Scales the expression of each gene, so that the variance across cells is 1 + This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate + The results of this are stored in pbmc[[â€œRNAâ€]]@scale.data å›å½’æ‰percent.mtå¯¹äºPCAçš„å½±å“ã€‚è¿™æ­¥æ˜¯ä¸€æ­¥é™é€Ÿæ­¥éª¤ï¼› all.genes &lt;- rownames(pbmc) pbmc &lt;- ScaleData(pbmc, features = all.genes,vars.to.regress = \"percent.mt\") æœ‰ä¸€ä¸ªé—®é¢˜åé¢çš„markeråŸºå› ä¸€å®šæ˜¯HVGå—ï¼Ÿ 2.5 çº¿æ€§é™ç»´(PCA) Next we perform PCA on the scaled data. By default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to choose a different subset. pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc)) # Examine and visualize PCA results a few different ways print(pbmc[[\"pca\"]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL ## Negative: MALAT1, LTB, IL32, IL7R, CD2 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 ## Negative: NKG7, PRF1, CST7, GZMA, GZMB ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPA1 ## Negative: PPBP, PF4, SDPR, SPARC, GNG11 ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1 ## Negative: VIM, IL7R, S100A6, S100A8, IL32 ## PC_ 5 ## Positive: GZMB, FGFBP2, S100A8, NKG7, GNLY ## Negative: LTB, IL7R, CKB, MS4A7, RP11-290F20.3 VizDimLoadings(pbmc, dims = 1:2, reduction = \"pca\") DimPlot(pbmc, reduction = \"pca\") In particular DimHeatmap allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. Setting cells to a number plots the â€˜extremeâ€™ cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, we find this to be a valuable tool for exploring correlated feature sets. ### Plot an equal number of genes with both + and - scores. mypal &lt;- rev(colorRampPalette(RColorBrewer::brewer.pal(11,\"RdBu\"))(256)) DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE,fast = F)+scale_fill_gradientn(colors = mypal) DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE) 2.6 Determine the â€˜dimensionalityâ€™ of the dataset To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a â€˜metafeatureâ€™ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many componenets should we choose to include? 10? 20? 100? ä¸¤ç§ç»Ÿè®¡æ–¹æ³•ï¼ŒJackStrawå’ŒElbowPlotï¼Œå‰è€…æ¯”è¾ƒè€—æ—¶ï¼Œä¸å†å±•ç¤ºäº†ï¼Œç”¨åè€… ElbowPlot(pbmc) ä½œè€…ç»™å‡ºäº†æ›´è¿›ä¸€æ­¥çš„è§£é‡Š Identifying the true dimensionality of a dataset â€“ can be challenging/uncertain for the user. We therefore suggest these three approaches to consider. The first is more supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example. The second implements a statistical test based on a random null model, but is time-consuming for large datasets, and may not return a clear PC cutoff. The third is a heuristic that is commonly used, and can be calculated instantly. In this example, all three approaches yielded similar results, but we might have been justified in choosing anything between PC 7-12 as a cutoff. We chose 10 here, but encourage users to consider the following: Dendritic cell and NK aficionados may recognize that genes strongly associated with PCs 12 and 13 define rare immune subsets (i.e. MZB1 is a marker for plasmacytoid DCs). However, these groups are so rare, they are difficult to distinguish from background noise for a dataset of this size without prior knowledge. We encourage users to repeat downstream analyses with a different number of PCs (10, 15, or even 50!). As you will observe, the results often do not differ dramatically. We advise users to err on the higher side when choosing this parameter. For example, performing downstream analyses with only 5 PCs does signifcanltly and adversely affect results. 3. åç»­åˆ†æ 3.1 èšç±» FindNeighborsæ„å»ºæ„å»ºSNN-graph, è€ŒFindClustersç”¨æ¥å®ç°Louvain algorithmï¼Œè¿›è¡Œå›¾èšç±»ï¼› methods(FindNeighbors) ## [1] FindNeighbors.Assay* FindNeighbors.default* FindNeighbors.dist* ## [4] FindNeighbors.Seurat* ## see '?methods' for accessing help and source code getAnywhere(FindNeighbors.Seurat) ## A single object matching 'FindNeighbors.Seurat' was found ## It was found in the following places ## registered S3 method for FindNeighbors from namespace Seurat ## namespace:Seurat ## with value ## ## function (object, reduction = \"pca\", dims = 1:10, assay = NULL, ## features = NULL, k.param = 20, compute.SNN = TRUE, prune.SNN = 1/15, ## nn.method = \"rann\", annoy.metric = \"euclidean\", nn.eps = 0, ## verbose = TRUE, force.recalc = FALSE, do.plot = FALSE, graph.name = NULL, ## ...) ## { ## CheckDots(...) ## if (!is.null(x = dims)) { ## assay &lt;- DefaultAssay(object = object[[reduction]]) ## data.use &lt;- Embeddings(object = object[[reduction]]) ## if (max(dims) &gt; ncol(x = data.use)) { ## stop(\"More dimensions specified in dims than have been computed\") ## } ## data.use &lt;- data.use[, dims] ## neighbor.graphs &lt;- FindNeighbors(object = data.use, k.param = k.param, ## compute.SNN = compute.SNN, prune.SNN = prune.SNN, ## nn.method = nn.method, annoy.metric = annoy.metric, ## nn.eps = nn.eps, verbose = verbose, force.recalc = force.recalc, ## ...) ## } ## else { ## assay &lt;- assay %||% DefaultAssay(object = object) ## data.use &lt;- GetAssay(object = object, assay = assay) ## neighbor.graphs &lt;- FindNeighbors(object = data.use, features = features, ## k.param = k.param, compute.SNN = compute.SNN, prune.SNN = prune.SNN, ## nn.method = nn.method, annoy.metric = annoy.metric, ## nn.eps = nn.eps, verbose = verbose, force.recalc = force.recalc, ## ...) ## } ## graph.name &lt;- graph.name %||% paste0(assay, \"_\", names(x = neighbor.graphs)) ## for (ii in 1:length(x = graph.name)) { ## DefaultAssay(object = neighbor.graphs[[ii]]) &lt;- assay ## object[[graph.name[[ii]]]] &lt;- neighbor.graphs[[ii]] ## } ## if (do.plot) { ## if (!\"tsne\" %in% names(x = object@reductions)) { ## warning(\"Please compute a tSNE for SNN visualization. See RunTSNE().\") ## } ## else { ## if (nrow(x = Embeddings(object = object[[\"tsne\"]])) != ## ncol(x = object)) { ## warning(\"Please compute a tSNE for SNN visualization. See RunTSNE().\") ## } ## else { ## net &lt;- graph.adjacency(adjmatrix = as.matrix(x = neighbor.graphs[[2]]), ## mode = \"undirected\", weighted = TRUE, diag = FALSE) ## plot.igraph(x = net, layout = as.matrix(x = Embeddings(object = object[[\"tsne\"]])), ## edge.width = E(graph = net)$weight, vertex.label = NA, ## vertex.size = 0) ## } ## } ## } ## object &lt;- LogSeuratCommand(object = object) ## return(object) ## } ## &lt;bytecode: 0x000000001e49f8e0&gt; ## &lt;environment: namespace:Seurat&gt; pbmc &lt;- FindNeighbors(pbmc, dims = 1:10) pbmc &lt;- FindClusters(pbmc, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95930 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8737 ## Number of communities: 9 ## Elapsed time: 0 seconds 3.2 Run UMAP/tsne run tsne pbmc &lt;- RunTSNE(pbmc,dims = 1:10) DimPlot(pbmc,label = T, reduction = \"tsne\") draw snn graph on tsne-embeding test &lt;- pbmc[[\"RNA_snn\"]] net &lt;- graph.adjacency(adjmatrix = as.matrix(x = test), mode = \"undirected\", weighted = TRUE, diag = FALSE) plot.igraph(x = net, layout = as.matrix(x = Embeddings(object = pbmc[[\"tsne\"]])), edge.width = E(graph = net)$weight, vertex.label = NA, vertex.size = 0) run umap # If you haven't installed UMAP, you can do so via reticulate::py_install(packages = # 'umap-learn') pbmc &lt;- RunUMAP(pbmc,umap.method = \"umap-learn\", dims = 1:10) # note that you can set `label = TRUE` or use the LabelClusters function to help label # individual clusters DimPlot(pbmc,label = T, reduction = \"umap\") test &lt;- pbmc[[\"RNA_snn\"]] net &lt;- graph.adjacency(adjmatrix = as.matrix(x = test), mode = \"undirected\", weighted = TRUE, diag = FALSE) plot.igraph(x = net, layout = as.matrix(x = Embeddings(object = pbmc[[\"umap\"]])), edge.width = E(graph = net)$weight, vertex.label = NA, vertex.size = 0) 3.3 Finding differentially expressed features (cluster biomarkers) ä¹‹å‰åˆ†ç¾¤ç»“æœåšå·®å¼‚è¡¨è¾¾ï¼› Seurat can help you find markers that define clusters via differential expression. By default, it identifes positive and negative markers of a single cluster (specified in ident.1), compared to all other cells. FindAllMarkers automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells. The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the thresh.test argument requires a feature to be differentially expressed (on average) by some amount between the two groups. You can set both of these to 0, but with a dramatic increase in time - since this will test a large number of features that are unlikely to be highly discriminatory. As another option to speed up these computations, max.cells.per.ident can be set. This will downsample each identity class to have no more cells than whatever this is set to. While there is generally going to be a loss in power, the speed increases can be significiant and the most highly differentially expressed features will likely still rise to the top. # find markers for every cluster compared to all remaining cells, report only the positive ones pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 2, wt = avg_logFC) ## # A tibble: 18 x 7 ## # Groups: cluster [9] ## p_val avg_logFC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 1.88e-117 0.748 0.913 0.588 2.57e-113 0 LDHB ## 2 5.01e- 85 0.931 0.437 0.108 6.88e- 81 0 CCR7 ## 3 0. 3.86 0.996 0.215 0. 1 S100A9 ## 4 0. 3.80 0.975 0.121 0. 1 S100A8 ## 5 2.61e- 81 0.886 0.981 0.65 3.58e- 77 2 LTB ## 6 1.22e- 59 0.886 0.669 0.25 1.68e- 55 2 CD2 ## 7 0. 2.99 0.939 0.042 0. 3 CD79A ## 8 1.06e-269 2.49 0.623 0.022 1.45e-265 3 TCL1A ## 9 5.98e-221 2.23 0.987 0.226 8.20e-217 4 CCL5 ## 10 1.42e-173 2.08 0.572 0.051 1.94e-169 4 GZMK ## 11 3.51e-184 2.30 0.975 0.134 4.82e-180 5 FCGR3A ## 12 2.03e-125 2.14 1 0.315 2.78e-121 5 LST1 ## 13 3.17e-267 3.35 0.961 0.068 4.35e-263 6 GZMB ## 14 1.04e-189 3.66 0.961 0.132 1.43e-185 6 GNLY ## 15 1.48e-220 2.68 0.812 0.011 2.03e-216 7 FCER1A ## 16 1.67e- 21 1.99 1 0.513 2.28e- 17 7 HLA-DPB1 ## 17 7.73e-200 5.02 1 0.01 1.06e-195 8 PF4 ## 18 3.68e-110 5.94 1 0.024 5.05e-106 8 PPBP å¯è§†åŒ–ï¼š VlnPlot(pbmc, features = c(\"MS4A1\", \"CD79A\")) # you can plot raw counts as well VlnPlot(pbmc, features = c(\"MS4A1\", \"CD79A\"), slot = \"counts\", log = TRUE) ä½¿ç”¨FeatureScatterè·å¾—å’Œæµå¼å›¾ä¸€æ ·çš„æ•ˆæœï¼› FeatureScatter(object = pbmc, feature1 = \"MS4A1\", feature2 = \"CD79A\")+ ggtitle(label = NULL) ç”¨FeaturePlotåœ¨Embedingä¸Šå±•ç¤ºè¡¨è¾¾é‡ï¼› FeaturePlot(pbmc, features = c(\"MS4A1\", \"GNLY\", \"CD3E\", \"CD14\", \"FCER1A\", \"FCGR3A\", \"LYZ\", \"PPBP\", \"CD8A\")) æ°”æ³¡å›¾DotPlot DotPlot(object = pbmc, features = c(\"MS4A1\", \"GNLY\", \"CD3E\", \"CD14\", \"FCER1A\", \"FCGR3A\", \"LYZ\", \"PPBP\", \"CD8A\"))+ coord_flip() RidgePlot RidgePlot(object = pbmc, features = c(\"MS4A1\", \"GNLY\", \"CD3E\", \"CD14\", \"FCER1A\", \"FCGR3A\", \"LYZ\", \"PPBP\", \"CD8A\")) çƒ­å›¾DoHeatmap top10 &lt;- pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_logFC) DoHeatmap(pbmc, features = top10$gene) + scale_fill_gradientn(colors = mypal) 3.4 Assigning cell type identity to clusters new.cluster.ids &lt;- c(\"Naive CD4 T\",\"CD14+ Mono\", \"Memory CD4 T\", \"B\", \"CD8 T\", \"FCGR3A+ Mono\", \"NK\", \"DC\", \"Platelet\") names(new.cluster.ids) &lt;- levels(pbmc) pbmc &lt;- RenameIdents(pbmc, new.cluster.ids) DimPlot(pbmc, reduction = \"umap\", label = TRUE, pt.size = 0.5) + NoLegend() 4. Seurat object è¯¦è§£ è¿™ä¸€éƒ¨åˆ†æ¥è‡ªwiki 4.1 The Seurat object ä¸€ä¸ªSeuratå¯¹è±¡æœ‰å¦‚ä¸‹çš„slots: Slot Function assays A list of assays within this object meta.data Cell-level meta data active.assay Name of active, or default, assay active.ident Identity classes for the current object graphs A list of nearest neighbor graphs reductions A list of DimReduc objects project.name User-defined project name (optional) tools Empty list. Tool developers can store any internal data from their methods here misc Empty slot. User can store additional information here version Seurat version used when creating the object è¿™ä¸ªå¯¹è±¡æŠŠå•ç»†èƒæ•°æ®çš„æ‰€æœ‰çš„åŸºæœ¬ä¿¡æ¯éƒ½åŒ…å«è¿›å»äº†ï¼Œå¯ä»¥ç”¨åŸºæœ¬çš„ä¸€äº›å‡½æ•°å»è·å–è¿™äº›ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æƒ³è¦çŸ¥é“è¿™ä¸ªæ•°æ®å¯¹åº”å¤šå°‘ç»†èƒï¼Œå¤šå°‘åŸºå› ï¼Œå¯ä»¥ç”¨dim;ncol;nrow;ç»†èƒæˆ–è€…featureçš„åå­—ï¼Œå¯ä»¥ç”¨rownames;colnames; æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡namesçŸ¥é“é‡Œé¢å­˜å‚¨çš„å¦‚åŸå§‹è¡¨è¾¾çŸ©é˜µï¼Œæˆ–è€…é™ç»´åå¯¹è±¡çš„åå­—ã€‚ names(x = pbmc) ## [1] \"RNA\" \"RNA_nn\" \"RNA_snn\" \"pca\" \"tsne\" \"umap\" rna &lt;- pbmc[['RNA']] å¯¹äºSeuratå¯¹è±¡ï¼Œæœ‰ä¸€ç³»åˆ—çš„å‡½æ•°å¯ä»¥å¯¹å…¶è¿›è¡Œæ“ä½œã€‚è¿™äº›å‡½æ•°å¯ä»¥ç§°ä¸ºå…¶æ‰€å±çš„methodsã€‚å¤šè¯´ä¸€å¥ï¼ŒSeuraté‡‡å–çš„æ˜¯S3å¯¹è±¡çš„é¢å‘å¯¹è±¡çš„æ•°æ®ç»“æ„ã€‚ å¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤è®¿é—®ä¸Seuratå¯¹è±¡ç›¸å…³çš„æ“ä½œã€‚ utils::methods(class = 'Seurat') ## [1] $ $&lt;- [ ## [4] [[ [[&lt;- AddMetaData ## [7] as.CellDataSet as.loom as.SingleCellExperiment ## [10] Command DefaultAssay DefaultAssay&lt;- ## [13] dim dimnames droplevels ## [16] Embeddings FindClusters FindMarkers ## [19] FindNeighbors FindVariableFeatures GetAssay ## [22] GetAssayData HVFInfo Idents ## [25] Idents&lt;- Key levels ## [28] levels&lt;- Loadings merge ## [31] Misc Misc&lt;- names ## [34] NormalizeData OldWhichCells Project ## [37] Project&lt;- RenameCells RenameIdents ## [40] ReorderIdent RunALRA RunCCA ## [43] RunICA RunLSI RunPCA ## [46] RunTSNE RunUMAP ScaleData ## [49] ScoreJackStraw SetAssayData SetIdent ## [52] show StashIdent Stdev ## [55] subset SubsetData Tool ## [58] Tool&lt;- VariableFeatures VariableFeatures&lt;- ## [61] WhichCells ## see '?methods' for accessing help and source code 4.2 Assay The Assay class stores single cell data. For typical scRNA-seq experiments, a Seurat object will have a single Assay (â€œRNAâ€). This assay will also store multiple â€˜transformationsâ€™ of the data, including raw counts (@counts slot), normalized data (@data slot), and scaled data for dimensional reduction (@scale.data slot). For more complex experiments, an object could contain multiple assays. These could include multi-modal data types (CITE-seq antibody-derived tags, ADTs), or imputed/batch-corrected measurements. Each of those assays has the option to store the same data transformations as well. ä¸€ä¸ªAssay æ‰€å«æœ‰çš„Slots Slot Function counts Stores unnormalized data such as raw counts or TPMs data Normalized data matrix scale.data Scaled data matrix key A character string to facilitate looking up features from a specific Assay var.features A vector of features identified as variable meta.features Feature-level meta data Assayå¯¹è±¡ä¹Ÿå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³• Summary information about Assay objects can be had quickly and easily using standard R functions. Object shape/dimensions can be found using the dim, ncol, and nrow functions; cell and feature names can be found using the colnames and rownames functions, respectively, or the dimnames function. æ›´å¤šçš„æ–¹æ³•è§ utils::methods(class = 'Assay') ## [1] [ [[ [[&lt;- ## [4] AddMetaData DefaultAssay DefaultAssay&lt;- ## [7] dim dimnames FindNeighbors ## [10] FindVariableFeatures GetAssayData HVFInfo ## [13] Key Key&lt;- merge ## [16] Misc Misc&lt;- NormalizeData ## [19] OldWhichCells RenameCells RunICA ## [22] RunLSI RunPCA ScaleData ## [25] SetAssayData show subset ## [28] SubsetData VariableFeatures VariableFeatures&lt;- ## [31] WhichCells ## see '?methods' for accessing help and source code Data Access # GetAssayData allows pulling from a specific slot rather than just data GetAssayData(object = rna, slot = 'scale.data')[1:3, 1:3] ## AAACATACAACCAC AAACATTGAGCTAC AAACATTGATCAGC ## AL627309.1 -0.06433822 -0.06968772 -0.04966479 ## AP006222.2 -0.02663018 -0.02065038 -0.04303249 ## RP11-206L10.2 -0.03015459 -0.02024084 -0.05734758 head(x = HVFInfo(object = rna,selection.method = \"vst\")) ## mean variance variance.standardized ## AL627309.1 0.003411676 0.003401325 0.9330441 ## AP006222.2 0.001137225 0.001136363 0.9924937 ## RP11-206L10.2 0.001895375 0.001892500 0.9627290 ## RP11-206L10.9 0.001137225 0.001136363 0.9924937 ## LINC00115 0.006823351 0.006779363 0.9062135 ## NOC2L 0.107278241 0.159514698 0.7849309 The key # Key both accesses and sets the key slot for an Assay object &gt; Key(object = rna) \"rna_\" &gt; Key(object = rna) &lt;- 'myRNA_' &gt; Key(object = rna) \"myRNA_\" # Pull a feature from the RNA assay on the Seurat level &gt; head(x = FetchData(object = pbmc, vars.fetch = 'rna_MS4A1')) rna_MS4A1 AAACATACAACCAC 0.000000 AAACATTGAGCTAC 2.583047 AAACATTGATCAGC 0.000000 AAACCGTGCTTCCG 0.000000 AAACCGTGTATGCG 0.000000 AAACGCACTGGTAC 0.000000 The DimReduc object represents a dimensional reduction taken upon the Seurat object. 4.3 The DimReduc object The DimReduc object represents a dimensional reduction taken upon the Seurat object. Slot Function cell.embeddings A matrix with cell embeddings feature.loadings A matrix with feature loadings feature.loadings.projected A matrix with projected feature loadings assay.used Assay used to calculate this dimensional reduction stdev Standard deviation for the dimensional reduction key A character string to facilitate looking up features from a specific DimReduc jackstraw Results from the JackStraw function misc â€¦ å’Œä¹‹å‰çš„å¾ˆç±»ä¼¼ pca &lt;- pbmc[[\"pca\"]] # The following examples use the PCA dimensional reduction from the PBMC 3k dataset &gt; pca A dimensional reduction object with key PC Number of dimensions: 20 Projected dimensional reduction calculated: FALSE Jackstraw run: FALSE # nrow and ncol provide the number of features and cells, respectively # dim provides both nrow and ncol at the same time &gt; dim(x = pca) [1] 1838 2638 # length provides the number of dimensions calculated &gt; length(x = pca) [1] 20 # In addtion to rownames and colnames, one can use dimnames # which provides a two-length list with both rownames and colnames &gt; head(x = rownames(x = rna)) [1] \"TNFRSF4\" \"CPSF3L\" \"ATAD3C\" \"C1orf86\" \"RER1\" \"TNFRSF25\" &gt; head(x = colnames(x = rna)) [1] \"AAACATACAACCAC\" \"AAACATTGAGCTAC\" \"AAACATTGATCAGC\" \"AAACCGTGCTTCCG\" [5] \"AAACCGTGTATGCG\" \"AAACGCACTGGTAC\" Access data # The key can be used to pull cell embeddings for specific dimensions from the Seurat level &gt; Key(object = pca) \"PC\" &gt; head(x = FetchData(object = pbmc, vars.fetch = 'PC1')) PC1 AAACATACAACCAC 5.569384 AAACATTGAGCTAC 7.216456 AAACATTGATCAGC 2.706629 AAACCGTGCTTCCG -10.134042 AAACCGTGTATGCG -1.099311 AAACGCACTGGTAC 1.455335 # DefaultAssay gets the name of the Assay object used to calculate the DimReduc &gt; DefaultAssay(object = pca) [1] \"RNA\" # Stdev gets the vector of standard deviations for each dimension embedded. Stdev(object = pca) [1] 5.666584 4.326466 3.952192 3.638124 2.191529 1.996551 1.877891 1.798251 [9] 1.766873 1.753684 1.731568 1.720525 1.718079 1.715879 1.707009 1.702660 [17] 1.697318 1.692549 1.686149 1.683967 åœ¨å…¶ä¸Šå¯ä»¥æ‰§è¡Œçš„methodæœ‰ utils::methods(class = \"DimReduc\") ## [1] [ [[ Cells DefaultAssay DefaultAssay&lt;- ## [6] dim dimnames Embeddings IsGlobal JS ## [11] JS&lt;- Key Key&lt;- length Loadings ## [16] Loadings&lt;- names print RenameCells RunTSNE ## [21] ScoreJackStraw show Stdev subset ## see '?methods' for accessing help and source code 4.4 Ré¢å‘å¯¹è±¡ç¼–ç¨‹çš„æ›´å¤šç»†èŠ‚ï¼› å…³äºé¢å‘å¯¹è±¡ï¼Œä»¥åŠS3å¯¹è±¡çš„æ•™ç¨‹ï¼Œæ›´å¤šå¯è§ï¼š Ræ·±å…¥|é¢å‘å¯¹è±¡â€”â€”æ³›å‹å‡½æ•° OO field guide Rè¯­è¨€é¢å‘å¯¹è±¡ç¼–ç¨‹","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"},{"name":"scRNA-seq","slug":"scRNA-seq","permalink":"https://landau1994.github.io/tags/scRNA-seq/"}]},{"title":"Dobrow-chap3","slug":"Dobrow-chap3","date":"2020-05-06T14:15:53.000Z","updated":"2025-01-11T17:16:31.803Z","comments":true,"path":"2020/05/06/Dobrow-chap3/","link":"","permalink":"https://landau1994.github.io/2020/05/06/Dobrow-chap3/","excerpt":"","text":"This is a note of the textbook Introduction to stochastic processes with R There exists everywhere a medium in things, determined by equilibrium. â€”Dmitri Mendeleev æ‰¿æ¥ä¸Šç« æœ€åçš„æ•°å€¼æ¡ˆä¾‹ï¼Œæœ¬ç« ä¸»è¦è®²è½¬ç§»æ­¥æ•°è¶‹äºæ— ç©·æ—¶é©¬å°”å¯å¤«é“¾çš„æ€§è´¨ã€‚ 3.1 Limiting Distribution 3.1.1 å®šä¹‰ ä½œè€…ç»™äº†æœ‰ä¸€ä¸ªå®šä¹‰å’Œä¸‰ä¸ªç­‰ä»·å®šä¹‰ã€‚è¿™ä¸ªå«ä¹‰æœ€æ¸…æ¥šï¼š A limiting distribution for the Markov chain is a probability distribution ğ€ with the property that, for any initial distribution : è¿™ä¸ªå®šä¹‰ä¸åŸå®šä¹‰çš„ç­‰ä»·æ€§ä¹Ÿå¾ˆå®¹æ˜“ç†è§£ï¼š è‹¥å¯¹æŸä¸€é©¬å°”å¯å¤«é“¾çš„çŠ¶æ€è½¬ç§»çŸ©é˜µæœ‰ï¼š å¹¶ä¸”è®¾åˆå§‹åˆ†å¸ƒ,çŠ¶æ€æ€»æ•°ä¸º åˆ™æœ‰ï¼š $$\\begin{aligned} _{n}^n &amp;=(_1,,_n) \\ &amp; = \\begin{pmatrix} 1{i=1}^n_i \\ 2{i=1}^n_i \\ \\ m{i=1}^n_i \\end{pmatrix} \\ &amp; = \\ &amp; = \\end{aligned} $$ Ex3.1 Two state Markov Chain è®¡ç®—æ¡ˆä¾‹ï¼› 3.1.2 Proportion of Time in Each State åˆ©ç”¨è®¡ç®—æ¡ä»¶æœŸæœ›çš„æŠ€æœ¯ï¼Œæ¥ä»çŠ¶æ€åœ¨è¿‡ç¨‹ä¸­æ‰€å çš„æ¯”ä¾‹æ¥ç†è§£Limit distribution Ex3.2 ###### Simulate discrete-time Markov chain ######################## # Simulates n steps of a Markov chain # markov(init,mat,n,states) # Generates X0, ..., Xn for a Markov chain with initiial # distribution init and transition matrix mat # Labels can be a character vector of states; default is 1, .... k markov &lt;- function(init,mat,n,labels) { if (missing(labels)) labels &lt;- 1:length(init) simlist &lt;- numeric(n+1) states &lt;- 1:length(init) simlist[1] &lt;- sample(states,1,prob=init) for (i in 2:(n+1)) { simlist[i] &lt;- sample(states,1,prob=mat[simlist[i-1],]) } labels[simlist] } #################################################### P &lt;- matrix(c(0.1,0.2,0.4,0.3,0.4,0,0.4,0.2,0.3,0.3,0,0.4,0.2,0.1,0.4,0.3), nrow=4, byrow=TRUE) lab &lt;- c(\"Aerobics\",\"Massage\",\"Weights\",\"Yoga\") rownames(P) &lt;- lab colnames(P) &lt;- lab P init &lt;- c(1/4,1/4,1/4,1/4) # initial distribution states &lt;- c(\"a\",\"m\",\"w\",\"y\") # simulate chain for 100 steps simlist &lt;- markov(init,P,100,states) simlist table(simlist)/100 steps &lt;- 1000000 simlist &lt;- markov(init,P,steps,states) table(simlist)/steps 3.2 Stationary Distribution 3.2.1 å®šä¹‰ æ³¨æ„Stationary Distributionçš„å®šä¹‰æ²¡æœ‰å‡ºç°æé™ã€‚ If the initial distributino is a stationary distribution, Then is a sequence of identically distributed random variables. But it doesn't mean that the random variables are independent. Lemma 3.1: Limiting Distributions are stationary Distribution The reverse is false, åä¾‹ï¼š ï¼Œ ä»¥åŠ 3.2.2 Regular Matrices ä¸€ä¸ªè‡ªç„¶çš„æƒ³æ³•æ˜¯é—®ï¼Œä»€ä¹ˆæ ·çš„æ¡ä»¶ä¸‹ï¼Œä¸€ä¸ªé©¬å°”å¯å¤«é“¾æœ‰æé™åˆ†å¸ƒï¼Œè€Œä¸”æé™åˆ†å¸ƒå°±æ˜¯å¹³ç¨³åˆ†å¸ƒå‘¢ã€‚ æ»¡è¶³å¦‚ä¸‹æ€§è´¨çš„é©¬å°”å¯å¤«é“¾æ˜¯ç¬¦åˆè¿™ä¸ªè¦æ±‚çš„ Regular Transition Matrix A transition matrix is said to be regular if some power of is positive. That is , for some æœ‰å®šç†ï¼š Theorem 3.2: A markov chain whose transition matrix is regular has a limiting distribution, which is teh unique, positive, stationary distribution of the chanin. Ex 3.3-3.4 å…·ä½“ç®—ä¾‹ï¼Œ 3.2.3 Finding the stationary distribution æœ¬è´¨ä¸Šè¿™æ˜¯ä¸€ä¸ªç‰¹å¾å€¼é—®é¢˜ã€‚ ### Stationary distribution of discrete-time Markov chain ### (uses eigenvectors) ### stationary &lt;- function(mat) { x = eigen(t(mat))$vectors[,1] as.double(x/sum(x)) } Ex 3.5-3.6; è®¡ç®—æŠ€å·§ï¼Œä»¤ Ex 3.7 The Ehrenfest dog-flea model Ex 3.8 Random walk on a graph; On weighted graph Stationiary Distribution for Random walk on a weighted graph Let be a weighted graph with edge weight function . For random walk on G, the stationary distribution is proportion to the sum of teh edge weights incident to each vertex. That is. where On simple graph Stationary Distribution for simple Random Walk on a graph For simple random walk on a weighted graph, set , then, ,which gives Ex 3.9-3.10 å¦‚ä½•è®¡ç®—çš„æ¡ˆä¾‹ï¼› 3.2.4 The Eigenvalue Connection è½¬ç½®ï¼Œçœ‹å‡ºä¸ç‰¹å¾å€¼çš„å…³è”ã€‚ Ex 3.10 ç†è®ºæ¡ˆä¾‹ï¼š random walk in regular graph.ã€‚ 3.3 Can you find the way to state 3.3.1 çŠ¶æ€å¯åˆ°è¾¾ä¸çŠ¶æ€äº’é€š Say that state is accessible from state i, if . That is,there is positive probability of reaching from in a finite number of steps. State and communicate if is accessible from and is accessible from eg 3.11 æœ¬ä¾‹è®²è¿°äº†ç”¨ Transition graphs å±•ç¤º Communication classes 3.3.2 ä¸å¯çº¦ Irreducibility A Markov chain is called irreducible if it has exactly one cmmunication class. That is, all states communicate with each other Ex 3.12 ä¸€ä¸ªä¸å¯çº¦é“¾çš„ä¾‹å­ï¼› 3.3.3 Recurrence and Transience Given a Markov chain , let be the first passage time to state . If , see. Let be the probability started in eventually returns to . State is said to be recurrent if the Markov chain started in eventually revists . That is State is said to be transient if there is positive probability that the Markov chain started in j never returns to . That is å¦‚ä½•æ ¹æ®çŠ¶æ€è½¬ç§»çŸ©é˜µåˆ¤å®šï¼ŒæŸä¸€ä¸ªçŠ¶æ€æ˜¯Recurrentæˆ–Transient Statesã€‚ç”¨ç¤ºæ€§å‡½æ•°ï¼Œ ç”±æ­¤å¯ä»¥æ¨å‡ºå¦å¤–ä¸€ä¸ªåˆ¤å®šæ¡ä»¶ï¼› Recurrence, Transience State is recurrent if and only if State j is transient if and only if Recuurence and Transience are Class Properties Theorem 3.3 The states of a communication class are either all recurrent or all transient. Corollary 3.4 For a finite irreducible Markov chain, all states are recuurent. Ex 3.13 æ¥ä¸‹æ¥çš„ä¾‹å­æ˜¯ç®€å•çš„ä¸€ç»´éšæœºæ¸¸èµ°ï¼›è¿™ä¸ªä¾‹å­å¯ä»¥æ¨å¹¿åˆ°é«˜ç»´ã€‚ 3.3.4 Canonical Decomposition Closed Communication Class Lemma 3.5 A communication class is closed if it consists of all recurrent states. A finite communication class is closed only if it consits of all recurrent states. åè¯æ³•å³å¯è¯å¾—ï¼›æœ€åä¾¿å¯ä»¥å¾—åˆ°ï¼Œæˆ‘ä»¬æƒ³å®šä¹‰çš„ï¼› The state space S of a finite Markov chain can be partitioned into transient and reccurent states as , where T is the set of all transient states and are closed communiction classes of recurrent states. This is called the canonical decomposition. æ³¨ï¼šç”±ç­‰ä»·ç±»çš„å®šä¹‰å¯ä»¥ä¿éšœè¿™ä¹ˆé‡æ’çŠ¶æ€è½¬ç§»çŸ©é˜µï¼Œæ˜¯ä¸åŸçŸ©é˜µç­‰ä»·çš„ã€‚ Given a canonical decomposition, the state space can be reordered so that the Markov transition matrix has the block matrix form å…¶ä¸­ Ex3.14 å…·ä½“ case; æ›´è¿›ä¸€æ­¥æœ‰ï¼š edit: 2020-05-06 3.7 Time reversibility 3.7.1 Definition The property of time reversibility can be explained intuitively as follows. If you were to take a movie of Markov chain moving forward in time and then run the movie backwards, you could not tell the difference between the two. æ¢æˆæ•°å­¦ä¸Šçš„è¯­è¨€å°±æ˜¯ï¼Œå¦‚æœå‡è®¾é©¬å°”å¯å¤«é“¾å¤„äºç¨³æ€ï¼Œè¿™æ—¶å­˜åœ¨ï¼š ç”±å…¨æ¦‚ç‡å…¬å¼å¯çŸ¥ï¼› Time Reversibility An irreducible Markov chain with transition matrix P and stationary distribution , if Ex 3.23; Ex 3.24ï¼›Simple random walk on a graph is time 3.7.2 Reversible Markov Chains and Radom walk Every reversible Markov chain can be considered as a random walk on a weighted graph Ex 3.25 ç®—ä¾‹ï¼› 3.7.3 The key benifit of reversibility Proposition 3.9 Let be the transition matrix of a Markov chain. If is a probability distribution which satisfies then is the stationary distribution, and the markov chain is reversible. Ex 3.26 Birth-and-death chain Case: random walk with a partialy relecting boundary. 3.8 Absorbing Chains 3.8.1 å®šä¹‰ Absorbing State, Absorbing Chain State is an absorbing state if . A Markov chain is called an absorbing chain if it has at leat one absorbing state. æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼Œä¸€ä¸ªå¸æ”¶çš„é©¬å°”å¯å¤«é“¾çš„canoical decompostionå¯ä»¥å†™ä¸ºï¼š Ex 3.31 3.8.2 Expected Number of Visits to Transient States Theorem 3.11 Consider an absorbing Markov chain with t transient states. Let be a matrix indexed by transient states. where is the expected number of visits to given that the chain starts in , Then, 3.8.3 Expected Time to Absorption Absorbing Markov Chains For an absorbing Markov chain with all states either transient or absorbing. Let 1. (Absorption probability) The probability that from transient state the chain is absorbed in state is 2. (Absorption time) The expected number of steps from transient state until the chain is absorbed in some absorbing state is 3.8.4 Expected Hitting Time for Irreducible chain 3.8.5 Patterns in Sequences 3.9 Regenration and strong Markov property 3.10 Proofs of limiting Theorem å‰©ä¸‹çš„éƒ½æ˜¯å¸¸è§„å†…å®¹ã€‚ä¸å†èµ˜è¿°ã€‚ æ€»çš„æ¥è¯´ï¼Œè¿™ä¸€ç« çš„ç« èŠ‚ç»„ç»‡å¾ˆæœ‰æ¡ç†ï¼Œå¯¹åˆå­¦è€…å‹å¥½ã€‚è€Œä¸”é€‰çš„ä¾‹å­å¾ˆæœ‰å¯å‘æ€§ã€‚ é¢˜å¤–è¯ï¼š æœ‰ä¸ªå€¼å¾—æ€è€ƒçš„é—®é¢˜ï¼Œè¿™ç§åå‘åº”ç”¨çš„æ•°å­¦å†…å®¹çš„æ•™æï¼Œå¦‚ä½•å¹³è¡¡è®ºè¿°çš„é€»è¾‘ï¼Œç†è®ºä»¥åŠæ€è€ƒçš„æ·±åº¦ï¼Œä»¥åŠåº”ç”¨çš„å¹¿åº¦ï¼Œä»¥åŠå¯¹äºè¯»è€…çš„å¸å¼•æ€§å’Œå®ç”¨æ€§ï¼Œéƒ½æ˜¯å¾ˆéœ€è¦åŠŸåº•çš„ã€‚ä½†æ˜¯è¿™æ–¹é¢åšçš„å¥½çš„æ•™æçœŸçš„å¤ªå°‘äº†ã€‚ ç†æƒ³çš„å¤§å­¦æ•™å¸ˆï¼Œæ˜¯å­¦æœ¯æˆå°±å’Œæ•™å­¦æˆå°±éƒ½å¾ˆå‡ºè‰²ï¼Œä½†æ˜¯è¿™æ¯•ç«Ÿæ˜¯å°‘æ•°ã€‚ æœ‰ä¸€å¯¹å„¿ç›¸äº’çŸ›ç›¾çš„å‘½é¢˜ï¼š å¤§å­¦ç”Ÿåº”è¯¥æé«˜è‡ªå­¦èƒ½åŠ›ï¼Œä¸è¦æŒ‡æœ›è€å¸ˆæ‰‹æŠŠæ‰‹çš„æ•™ï¼Ÿ å›½å®¶ç»™äº†å¤§å­¦è€å¸ˆå·¥èµ„ï¼Œå¤§å­¦ç”Ÿä¹Ÿä»˜äº†å­¦è´¹ï¼Œå¦‚æœéƒ½é è‡ªå­¦çš„è¯ï¼Œè¦å¤§å­¦å¹²ä»€ä¹ˆï¼Ÿ ä¾ç¬”è€…çœ‹æ¥ï¼Œå¤§å­¦æä¾›çš„æ˜¯ä¸€å¥—é€‚åˆå­¦ä¹ å’Œç ”ç©¶çš„ç¡¬ä»¶è®¾æ–½ï¼Œä¸€å¼ å¹³é™çš„ä¹¦æ¡Œï¼Œä¸€ç¾¤å¿—åŒé“åˆçš„è‰¯å¸ˆç›Šå‹ã€‚è¿™äº›ç¯å¢ƒå’Œäººï¼Œæ˜¯ä»»ä½•å…¶å®ƒæœºæ„æˆ–è€…ç½‘è¯¾ä»£æ›¿ä¸äº†çš„ã€‚","categories":[{"name":"math","slug":"math","permalink":"https://landau1994.github.io/categories/math/"}],"tags":[{"name":"stochastic Process","slug":"stochastic-Process","permalink":"https://landau1994.github.io/tags/stochastic-Process/"},{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"","slug":"networkdata-quickstart","date":"2020-05-04T15:33:30.000Z","updated":"2025-01-11T17:16:31.839Z","comments":true,"path":"2020/05/04/networkdata-quickstart/","link":"","permalink":"https://landau1994.github.io/2020/05/04/networkdata-quickstart/","excerpt":"","text":"æ‰€é€‰ä¾‹å­å‡ºè‡ªModern Statistics for Modern Biology(Susan Holmes, Wolfgang Huber) æ— å‘å›¾çš„é‚»æ¥çŸ©é˜µæ˜¯ä¸€ä¸ª0-1çŸ©é˜µï¼š library(igraph) library(ggplot2) library(ggnetwork) library(network) edges1 &lt;- matrix(c(1,3,2,3,3,4,4,5,4,6),byrow = TRUE,ncol = 2) ### generate adjacency matrix edges1 &lt;- as.data.frame(edges1) mat &lt;- matrix(data = 0,nrow = 6,ncol = 6) for(ii in 1:6){ mat[edges1[ii,1],edges1[ii,2]] &lt;- 1 mat[edges1[ii,2],edges1[ii,1]] &lt;- 1 } ### Prepare data to plot dat_long &lt;- reshape2::melt(mat) dat_long$value &lt;- as.factor(dat_long$value) colnames(dat_long) &lt;- c(\"V1\",\"V2\",\"value\") ### plot gg &lt;- ggplot(dat_long)+ geom_tile(aes(V1,V2,fill=value), color=\"#7f7f7f\")+ scale_fill_manual(values=c(\"white\", \"black\"))+ coord_equal()+ labs(x=NULL, y=NULL)+ scale_x_continuous(breaks = 1:6)+ scale_y_reverse(breaks=1:6)+ theme_bw()+ theme(panel.grid=element_blank())+ theme(panel.border=element_blank()) gg ä»é‚»æ¥çŸ©é˜µå¾—åˆ°Graph: g1 &lt;- graph_from_adjacency_matrix(mat,mode = \"undirected\") plot(g1,vertex.size=25,edge.width=5,vertex.color=\"coral\") ç»™å®šedgelistï¼Œå¾—åˆ°Graph edges1 &lt;- matrix(c(1,3,2,3,3,4,4,5,4,6),byrow = TRUE,ncol = 2) g1 &lt;- graph_from_edgelist(edges1,directed = F) plot(g1,vertex.size=25,edge.width=5,vertex.color=\"coral\") æ›´ä¸ºé«˜çº§çš„æ˜¯ï¼Œä»æ•°æ®ä¸­è®¡ç®—å‡ºé‚»æ¥çŸ©é˜µï¼Œå¹¶ä¸”è‡ªå®šä¹‰å¯è§†åŒ–çš„layoutã€‚ library(rworldmap) ### obtain data; get the binary matrix load(\"D:/tmp/Moderstatdata/data/dist2009c.RData\") country09 = attr(dist2009c, \"Label\") mstree2009 = ape::mst(dist2009c) ### calculate layout from world map mat = match(country09, countriesLow$NAME) coords2009 = data.frame( lat = countriesLow$LAT[mat], lon = countriesLow$LON[mat], country = country09) layoutCoordinates = cbind( x = jitter(coords2009$lon, amount = 15), y = jitter(coords2009$lat, amount = 8)) labc = names(table(country09)[which(table(country09) &gt; 1)]) matc = match(labc, countriesLow$NAME) dfc = data.frame( latc = countriesLow$LAT[matc], lonc = countriesLow$LON[matc], labc) dfctrans = dfc dfctrans[, 1] = (dfc[,1] + 31) / 93 dfctrans[, 2] = (dfc[,2] + 105) / 238 ggeo09 = ggnetwork(mstree2009, arrow.gap = 0, layout = layoutCoordinates) ###plot ggplot(ggeo09, aes(x = x, y = y, xend = xend, yend = yend)) + geom_edges(color = \"black\", alpha = 0.5, curvature = 0.1) + geom_nodes(aes(color = vertex.names), size = 2) + theme_blank() + geom_label(data = dfctrans, aes(x = lonc, xend = lonc, y = latc, yend = latc, label = labc, fill = labc), colour = \"white\", alpha = 0.5, size = 3) + theme(legend.position = \"none\")","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"},{"name":"Graph","slug":"Graph","permalink":"https://landau1994.github.io/tags/Graph/"},{"name":"Network","slug":"Network","permalink":"https://landau1994.github.io/tags/Network/"}]},{"title":"Calculate pi in R quikstart","slug":"Calculate-pi-in-R-quikstart","date":"2020-04-24T14:25:00.000Z","updated":"2025-01-11T17:16:31.798Z","comments":true,"path":"2020/04/24/Calculate-pi-in-R-quikstart/","link":"","permalink":"https://landau1994.github.io/2020/04/24/Calculate-pi-in-R-quikstart/","excerpt":"","text":"Rä¸­ä¹Ÿå¯ä»¥ç”¨RmpfråŒ…å®ç°å¤šç²¾åº¦çš„è®¡ç®—ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å¦‚ä¸‹ä»£ç å®ç°AGMç®—æ³•è®¡ç®—Piåˆ°å°æ•°ç‚¹å256ä½ã€‚ library(Rmpfr) piMpfr &lt;- function(prec=256, itermax = 100, verbose=TRUE) { m2 &lt;- mpfr(2, prec) # '2' as mpfr number ## -&gt; all derived numbers are mpfr (with precision 'prec') p &lt;- m2 + sqrt(m2) # 2 + sqrt(2) = 3.414.. y &lt;- sqrt(sqrt(m2)) # 2^ {1/4} x &lt;- (y+1/y) / m2 it &lt;- 0L repeat { p.old &lt;- p it &lt;- it+1L p &lt;- p * (1+x) / (1+y) if(verbose) cat(sprintf(\"it=%2d, pi^ = %s, |.-.|/|.|=%e\\n\", it, formatMpfr(p, min(50, prec/log2(10))), 1-p.old/p)) if (abs(p-p.old) &lt;= m2^(-prec)) break if(it &gt; itermax) { warning(\"not converged in\", it, \"iterations\") ; break } ## else s &lt;- sqrt(x) y &lt;- (y*s + 1/s) / (1+y) x &lt;- (s+1/s)/2 } p } piMpfr(prec = 256) ## it= 1, pi^ = 3.1426067539416226007907198236183018919713562462772, |.-.|/|.|=-8.642723e-02 ## it= 2, pi^ = 3.1415926609660442304977522351203396906792842568645, |.-.|/|.|=-3.227958e-04 ## it= 3, pi^ = 3.1415926535897932386457739917571417940347896238675, |.-.|/|.|=-2.347934e-09 ## it= 4, pi^ = 3.1415926535897932384626433832795028841972241204666, |.-.|/|.|=-5.829228e-20 ## it= 5, pi^ = 3.1415926535897932384626433832795028841971693993751, |.-.|/|.|=-1.741826e-41 ## it= 6, pi^ = 3.1415926535897932384626433832795028841971693993751, |.-.|/|.|=0.000000e+00 ## 1 'mpfr' number of precision 256 bits ## [1] 3.141592653589793238462643383279502884197169399375105820974944592307816406286163","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"}]},{"title":"A Hard Rain's A-Gonna Fall","slug":"A-Hard-Rain-s-A-Gonna-Fall","date":"2020-04-20T02:31:32.000Z","updated":"2025-01-11T17:16:31.795Z","comments":true,"path":"2020/04/20/A-Hard-Rain-s-A-Gonna-Fall/","link":"","permalink":"https://landau1994.github.io/2020/04/20/A-Hard-Rain-s-A-Gonna-Fall/","excerpt":"","text":"A Hard Rain's A-Gonna Fallæ˜¯ç¾å›½å›½å®çº§æ­Œæ‰‹ï¼Œè¯—äººï¼Œè¯ºè´å°”æ–‡å­¦å¥–å¾—ä¸»Bob Dylançš„åæ›²ä¹‹ä¸€ï¼Œè™½ç„¶åŸå”±è¯´ä¸ä¸Šå¤šä¹ˆå¥½å¬ï¼Œä½†æ˜¯æ­Œè¯å¾ˆæœ‰æ„å¢ƒï¼Œåˆ†äº«å¦‚ä¸‹ï¼š A Hard Rain's A-Gonna Fall Bob Dylan Oh, where have you been, my blue-eyed son? Oh, where have you been, my darling young one? I've stumbled on the side of twelve misty mountains I've walked and I've crawled on six crooked highways I've stepped in the middle of seven sad forests I've been out in front of a dozen dead oceans I've been ten thousand miles in the mouth of a graveyard And it's a hard, and it's a hard, it's a hard, and it's a hard And it's a hard rain's a-gonna fall Oh, what did you see, my blue-eyed son? Oh, what did you see, my darling young one? I saw a newborn baby with wild wolves all around it I saw a highway of diamonds with nobody on it I saw a black branch with blood that kept drippin' I saw a room full of men with their hammers a-bleedin' I saw a white ladder all covered with water I saw ten thousand talkers whose tongues were all broken I saw guns and sharp swords in the hands of young children And it's a hard, and it's a hard, it's a hard, it's a hard And it's a hard rain's a-gonna fall And what did you hear, my blue-eyed son? And what did you hear, my darling young one? I heard the sound of a thunder, it roared out a warnin' Heard the roar of a wave that could drown the whole world Heard one person starve, I heard many people laughin' Heard the song of a poet who died in the gutter Heard the sound of a clown who cried in the alley And it's a hard, and it's a hard, it's a hard, it's a hard And it's a hard rain's a-gonna fall Oh, who did you meet, my blue-eyed son? Who did you meet, my darling young one? I met a young child beside a dead pony I met a white man who walked a black dog I met a young woman whose body was burning I met a young girl, she gave me a rainbow I met one man who was wounded in love I met another man who was wounded with hatred And it's a hard, it's a hard, it's a hard, it's a hard It's a hard rain's a-gonna fall Oh, what'll you do now, my blue-eyed son? Oh, what'll you do now, my darling young one? I'm a-goin' back out 'fore the rain starts a-fallin' I'll walk to the depths of the deepest black forest Where the people are many and their hands are all empty Where the pellets of poison are flooding their waters Where the home in the valley meets the damp dirty prison Where the executioner's face is always well-hidden Where hunger is ugly, where souls are forgotten Where black is the color, where none is the number And I'll tell it and think it and speak it and breathe it And reflect it from the mountain so all souls can see it Then I'll stand on the ocean until I start sinkin' But I'll know my song well before I start singin' And it's a hard, it's a hard, it's a hard, it's a hard It's a hard rain's a-gonna fall","categories":[{"name":"others","slug":"others","permalink":"https://landau1994.github.io/categories/others/"}],"tags":[{"name":"art","slug":"art","permalink":"https://landau1994.github.io/tags/art/"}]},{"title":"pheatmap_advanced","slug":"pheatmap_advanced","date":"2020-04-19T16:00:00.000Z","updated":"2025-01-11T17:16:31.842Z","comments":true,"path":"2020/04/20/pheatmap_advanced/","link":"","permalink":"https://landau1994.github.io/2020/04/20/pheatmap_advanced/","excerpt":"","text":"Case 1 The datasets were provided by data-to-viz library(tidyverse) library(pheatmap) library(ggplot2) library(viridis) library(kableExtra) ### dataset 1 data &lt;- read.table(\"https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/13_AdjacencyDirectedWeighted.csv\", header=TRUE) # show data data %&gt;% head(3) %&gt;% select(1:3) %&gt;% kable() %&gt;% kable_styling(bootstrap_options = \"striped\", full_width = F) Africa East.Asia Europe Africa 3.142471 0.000000 2.107883 East Asia 0.000000 1.630997 0.601265 Europe 0.000000 0.000000 2.401476 ### the following function were embeded in pheatmap source code scale_rows = function(x){ m = apply(x, 1, mean, na.rm = T) s = apply(x, 1, sd, na.rm = T) return((x - m) / s) } scale_mat = function(mat, scale){ if(!(scale %in% c(\"none\", \"row\", \"column\"))){ stop(\"scale argument shoud take values: 'none', 'row' or 'column'\") } mat = switch(scale, none = mat, row = scale_rows(mat), column = t(scale_rows(t(mat)))) return(mat) } generate_breaks = function(x, n, center = F){ if(center){ m = max(abs(c(min(x, na.rm = T), max(x, na.rm = T)))) res = seq(-m, m, length.out = n + 1) } else{ res = seq(min(x, na.rm = T), max(x, na.rm = T), length.out = n + 1) } return(res) } data.plot &lt;- scale_mat(mat = data,scale = \"column\") breaks &lt;- generate_breaks(data.plot,n = 256,center = F) pheatmap::pheatmap(mat = data.plot, cluster_cols = F, cluster_rows = F, scale = \"column\",border_color = \"white\", color = viridis(n = 256, alpha = 1, begin = 0, end = 1, option = \"viridis\"), breaks = breaks) case 2 the codes were adapted from slowkow Sort dendrogram is very important set.seed(42) random_string &lt;- function(n) { substr(paste(sample(letters), collapse = \"\"), 1, n) } mat &lt;- matrix(rgamma(1000, shape = 1) * 5, ncol = 50) colnames(mat) &lt;- paste( rep(1:3, each = ncol(mat) / 3), replicate(ncol(mat), random_string(5)), sep = \"\" ) rownames(mat) &lt;- replicate(nrow(mat), random_string(3)) mat %&gt;% as.data.frame %&gt;% head(3) %&gt;% select(1:3) %&gt;% kable() %&gt;% kable_styling(bootstrap_options = \"striped\", full_width = F) 1jrqxa 1pskvw 1ojvwz abv 9.6964789 9.172811 2.827695 nft 0.9020955 15.575853 4.328376 xha 2.6721643 3.127039 1.765077 split data into 3 groups, and increase the values in group1 col_groups &lt;- substr(colnames(mat), 1, 1) mat[,col_groups == \"1\"] &lt;- mat[,col_groups == \"1\"] * 5 making the heatmap # install.packages(\"pheatmap\", \"RColorBrewer\", \"viridis\") library(pheatmap) library(RColorBrewer) library(viridis) # Data frame with column annotations. mat_col &lt;- data.frame(group = col_groups) rownames(mat_col) &lt;- colnames(mat) # List with colors for each annotation. mat_colors &lt;- list(group = brewer.pal(3, \"Set1\")) names(mat_colors$group) &lt;- unique(col_groups) pheatmap( mat = mat, color = inferno(10), border_color = NA, show_colnames = FALSE, show_rownames = FALSE, annotation_col = mat_col, annotation_colors = mat_colors, drop_levels = TRUE, fontsize = 14, main = \"Default Heatmap\" ) The default color breaks in pheatmap are uniformly distributed across the range of the data. We can see that values in group 1 are larger than values in groups 2 and 3. However, we canâ€™t distinguish different values within groups 2 and 3. ## ----uniform-color-breaks------------------------------------------------ mat_breaks &lt;- seq(min(mat), max(mat), length.out = 10) dat &lt;- data.frame(values = as.numeric(mat)) ## ----uniform-color-breaks-detail, fig.height=2, echo=FALSE--------------- dat_colors &lt;- data.frame( xmin = mat_breaks[1:(length(mat_breaks)-1)], xmax = mat_breaks[2:length(mat_breaks)], ymin = 0, ymax = max(density(mat, bw = \"SJ\")$y), fill = rev(inferno(length(mat_breaks) - 1)), stringsAsFactors = FALSE ) ggplot() + geom_rect( data = dat_colors, mapping = aes( xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill ) ) + geom_density( data = dat, mapping = aes(values), bw = \"SJ\", color = \"cyan\" ) + scale_fill_manual(values = dat_colors$fill) + cowplot::theme_cowplot()+ theme(legend.position = \"none\") + labs(title = \"Uniform breaks\") there are 6 data points greater than or equal to 100 are represented with 4 different colors. dat2 &lt;- as.data.frame(table(cut( mat, mat_breaks ))) dat2$fill &lt;- inferno(nrow(dat2)) ggplot() + geom_bar( data = dat2, mapping = aes(x = Var1, weight = Freq, fill = Var1), color = \"black\", size = 0.1 ) + coord_flip() + scale_fill_manual(values = dat2$fill) + cowplot::theme_cowplot()+ theme(legend.position = \"none\") + labs(y = \"data points\", x = \"breaks\", title = \"Number of data points per color\") If we reposition the breaks at the quantiles of the data, then each color will represent an equal proportion of the data: quantile_breaks &lt;- function(xs, n = 10) { breaks &lt;- quantile(xs, probs = seq(0, 1, length.out = n)) breaks[!duplicated(breaks)] } mat_breaks &lt;- quantile_breaks(mat, n = 11) lets see dat_colors &lt;- data.frame( xmin = mat_breaks[1:(length(mat_breaks)-1)], xmax = mat_breaks[2:length(mat_breaks)], ymin = 0, ymax = max(density(mat, bw = \"SJ\")$y), fill = rev(inferno(length(mat_breaks) - 1)), stringsAsFactors = FALSE ) ggplot() + geom_rect( data = dat_colors, mapping = aes( xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill ) ) + geom_density( data = dat, mapping = aes(values), bw = \"SJ\", color = \"cyan\" ) + scale_fill_manual(values = dat_colors$fill) + theme(legend.position = \"none\") + labs(title = \"Quantile breaks\") dat2 &lt;- as.data.frame(table(cut( mat, mat_breaks ))) dat2$fill &lt;- inferno(nrow(dat2)) ggplot() + geom_bar( data = dat2, mapping = aes(x = Var1, weight = Freq, fill = Var1), color = \"black\", size = 0.1 ) + coord_flip() + scale_fill_manual(values = dat2$fill) + theme(legend.position = \"none\") + labs(y = \"data points\", x = \"breaks\", title = \"Number of data points per color\") When we use quantile breaks in the heatmap, we can clearly see that group 1 values are much larger than values in groups 2 and 3, and we can also distinguish different values within groups 2 and 3: pheatmap( mat = mat, color = inferno(length(mat_breaks) - 1), breaks = mat_breaks, border_color = NA, show_colnames = FALSE, show_rownames = FALSE, annotation_col = mat_col, annotation_colors = mat_colors, drop_levels = TRUE, fontsize = 14, main = \"Quantile Color Scale\" ) We can also transform data pheatmap( mat = log10(mat), color = inferno(10), border_color = NA, show_colnames = FALSE, show_rownames = FALSE, annotation_col = mat_col, annotation_colors = mat_colors, drop_levels = TRUE, fontsize = 14, main = \"Log10 Transformed Values\" ) sort dendrograms library(dendsort) mat_cluster_cols &lt;- hclust(dist(t(mat))) sort_hclust &lt;- function(...) as.hclust(dendsort(as.dendrogram(...))) mat_cluster_cols &lt;- sort_hclust(mat_cluster_cols) plot(mat_cluster_cols, main = \"Sorted Dendrogram\", xlab = \"\", sub = \"\") sort Dendrogram heatmap mat_cluster_rows &lt;- sort_hclust(hclust(dist(mat))) pheatmap( mat = mat, color = inferno(length(mat_breaks) - 1), breaks = mat_breaks, border_color = NA, cluster_cols = mat_cluster_cols, cluster_rows = mat_cluster_rows, show_colnames = FALSE, show_rownames = FALSE, annotation_col = mat_col, annotation_colors = mat_colors, drop_levels = TRUE, fontsize = 14, main = \"Sorted Dendrograms\" ) change colnames angle pheatmap( mat = mat, color = inferno(length(mat_breaks) - 1), breaks = mat_breaks, border_color = NA, cluster_cols = mat_cluster_cols, cluster_rows = mat_cluster_rows, show_colnames = TRUE, show_rownames = FALSE, annotation_col = mat_col, angle_col = 90, fontsize_col = 8, annotation_colors = mat_colors, drop_levels = TRUE, fontsize = 10, main = \"Sorted Dendrograms\" )","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"}]},{"title":"Learn-igraph-Basic","slug":"Learnigraph-1-ManuNetworkDataBasic","date":"2020-04-19T16:00:00.000Z","updated":"2025-01-11T17:16:31.824Z","comments":true,"path":"2020/04/20/Learnigraph-1-ManuNetworkDataBasic/","link":"","permalink":"https://landau1994.github.io/2020/04/20/Learnigraph-1-ManuNetworkDataBasic/","excerpt":"","text":"Learn-igraphç³»åˆ—æ˜¯å¯¹Statistical Analysis of Network Data with Rä¸€ä¹¦çš„å­¦ä¹ ç¬”è®°ï¼Œä»‹ç»å¦‚ä½•ä½¿ç”¨Rè¿›è¡Œç½‘ç»œæ•°æ®åˆ†æï¼Œç½‘ç»œæ•°æ®çš„å¤„ç†ä¸»è¦æ˜¯åŸºäºigraphåŒ…ï¼Œå¯è§†åŒ–ç”¨çš„æ˜¯ggnet 0. åŸºæœ¬æ¦‚å¿µ ä¸€äº›éœ€è¦çŸ¥é“çš„åŸºæœ¬æ¦‚å¿µï¼› Network; Graph; Order of a graph; Size of a graph; directed graph; undirected graph; subgraph; 1. åˆ›å»ºigraph class 1.1 æ— å‘å›¾ igraphåŒ…å¤„ç†ç½‘ç»œå›¾çš„æ•°æ®ç»“æ„ä¸ºigraph class, æœ€åŸºç¡€çš„åˆ›å»ºæ–¹å¼å¦‚ä¸‹ï¼š library(igraph) library(ggraph) library(ggnetwork) g &lt;- graph.formula(1-2,1-3,2-3,2-4,3-5,4-5,4-6,4-7,5-6,6-7) l &lt;- layout.auto(g) plot(g, layout=l, vertex.color=\"skyblue\") è¯¥ç½‘ç»œçš„åŸºæœ¬ä¿¡æ¯å¯ä»¥é€šè¿‡å¦‚ä¸‹æ–¹å¼è·å¾—ï¼š V(g) ###+ 7/7 vertices, named, from 27d8280: ###[1] 1 2 3 4 5 6 7 E(g) ###+ 10/10 edges from 27d8280 (vertex names): ###[1] 1--2 1--3 2--3 2--4 3--5 4--5 4--6 4--7 5--6 6--7 ###str(g) get.adjedgelist(g) # $`1` # + 2/10 edges from f3f6e64 (vertex names): # [1] 1--2 1--3 # # $`2` # + 3/10 edges from f3f6e64 (vertex names): # [1] 1--2 2--3 2--4 # # $`3` # + 3/10 edges from f3f6e64 (vertex names): # [1] 1--3 2--3 3--5 # # $`4` # + 4/10 edges from f3f6e64 (vertex names): # [1] 2--4 4--5 4--6 4--7 # # $`5` # + 3/10 edges from f3f6e64 (vertex names): # [1] 3--5 4--5 5--6 # # $`6` # + 3/10 edges from f3f6e64 (vertex names): # [1] 4--6 5--6 6--7 # # $`7` # + 2/10 edges from f3f6e64 (vertex names): # [1] 4--7 6--7 get.edgelist(g) # [,1] [,2] # [1,] \"1\" \"2\" # [2,] \"1\" \"3\" # [3,] \"2\" \"3\" # [4,] \"2\" \"4\" # [5,] \"3\" \"5\" # [6,] \"4\" \"5\" # [7,] \"4\" \"6\" # [8,] \"4\" \"7\" # [9,] \"5\" \"6\" # [10,] \"6\" \"7\" print(g, e=TRUE, v=TRUE) # IGRAPH f673c51 UN-- 7 10 -- # + attr: name (v/c) # + edges from f673c51 (vertex names): # [1] 1--2 1--3 2--3 2--4 3--5 4--5 4--6 4--7 5--6 6--7 get.adjacency(g) # 7 x 7 sparse Matrix of class \"dgCMatrix\" # 1 2 3 4 5 6 7 # 1 . 1 1 . . . . # 2 1 . 1 1 . . . # 3 1 1 . . 1 . . # 4 . 1 . . 1 1 1 # 5 . . 1 1 . 1 . # 6 . . . 1 1 . 1 # 7 . . . 1 . 1 . 1.2 æœ‰å‘å›¾ åŒæ ·çš„æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥åˆ›å»ºæœ‰å‘å›¾ï¼› dg &lt;- graph.formula(1-+2,1-+3,2++3) op &lt;- par(mfrow=c(1,2)) plot(g, vertex.size=10,layout=l, vertex.color=\"skyblue\") plot(dg,vertex.size=10,vertex.color=\"skyblue\") par(op) 1.3 ä»é‚»æ¥çŸ©é˜µå¯¼å…¥å›¾ï¼› æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªç¥å¥‡çš„æ•°æ®Arecibo_message[https://en.wikipedia.org/wiki/Arecibo_message], æ¥è¯´æ˜,æœ‰æ—¶å€™,ä¿¡æ¯æ‰€å¯¹åº”çš„çŸ©é˜µï¼Œå¯èƒ½å°±æ˜¯ä¸€å¼ å›¾ç‰‡ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå›¾ã€‚ ###python command comes from ###https://codegolf.stackexchange.com/questions/182924/output-the-arecibo-message mat &lt;- reticulate::py_eval(\"''.join(bin(i)[3:]for i in b'`UP@JB`IDQKJjjd`@@@@@L@@Ah@@CP@@J`@@_@@@@@LNLLP@FPtXpu}}}|@@@@`@@`@@@A@@A~@@~@@@CCCcDA@DMCGM____@@@@HF@H@L@@PX@_`pO`A`@HA@HHF@`LLB@FHX@@s@@Xa`CC@`HD@``L@b@XAD@PDDA@PD@C@F@X@ck@A@P@BCx@DKi[@gI\\x7f\\\\NC\\\\@TGY@hOrAPXDFp@@@@@\\\\D@@zbjipAU@@B`@Gp@@\\x7fx@G@\\\\@X@LAh@lFXCLHhJHQHdPBJH@DHP@H@`@Dh@OOix')[1:]\") mat &lt;- as.integer(unlist(strsplit(mat,split = \"\"))) mat &lt;- matrix(data = mat,nrow = 23,ncol = 73) expand.matrix &lt;- function(A){ m &lt;- nrow(A) n &lt;- ncol(A) B &lt;- matrix(0,nrow = m, ncol = m) C &lt;- matrix(0,nrow = n, ncol = n) cbind(rbind(B,t(A)),rbind(A,C)) } g1 &lt;- graph_from_adjacency_matrix(expand.matrix(mat),mode = \"undirected\") plot(g1,vertex.size=10,edge.width=2,layout=layout.circle,vertex.color=\"coral\") å¦‚æœç›´æ¥å¯è§†åŒ–è¿™ä¸ªå›¾ï¼Œæˆ‘ä»¬ä»€ä¹ˆä¹Ÿçœ‹ä¸å‡ºæ¥ï¼Œç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬ç”¨å°†åŸæ•°æ®è§†ä¸ºæ …æ ¼æ•°æ®ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬èƒ½çœ‹å‡ºè¿™ä¸ªæ•°æ®çš„å†…æ¶µæ˜¯å¾ˆä¸°å¯Œçš„ dat_long &lt;- reshape2::melt(mat) dat_long$value &lt;- as.factor(dat_long$value) colnames(dat_long) &lt;- c(\"V1\",\"V2\",\"value\") ### plot gg &lt;- ggplot(dat_long)+ geom_tile(aes(V1,V2,fill=value), color=\"#7f7f7f\")+ scale_fill_manual(values=c(\"black\", \"white\"))+ coord_equal()+ labs(x=NULL, y=NULL)+ scale_x_continuous(breaks = 1:6)+ scale_y_reverse(breaks=1:6)+ theme_bw()+ theme(panel.grid=element_blank())+ theme(panel.border=element_blank(), axis.ticks=element_blank(), axis.text = element_blank(), legend.position = \"none\") gg 1.4 ä»data.frameä¸­åˆ›å»ºå›¾ éœ€è¦ä¸¤ä¸ªè¾“å…¥ï¼Œä¸€ä¸ªæ˜¯è¾¹çš„ä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯èŠ‚ç‚¹çš„ä¿¡æ¯ ## A simple example with a couple of actors ## The typical case is that these tables are read in from files.... actors &lt;- data.frame(name=c(\"Alice\", \"Bob\", \"Cecil\", \"David\", \"Esmeralda\"), age=c(48,33,45,34,21), gender=c(\"F\",\"M\",\"F\",\"M\",\"F\")) relations &lt;- data.frame(from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\", \"David\", \"Esmeralda\"), to=c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"), same.dept=c(FALSE,FALSE,TRUE,FALSE,FALSE,TRUE), friendship=c(4,5,5,2,1,1), advice=c(4,5,5,4,2,3)) g &lt;- graph_from_data_frame(relations, directed=TRUE, vertices=actors) ## The opposite operation as_data_frame(g, what=\"vertices\") ## name age gender ## Alice Alice 48 F ## Bob Bob 33 M ## Cecil Cecil 45 F ## David David 34 M ## Esmeralda Esmeralda 21 F as_data_frame(g, what=\"edges\") ## from to same.dept friendship advice ## 1 Bob Alice FALSE 4 4 ## 2 Cecil Bob FALSE 5 5 ## 3 Cecil Alice TRUE 5 5 ## 4 David Alice FALSE 2 4 ## 5 David Bob FALSE 1 2 ## 6 Esmeralda Alice TRUE 1 3 å¯è§†åŒ–ï¼Œ plot(g,vertex.size=10,vertex.color=\"skyblue\") 1.5 ç”¨é¢„å®šä¹‰çš„å‡½æ•°ç”Ÿæˆ igraphé‡Œæœ‰å¾ˆå¤šå¸¦makeçš„å‡½æ•°ï¼Œæ˜¯å¯ä»¥ç”Ÿæˆå›¾çš„ # ls.str and lsf.str return an object of class \"ls_str\", basically the character vector of matching names (functions only for lsf.str), similarly to ls, with a print() method that calls str() on each object. ###head(lsf.str(\"package:igraph\")) grep(pattern = \"^make\",x=ls(\"package:igraph\"),value = T) ## [1] \"make_\" \"make_bipartite_graph\" ## [3] \"make_chordal_ring\" \"make_clusters\" ## [5] \"make_de_bruijn_graph\" \"make_directed_graph\" ## [7] \"make_ego_graph\" \"make_empty_graph\" ## [9] \"make_full_bipartite_graph\" \"make_full_citation_graph\" ## [11] \"make_full_graph\" \"make_graph\" ## [13] \"make_kautz_graph\" \"make_lattice\" ## [15] \"make_line_graph\" \"make_ring\" ## [17] \"make_star\" \"make_tree\" ## [19] \"make_undirected_graph\" æˆ‘ä»¬å±•ç¤ºå…¶ä¸­çš„ä¸€äº›å›¾ï¼š g1 &lt;- make_tree(10, 2) g2 &lt;- make_bipartite_graph( rep(0:1,length=10), c(1:10)) g3 &lt;- make_star(10, mode = \"out\") g4 &lt;- make_star(10, mode = \"in\") op &lt;- par(mfrow=c(2,2)) plot(g1,vertex.size=20,vertex.color=\"skyblue\") plot(g2,vertex.size=20,vertex.color=\"skyblue\") plot(g3,vertex.size=20,vertex.color=\"skyblue\") plot(g4,vertex.size=20,vertex.color=\"skyblue\") par(op) 2. åŸºæœ¬æ“ä½œ è¯±å¯¼å­å›¾ g &lt;- graph.formula(1-2,1-3,2-3,2-4,3-5,4-5,4-6,4-7,5-6,6-7) h &lt;- induced.subgraph(g,1:5) print(h) ## IGRAPH d91ee38 UN-- 5 6 -- ## + attr: name (v/c) ## + edges from d91ee38 (vertex names): ## [1] 1--2 1--3 2--3 2--4 3--5 4--5 Exclusionï¼š h &lt;- g - vertices(c(6,7)) print(h) ## IGRAPH d923ec9 UN-- 5 6 -- ## + attr: name (v/c) ## + edges from d923ec9 (vertex names): ## [1] 1--2 1--3 2--3 2--4 3--5 4--5 Inclusion: h &lt;- h + vertices(c(6,7)) g &lt;- h + edges(c(4,6),c(4,7),c(5,6),c(6,7)) print(g) ## IGRAPH d928f5d UN-- 7 10 -- ## + attr: name (v/c) ## + edges from d928f5d (vertex names): ## [1] 1--2 1--3 2--3 2--4 3--5 4--5 4--6 4--7 5--6 6--7 union: h1 &lt;- h h2 &lt;- graph.formula(4-6,4-7,5-6,6-7) g &lt;- graph.union(h1,h2) print(g) ## IGRAPH d92f82f UN-- 7 10 -- ## + attr: name (v/c) ## + edges from d92f82f (vertex names): ## [1] 6--7 5--6 4--7 4--6 4--5 3--5 2--4 2--3 1--3 1--2 3. æŸ¥çœ‹/æ·»åŠ /ä¿®æ”¹ å±æ€§ é¦–å…ˆåˆ›å»ºä¸€ä¸ªç¤ºä¾‹çš„å›¾ï¼Œ ## A simple example with a couple of actors ## The typical case is that these tables are read in from files.... actors &lt;- data.frame(name=c(\"Alice\", \"Bob\", \"Cecil\", \"David\", \"Esmeralda\"), age=c(48,33,45,34,21), gender=c(\"F\",\"M\",\"F\",\"M\",\"F\")) relations &lt;- data.frame(from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\", \"David\", \"Esmeralda\"), to=c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"), same.dept=c(FALSE,FALSE,TRUE,FALSE,FALSE,TRUE), friendship=c(4,5,5,2,1,1), advice=c(4,5,5,4,2,3)) g &lt;- graph_from_data_frame(relations, directed=TRUE, vertices=actors) æˆ‘ä»¬å¯ä»¥é€šè¿‡$è¿ç®—ç¬¦æ¥æŸ¥çœ‹ï¼Œæ·»åŠ ï¼Œä¿®æ”¹å±æ€§ ###check edge attribute names(edge_attr(g)) ###[1] \"same.dept\" \"friendship\" \"advice\" ###vertext names(vertex_attr(g)) ###[1] \"name\" \"age\" \"gender\" ###Vertex # list.vertex.attributes(g) # list.edge.attributes(g) V(g)$name ###[1] \"Alice\" \"Bob\" \"Cecil\" \"David\" \"Esmeralda\" edge_attr(g)$same.dept ###[1] FALSE FALSE TRUE FALSE FALSE TRUE edge_attr(g)$friendship ###[1] 4 5 5 2 1 1 å¯è§†åŒ–å¦‚ä¸‹ï¼š ## A simple example with a couple of actors ## The typical case is that these tables are read in from files.... actors &lt;- data.frame(name=c(\"Alice\", \"Bob\", \"Cecil\", \"David\", \"Esmeralda\"), age=c(48,33,45,34,21), gender=c(\"F\",\"M\",\"F\",\"M\",\"F\")) relations &lt;- data.frame(from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\", \"David\", \"Esmeralda\"), to=c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"), same.dept=c(FALSE,FALSE,TRUE,FALSE,FALSE,TRUE), friendship=c(4,5,5,2,1,1), advice=c(4,5,5,4,2,3)) g &lt;- graph_from_data_frame(relations, directed=TRUE, vertices=actors) V(g)$gender &lt;- plyr::revalue(x=V(g)$gender, replace=c(\"F\"=\"Female\",\"M\"=\"Male\")) V(g)$gender ## [1] \"Female\" \"Male\" \"Female\" \"Male\" \"Female\" g$name &lt;- \"Toy Graph\" set.seed(42) tmp.df &lt;- layout.graphopt(g) V(g)$color &lt;- plyr::revalue(x=V(g)$gender, replace=c(\"Female\"=\"skyblue\", \"Male\"=\"coral\")) plot(g,layout=tmp.df,vertex.size=20, vertex.color=V(g)$color,main=\"Toy Graph\") legend('right',legend=unique(V(g)$gender),pch=c(19,19),col = c(\"skyblue\",\"coral\")) set.seed(42) tmp.df &lt;- layout.graphopt(g) gg.net = ggnetwork(g, arrow.gap = 0.05, layout = tmp.df) ggplot(gg.net, aes(x = x, y = y, xend = xend, yend = yend)) + geom_edges(color = \"black\", alpha = 0.5, curvature = 0, arrow = arrow(length = unit(6, \"pt\"), type = \"closed\")) + geom_nodes(aes(color = gender), size = 10) + geom_nodetext(aes(label = name))+ scale_color_manual(values = c(\"skyblue\",\"coral\"))+ ggtitle(\"Toy Graph\")+ theme_blank() 4. æ›´å¤šå…³äºå›¾çš„æ¦‚å¿µå’Œæœ¯è¯­ 4.1 æ¦‚å¿µ ä¸‹è¿°æ¦‚å¿µä¸æ¬è¿ä¹¦é‡Œçš„å®šä¹‰ï¼›å¿˜è®°å°±æŸ¥ä¹¦ã€‚åé¢çš„ç« èŠ‚ä¼šå†ç”¨åˆ°è¿™äº›æ¦‚å¿µï¼Œè¿›è¡Œå›¾çš„å¯è§†åŒ–ä¸ç»Ÿè®¡åˆ†æã€‚ multi-graph simple-graph: å¯ä»¥ç”¨is.simple()åˆ¤å®šï¼Œå¯ä»¥ç”¨simplify()å°†multi-graphè½¬æ¢ä¸ºsimple-graph. neighbors degree: The degree of a vertex v defined as the number of edges incident on v; in-degree out-degree walk trails circuit &amp; cylce; reachable graph connected component of a graph strong connected weak connected distance/geodesic distance diameter 4.2 ä¸€äº›ç‰¹æ®Šçš„å›¾ ä¸ç¬¬ä¸€èŠ‚æœ‰é‡å  complet graph clique regular graph tree forest root ancestor descendant parents, children k-star dirrected acyclic graph(DAG) bipartite graph g.bip &lt;- graph.formula(actor1:actor2:actor3, movie1:movie2, actor1:actor2 - movie1, actor2:actor3 - movie2) V(graph = g.bip)$type &lt;- grepl(pattern = \"^movie\",V(graph = g.bip)$name) V(g.bip)$category &lt;- ifelse(V(graph = g.bip)$type,\"Movie\",\"Actor\") V(g.bip)$category ## [1] \"Actor\" \"Actor\" \"Actor\" \"Movie\" \"Movie\" g &lt;- g.bip set.seed(42) ### using matrxi product to do layout rotate 3/2pi tmp.df &lt;- layout.bipartite(g) %*% matrix(data = c(0,-1,1,0),nrow = 2) gg.net = ggnetwork(g, arrow.gap = 0.05, layout = tmp.df) head(gg.net) ## x y name type category xend yend ## 1 0 0.0 actor1 FALSE Actor 0.9514929 0.2378732 ## 2 0 0.5 actor2 FALSE Actor 0.9514929 0.2621268 ## 3 0 0.5 actor2 FALSE Actor 0.9514929 0.7378732 ## 4 0 1.0 actor3 FALSE Actor 0.9514929 0.7621268 ## 5 0 0.0 actor1 FALSE Actor 0.0000000 0.0000000 ## 6 0 0.5 actor2 FALSE Actor 0.0000000 0.5000000 ggplot(gg.net, aes(x = x, y = y, xend = xend, yend = yend)) + geom_edges(color = \"black\", alpha = 0.5, curvature = 0 # ,arrow = arrow(length = unit(6, \"pt\"), # type = \"closed\") ) + geom_nodes(aes(color = category), size = 16) + geom_nodetext(aes(label = name))+ scale_color_manual(values = c(\"skyblue\",\"coral\"))+ ggtitle(\"bipartite graph example\")+ theme_blank() igraphè‡ªå¸¦çš„ä¾‹å­ï¼š # Random bipartite graph inc &lt;- matrix(sample(0:1, 50, replace = TRUE, prob=c(2,1)), 10, 5) g &lt;- graph_from_incidence_matrix(inc) plot(g, layout = layout_as_bipartite,vertex.size=20, vertex.color=c(\"skyblue\",\"coral\")[V(g)$type+1]) é™„å½•ï¼šRé…è‰² åŸºæœ¬é¢œè‰²ï¼š #### code provided by ####http://bc.bojanorama.pl/2013/04/r-color-reference-sheet/ m &lt;- matrix(1:660, 60, 11) kol &lt;- colors()[m] #op &lt;- par(mar=c(.1, .1, 2, .1)) image(1:11, 1:60, t(m), col=kol, axes=FALSE, ann=FALSE) txtcol &lt;- ifelse( apply(col2rgb(kol), 2, mean) &lt; 70, \"white\", \"black\") text( as.numeric(col(m)), as.numeric(row(m)), kol, cex=.8, col=txtcol) mtext(\"grDevices::colors\", 3, cex=2) è°ƒè‰²ç‰ˆ RColorBrewer::display.brewer.all() mtext(\"RColorBrewer\", 3, cex=2) æ¸å˜è‰² library(RColorBrewer) library(colorRamps) library(viridis) ### manu rdylbu &lt;- colorRampPalette(rev(brewer.pal(n = 11, name =\"RdYlBu\"))) rdbu &lt;- colorRampPalette(rev(brewer.pal(n = 11, name =\"RdBu\"))) navy &lt;- colorRampPalette(c(\"navy\", \"white\", \"firebrick3\")) jet.colors &lt;- colorRampPalette(c(\"#00007F\", \"blue\", \"#007FFF\", \"cyan\", \"#7FFF7F\", \"yellow\", \"#FF7F00\", \"red\", \"#7F0000\")) cold &lt;- colorRampPalette(c('#f7fcf0','#41b6c4','#253494','#081d58','#081d58')) warm &lt;- colorRampPalette(c('#ffffb2','#fecc5c','#e31a1c','#800026','#800026')) warmcold &lt;- colorRampPalette(c(rev(cold(21)), warm(20))) ### add manu with package function N &lt;- 100 # ramp length funnames &lt;- rev(c(\"manu::rdylbu\",\"manu::rdbu\",\"manu::navy\",\"manu::jet.colors\",\"manu::warmcold\", \"viridis::viridis\", \"grDevices::rainbow\", \"grDevices::heat.colors\", \"grDevices::terrain.colors\", \"grDevices::topo.colors\", \"grDevices::cm.colors\", \"colorRamps::blue2red\", \"colorRamps::blue2green\", \"colorRamps::green2red\", \"colorRamps::blue2yellow\", \"colorRamps::cyan2yellow\", \"colorRamps::magenta2green\", \"colorRamps::matlab.like\", \"colorRamps::matlab.like2\", \"colorRamps::primary.colors\", \"colorRamps::ygobb\")) spl &lt;- strsplit(funnames, \"::\") pkgs &lt;- sapply(spl, \"[\", 1) funs &lt;- sapply(spl, \"[\", 2) kolmat &lt;- sapply(funs, do.call, list(N)) mat &lt;- matrix( seq(1, length(kolmat)), nrow(kolmat), ncol(kolmat)) image(seq(1, nrow(mat)), seq(1, ncol(mat)), mat, col=kolmat, axes=FALSE, ann=FALSE) text( nrow(mat)/2, seq(1, ncol(mat)), funnames) mtext(\"Color Ramps function\", 3, cex=2)","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"Graph","slug":"Graph","permalink":"https://landau1994.github.io/tags/Graph/"},{"name":"Network","slug":"Network","permalink":"https://landau1994.github.io/tags/Network/"}]},{"title":"LearnSeurat_CITE_seq","slug":"LearnSeurat_CITEseq","date":"2020-04-19T16:00:00.000Z","updated":"2025-01-11T17:16:31.823Z","comments":true,"path":"2020/04/20/LearnSeurat_CITEseq/","link":"","permalink":"https://landau1994.github.io/2020/04/20/LearnSeurat_CITEseq/","excerpt":"","text":"å‰è¨€ CITE-seqæ˜¯Rahul Satijaå’ŒPeter Smibertä¸¤ä¸ªç»„åˆä½œå¼€å‘çš„åœ¨å•ç»†èƒç²¾åº¦ï¼ŒåŒæ—¶æµ‹é‡ç»†èƒè¡¨é¢è›‹ç™½è¡¨è¾¾å’Œè½¬å½•ç»„çš„æŠ€æœ¯ã€‚è¯¥æŠ€æœ¯åŸç†å¦‚ä¸‹ï¼š CITE-seqåŸç†å›¾ï¼Œç”¨æŠ—ä½“æ¥æºæ ‡ç­¾ï¼Œå®ç°ç»†èƒè¡¨é¢è›‹ç™½å®šé‡ è¯¥é¡¹æŠ€æœ¯å¯ä»¥ç”¨äºå…ç–«ç›¸å…³çš„å•ç»†èƒæµ‹åºç ”ç©¶ä¸­ã€‚ä¾‹å¦‚, æœ‰ç ”ç©¶è¡¨æ˜ç§°ï¼š ä»–ä»¬åœ¨äººå’Œå°é¼ éå°ç»†èƒè‚ºç™Œä¸­è¿›è¡Œå•ç»†èƒRNAæµ‹åºï¼Œé‰´å®šäº†ä¸€ç¾¤DCï¼Œå¹¶å°†å…¶å‘½åä¸ºâ€œå¯Œå«å…ç–«è°ƒèŠ‚åˆ†å­çš„æˆç†ŸDCâ€ï¼ˆmregDCï¼‰ï¼Œè¿™æ˜¯ç”±äºå®ƒä»¬å…±è¡¨è¾¾äº†å…ç–«è°ƒèŠ‚åŸºå› ï¼ˆCd274ï¼ŒPdcd1lg2å’ŒCd200ï¼‰å’Œæˆç†ŸåŸºå› ï¼ˆCd40ï¼ŒCcr7å’ŒIl12bï¼‰ã€‚ è¿™æ®µä¸­æ–‡æŠ¥é“æ¥è‡ªå°æŸ¯æœºå™¨äºº Rahul Satijaç»„å¼€å‘çš„è½¯ä»¶Seuratæœ‰ä¸€ä¸ªæ•™ç¨‹ï¼Œå¯ä»¥åˆ†æCITE-seqæ•°æ®ã€‚æœ¬æ–‡åŸºäºè¯¥æ•™ç¨‹å¯¹è¯¥ç±»å‹æ•°æ®çš„åˆ†æè¿›è¡Œè¯´æ˜ã€‚ æ•°æ®è½½å…¥ é¦–å…ˆæˆ‘ä»¬éœ€è¦è·å–æ•°æ®ï¼Œè¯¥æ•°æ®é›†å–æ ·ä¸º8617ä¸ªè„å¸¦è¡€å•æ ¸ç»†èƒï¼ŒåŒ…å«äº†è¡¨è¾¾è°±æ•°æ®å’Œ11ä¸ªæŠ—ä½“æ¥æºæ ‡ç­¾æ•°æ®ï¼ˆantibody-derived tags ,ADT)ã€‚ library(Seurat) library(SeuratData) library(ggplot2) library(patchwork) ### AvailableData() check avaliable data: we choose cbmc ### InstallData('cbmc') library(cbmc.SeuratData) data(\"cbmc\") ### expression matrix cbmc[[\"RNA\"]]@counts[1:10,1:10] ## 10 x 10 sparse Matrix of class \"dgCMatrix\" ## ## A1BG . . . . . . . . . . ## A1BG-AS1 . . . . . . . . . . ## A1CF . . . . . . . . . . ## A2M . . . . . . . . . . ## A2M-AS1 . . . . . . . 1 . . ## A2ML1 . . . . . . . . . . ## A4GALT . . . . . . . . . . ## A4GNT . . . . . . . . . . ## AAAS . . . . . . . . . 1 ## AACS . . . . . . . . . . ### ADT count matrix ### Actually there are just 10 surface protein cbmc[[\"ADT\"]]@counts[1:10,1:10] ## 10 x 10 sparse Matrix of class \"dgCMatrix\" ## ## CD3 60 52 89 55 63 82 53 42 103 56 ## CD4 72 49 112 66 80 78 63 59 122 70 ## CD8 76 59 61 56 94 57 61 55 64 80 ## CD45RA 575 3943 682 378 644 479 487 472 540 535 ## CD56 64 68 87 58 104 44 64 48 136 91 ## CD16 161 107 117 82 168 92 77 99 235 131 ## CD11c 77 65 65 44 92 63 70 75 106 69 ## CD14 206 129 169 136 164 122 112 111 206 204 ## CD19 70 665 79 49 81 44 60 58 61 107 ## CD34 179 79 78 83 152 103 79 86 144 193 ### show default assay DefaultAssay(cbmc) ## [1] \"RNA\" æ ¹æ®åŸºå› è¡¨è¾¾è¿›è¡Œèšç±» æ³¨æ„åœ¨é»˜è®¤å‚æ•°çš„æƒ…å†µä¸‹ï¼Œä¸‹è¿°æ“ä½œæ—¶å¯¹Default Assayè¿›è¡Œçš„ # standard log-normalization cbmc &lt;- NormalizeData(cbmc) # choose ~1k variable features cbmc &lt;- FindVariableFeatures(cbmc) # standard scaling (no regression) cbmc &lt;- ScaleData(cbmc) # Run PCA, select 13 PCs for tSNE visualization and graph-based clustering cbmc &lt;- RunPCA(cbmc, verbose = FALSE) ä¸‹é¢çš„å›¾æ˜¯æ ¹æ®æ ‡å‡†å·®æ¥é€‰æ‹©PCs ElbowPlot(cbmc, ndims = 50) èšç±»å’Œt-SNEé™ç»´ cbmc &lt;- FindNeighbors(cbmc, dims = 1:25) cbmc &lt;- FindClusters(cbmc, resolution = 0.8) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 8617 ## Number of edges: 347548 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8592 ## Number of communities: 19 ## Elapsed time: 3 seconds cbmc &lt;- RunTSNE(cbmc, dims = 1:25, method = \"FIt-SNE\") # Find the markers that define each cluster, and use these to annotate the clusters, we use # max.cells.per.ident to speed up the process cbmc.rna.markers &lt;- FindAllMarkers(cbmc, max.cells.per.ident = 100, min.diff.pct = 0.3, only.pos = TRUE) # Note, for simplicity we are merging two CD14+ Monocyte clusters (that differ in expression of # HLA-DR genes) and NK clusters (that differ in cell cycle stage) new.cluster.ids &lt;- c(\"Memory CD4 T\", \"CD14+ Mono\", \"Naive CD4 T\", \"NK\", \"CD14+ Mono\", \"Mouse\", \"B\", \"CD8 T\", \"CD16+ Mono\", \"T/Mono doublets\", \"NK\", \"CD34+\", \"Multiplets\", \"Mouse\", \"Eryth\", \"Mk\", \"Mouse\", \"DC\", \"pDCs\") names(new.cluster.ids) &lt;- levels(cbmc) cbmc &lt;- RenameIdents(cbmc, new.cluster.ids) æˆ‘ä»¬çœ‹çœ‹èšç±»ç»“æœï¼š DimPlot(cbmc, label = TRUE) + NoLegend() ## Warning: Using `as.character()` on a quosure is deprecated as of rlang 0.3.0. ## Please use `as_label()` or `as_name()` instead. ## This warning is displayed once per session. è›‹ç™½è¡¨è¾¾æ•°æ®å¤„ç† Seurat3çš„assayå®ç°å¤šä¸ªç»„å­¦æˆ–è€…æ¨¡æ€çš„æ•°æ®çš„å­˜å‚¨å’Œè·å–ã€‚ ä»£ç é‡Œçš„æ³¨é‡Šæ¥è‡ªSeuratå®˜ç½‘ã€‚ # Now we can repeat the preprocessing (normalization and scaling) steps that we typically run # with RNA, but modifying the 'assay' argument. For CITE-seq data, we do not recommend typical # LogNormalization. Instead, we use a centered log-ratio (CLR) normalization, computed # independently for each feature. This is a slightly improved procedure from the original # publication, and we will release more advanced versions of CITE-seq normalizations soon. cbmc &lt;- NormalizeData(cbmc, assay = \"ADT\", normalization.method = \"CLR\") cbmc &lt;- ScaleData(cbmc, assay = \"ADT\") åœ¨RNAè¡¨è¾¾è°±çš„é™ç»´Embeddingä¸­åŒæ—¶å±•ç¤ºå±•ç¤ºè›‹ç™½è¡¨è¾¾æ°´å¹³å’ŒåŸºå› è¡¨è¾¾æ°´å¹³ï¼š æ•£ç‚¹å›¾ï¼šæ¨ªçºµè½´ä¸ºé™ç»´çš„åæ ‡ï¼š # in this plot, protein (ADT) levels are on top, and RNA levels are on the bottom FeaturePlot(cbmc, features = c(\"adt_CD3\", \"adt_CD11c\", \"adt_CD8\", \"adt_CD16\", \"CD3E\", \"ITGAX\", \"CD8A\", \"FCGR3A\"), min.cutoff = \"q05\", max.cutoff = \"q95\", ncol = 2) Ridge Plot: RidgePlot(cbmc, features = c(\"adt_CD3\", \"adt_CD8\", \"CD3E\",\"CD8A\"),ncol = 2) æ•£ç‚¹å›¾ï¼šæ¨ªçºµè½´ä¸ºè¡¨è¾¾é‡ï¼›è¿™ä¸ªç±»ä¼¼äºFACS # Draw ADT scatter plots (like biaxial plots for FACS). Note that you can even 'gate' cells if # desired by using HoverLocator and FeatureLocator FeatureScatter(cbmc, feature1 = \"adt_CD19\", feature2 = \"adt_CD3\") æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹çœ‹è›‹ç™½è¡¨è¾¾å’ŒåŸºå› è¡¨è¾¾çš„å…³ç³»ï¼š # view relationship between protein and RNA FeatureScatter(cbmc, feature1 = \"adt_CD3\", feature2 = \"CD3E\") æˆ‘ä»¬å¯ä»¥çœ‹çœ‹Tç»†èƒï¼š # Let's plot CD4 vs CD8 levels in T cells tcells &lt;- subset(cbmc, idents = c(\"Naive CD4 T\", \"Memory CD4 T\", \"CD8 T\")) FeatureScatter(tcells, feature1 = \"adt_CD4\", feature2 = \"adt_CD8\") é€‰æ²¡æœ‰æ ‡å‡†åŒ–çš„åŸå§‹æ•°æ®æˆ‘ä»¬çœ‹çœ‹ï¼Œåæ ‡è½´çš„é—´è·å¤ªå¤§ï¼Œä¼šæœ‰misleading # # Let's look at the raw (non-normalized) ADT counts. You can see the values are quite high, # particularly in comparison to RNA values. This is due to the significantly higher protein copy # number in cells, which significantly reduces 'drop-out' in ADT data FeatureScatter(tcells, feature1 = \"adt_CD4\", feature2 = \"adt_CD8\", slot = \"counts\") è¿™é‡Œè¿˜æ˜¯å¯ä»¥è§‚å¯Ÿåˆ°dropoutsç°è±¡çš„ï¼Œæ®åŸä½œè€…è¯´ï¼š &gt; If you look a bit more closely, youâ€™ll see that our CD8 T cell cluster is enriched for CD8 T cells, but still contains many CD4+ CD8- T cells. This is because Naive CD4 and CD8 T cells are quite similar transcriptomically, and the RNA dropout levels for CD4 and CD8 are quite high. This demonstrates the challenge of defining subtle immune cell differences from scRNA-seq data alone. ç”»çƒ­å›¾ï¼ŒSeurat3 åŠ äº† downsampleçš„åŠŸèƒ½ã€‚ # Downsample the clusters to a maximum of 300 cells each (makes the heatmap easier to see for small clusters) cbmc.small &lt;- subset(cbmc, downsample = 300) # Find protein markers for all clusters, and draw a heatmap adt.markers &lt;- rownames(cbmc.small[[\"ADT\"]]@counts) æˆ‘ä»¬å¯ä»¥çœ‹çœ‹Seuratçƒ­å›¾çš„é»˜è®¤é…è‰²ï¼ˆä¸‰ä¸ªå†’å·å¯ä»¥çœ‹æ›´ä¸ºåº•å±‚çš„å‡½æ•°ï¼‰, ä¸ªäººè§‰å¾—å¹¶ä¸å¥½çœ‹ã€‚ # using code from RColorBrewer to demo the palette n = 200 par(mfrow=c(3,1)) image( 1:n, 1, as.matrix(1:n), col = Seurat:::PurpleAndYellow(k=n), xlab = \"PurpleAndYellow n\", ylab = \"\", xaxt = \"n\", yaxt = \"n\", bty = \"n\" ) image( 1:n, 1, as.matrix(1:n), col = colorRampPalette(c(\"navy\", \"white\", \"firebrick3\"))(n), xlab = \"NavyWhite3Firebrick3 n\", ylab = \"\", xaxt = \"n\", yaxt = \"n\", bty = \"n\" ) image( 1:n, 1, as.matrix(1:n), col = colorRampPalette(RColorBrewer::brewer.pal(11,\"RdBu\"))(n), xlab = \"RdBu n\", ylab = \"\", xaxt = \"n\", yaxt = \"n\", bty = \"n\" ) æŠŠé»˜è®¤é…è‰²æ¢æ‰,è§ mypal &lt;- rev(colorRampPalette(RColorBrewer::brewer.pal(11,\"RdBu\"))(256)) #mypal2 &lt;- colorRampPalette(c(\"navy\", \"white\", \"firebrick3\"))(256) DoHeatmap(cbmc.small, features = unique(adt.markers), assay = \"ADT\", angle = 90,size = 3)+ scale_fill_gradientn(colors = mypal) ## Scale for 'fill' is already present. Adding another scale for 'fill', which ## will replace the existing scale. å»é™¤ç»†èƒæ‚è´¨ï¼Œ # You can see that our unknown cells co-express both myeloid and lymphoid markers (true at the # RNA level as well). They are likely cell clumps (multiplets) that should be discarded. We'll # remove the mouse cells now as well cbmc &lt;- subset(cbmc, idents = c(\"Multiplets\", \"Mouse\"), invert = TRUE) ç›´æ¥æ ¹æ®è›‹ç™½è´¨è¡¨è¾¾æ°´å¹³è¿›è¡Œèšç±» # Because we're going to be working with the ADT data extensively, we're going to switch the # default assay to the 'CITE' assay. This will cause all functions to use ADT data by default, # rather than requiring us to specify it each time DefaultAssay(cbmc) &lt;- \"ADT\" cbmc &lt;- RunPCA(cbmc, features = rownames(cbmc), reduction.name = \"pca_adt\", reduction.key = \"pca_adt_\", verbose = FALSE) å†æ¥çœ‹PCA(å…¶å®è¿™é‡Œç®—æ˜¯degenrateåˆ°çº¿æ€§ç»„åˆäº†) DimPlot(cbmc, reduction = \"pca_adt\") # Since we only have 10 markers, instead of doing PCA, we'll just use a standard euclidean # distance matrix here. Also, this provides a good opportunity to demonstrate how to do # visualization and clustering using a custom distance matrix in Seurat adt.data &lt;- GetAssayData(cbmc, slot = \"data\") adt.dist &lt;- dist(t(adt.data)) # Before we recluster the data on ADT levels, we'll stash the RNA cluster IDs for later cbmc[[\"rnaClusterID\"]] &lt;- Idents(cbmc) # Now, we rerun tSNE using our distance matrix defined only on ADT (protein) levels. cbmc[[\"tsne_adt\"]] &lt;- RunTSNE(adt.dist, assay = \"ADT\", reduction.key = \"adtTSNE_\") cbmc[[\"adt_snn\"]] &lt;- FindNeighbors(adt.dist)$snn cbmc &lt;- FindClusters(cbmc, resolution = 0.2, graph.name = \"adt_snn\") ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 7895 ## Number of edges: 258146 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9491 ## Number of communities: 11 ## Elapsed time: 2 seconds # We can compare the RNA and protein clustering, and use this to annotate the protein clustering # (we could also of course use FindMarkers) clustering.table &lt;- table(Idents(cbmc), cbmc$rnaClusterID) clustering.table ## ## Memory CD4 T CD14+ Mono Naive CD4 T NK B CD8 T CD16+ Mono ## 0 1754 0 1217 29 0 27 0 ## 1 0 2189 0 4 0 0 30 ## 2 3 0 2 890 3 1 0 ## 3 0 4 0 2 319 0 2 ## 4 24 0 18 4 1 243 0 ## 5 1 27 4 157 2 2 10 ## 6 4 5 0 1 0 0 0 ## 7 4 59 4 0 0 0 9 ## 8 0 9 0 2 0 0 179 ## 9 0 0 1 0 0 0 0 ## 10 1 0 2 0 25 0 0 ## ## T/Mono doublets CD34+ Eryth Mk DC pDCs ## 0 5 2 4 24 1 2 ## 1 1 1 5 25 55 0 ## 2 0 1 3 7 2 1 ## 3 0 2 2 3 0 0 ## 4 0 0 1 2 0 0 ## 5 56 0 9 16 6 2 ## 6 1 113 81 16 5 0 ## 7 117 0 0 2 0 1 ## 8 0 0 0 1 0 0 ## 9 0 0 0 0 1 43 ## 10 2 0 0 0 0 0 ä¸‹é¢è¿™ä¸ªembeding è¿˜æ˜¯æ ¹æ®ADTæ¥çš„ï¼ˆä¸è¿‡åªè¦markerè¿ç»­ï¼Œåªæœ‰10ä¸ªä¹Ÿæ²¡æœ‰å…³ç³»ï¼Ÿï¼‰ new.cluster.ids &lt;- c(\"CD4 T\", \"CD14+ Mono\", \"NK\", \"B\", \"CD8 T\", \"NK\", \"CD34+\", \"T/Mono doublets\", \"CD16+ Mono\", \"pDCs\", \"B\") names(new.cluster.ids) &lt;- levels(cbmc) cbmc &lt;- RenameIdents(cbmc, new.cluster.ids) tsne_rnaClusters &lt;- DimPlot(cbmc, reduction = \"tsne_adt\", group.by = \"rnaClusterID\") + NoLegend() tsne_rnaClusters &lt;- tsne_rnaClusters + ggtitle(\"Clustering based on scRNA-seq\") + theme(plot.title = element_text(hjust = 0.5)) tsne_rnaClusters &lt;- LabelClusters(plot = tsne_rnaClusters, id = \"rnaClusterID\", size = 4) tsne_adtClusters &lt;- DimPlot(cbmc, reduction = \"tsne_adt\", pt.size = 0.5) + NoLegend() tsne_adtClusters &lt;- tsne_adtClusters + ggtitle(\"Clustering based on ADT signal\") + theme(plot.title = element_text(hjust = 0.5)) tsne_adtClusters &lt;- LabelClusters(plot = tsne_adtClusters, id = \"ident\", size = 4) # Note: for this comparison, both the RNA and protein clustering are visualized on a tSNE # generated using the ADT distance matrix. wrap_plots(list(tsne_rnaClusters, tsne_adtClusters), ncol = 2) å¯¹äºè¯¥ç»“æœï¼Œä½œè€…æ˜¯è¿™ä¹ˆè§£é‡Šçš„ï¼š The ADT-based clustering yields similar results, but with a few differences + Clustering is improved for CD4/CD8 T cell populations, based on the robust ADT data for + CD4, CD8, CD14, and CD45RA + However, some clusters for which the ADT data does not contain good distinguishing protein markers (i.e. Mk/Ery/DC) lose separation You can verify this using FindMarkers at the RNA level, as well æ›´å¤š pbmc 10kçš„ç»†èƒä¹Ÿæä¾›äº†CITE-seqçš„å¤šæ¨¡æ€æ•°æ®ï¼Œå…·ä½“ç»†èŠ‚ï¼Œè¯·çœ‹Seuratå®˜æ–¹æ•™ç¨‹ã€‚","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"},{"name":"scRNA-seq","slug":"scRNA-seq","permalink":"https://landau1994.github.io/tags/scRNA-seq/"},{"name":"sc-seq","slug":"sc-seq","permalink":"https://landau1994.github.io/tags/sc-seq/"}]},{"title":"Combine pheatmap","slug":"combine_pheatmap","date":"2020-04-19T16:00:00.000Z","updated":"2025-01-11T17:16:31.832Z","comments":true,"path":"2020/04/20/combine_pheatmap/","link":"","permalink":"https://landau1994.github.io/2020/04/20/combine_pheatmap/","excerpt":"","text":"Talk is cheap, this is code: library(grid) library(gridExtra) library(pheatmap) library(ggplot2) library(colormap) items=names(colormaps) plot_list=list() for (a in items[1:8]){ x= pheatmap(volcano, cluster_rows = F, cluster_cols = F, main = a, height = 3, width = 3, border_color = NA, color = colormap_pal(colormap = colormaps[[a]])(100),silent = T) plot_list[[a]] = x[[4]] ##to save each plot into a list. note the [[4]] } cowplot::plot_grid(plotlist = plot_list[1:8],ncol = 2,nrow = 4) test equation: ;","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"}]},{"title":"rmarkdown-test","slug":"rmarkdown-test","date":"2020-04-19T16:00:00.000Z","updated":"2025-01-11T17:16:31.862Z","comments":true,"path":"2020/04/20/rmarkdown-test/","link":"","permalink":"https://landau1994.github.io/2020/04/20/rmarkdown-test/","excerpt":"","text":"This post test blogdown, reference this repo This post generate by blogdown::new_post(title = â€œRmarkdown_testâ€,ext=â€œ.Rmdâ€) R Markdown This is an R Markdown document. Please note this page was not rendered using the rmarkdown package or Pandoc. The R Markdown document is compiled to Markdown through knitr, and the Markdown document is rendered to HTML through Hexoâ€™s Markdown renderer. You can embed an R code chunk like this: summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 fit &lt;- lm(dist ~ speed, data = cars) fit ## ## Call: ## lm(formula = dist ~ speed, data = cars) ## ## Coefficients: ## (Intercept) speed ## -17.579 3.932 Including Plots You can also embed R plots: par(mar = c(0, 1, 0, 1)) pie( c(280, 60, 20), c('Sky', 'Sunny side of pyramid', 'Shady side of pyramid'), col = c('#0292D8', '#F7EA39', '#C4B632'), init.angle = -50, border = NA )","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"R","slug":"R","permalink":"https://landau1994.github.io/tags/R/"}]},{"title":"é˜¿é‡Œæ•°å­¦ç«èµ›é¢„èµ›2020å¹´çš„ä¸€é“æ¦‚ç‡é¢˜å­¦ä¹ ","slug":"é˜¿é‡Œæ•°å­¦ç«èµ›é¢„èµ›2020å¹´çš„ä¸€é“æ¦‚ç‡é¢˜å­¦ä¹ ","date":"2020-04-18T07:41:15.000Z","updated":"2025-01-11T17:16:31.883Z","comments":true,"path":"2020/04/18/é˜¿é‡Œæ•°å­¦ç«èµ›é¢„èµ›2020å¹´çš„ä¸€é“æ¦‚ç‡é¢˜å­¦ä¹ /","link":"","permalink":"https://landau1994.github.io/2020/04/18/%E9%98%BF%E9%87%8C%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B%E9%A2%84%E8%B5%9B2020%E5%B9%B4%E7%9A%84%E4%B8%80%E9%81%93%E6%A6%82%E7%8E%87%E9%A2%98%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"é˜¿é‡Œå·´å·´å…¨çƒæ•°å­¦ç«èµ›æ˜¯é˜¿é‡ŒåŠçš„ä¸€é¡¹æ•°å­¦ç«èµ›ã€‚å‡ºé¢˜èŒƒå›´å’Œå¾€å±Šé¢„é€‰èµ›é¢˜ç›®å¯ä»¥åœ¨å…¶å®˜ç½‘ä¸‹æŸ¥çœ‹ ã€‚ 2020å¹´çš„é¢„é€‰èµ›ï¼Œæœ‰é“é¢˜ç›®æ˜¯è¿™æ ·çš„ï¼š è€ƒè™‘ä¸€ä¸ªç”±ä»å·¦é“å³çš„nä¸ªå°æ–¹æ ¼ç»„æˆçš„çš„åŒºåŸŸï¼Œä»å·¦åˆ°å³ä¾æ¬¡åœ¨æ¯ä¸ªå°æ–¹æ ¼ç§ä¸€æ£µæ ‘ï¼Œä¸€å…±ç§æ£µã€‚æ ‘çš„ç§ç±»åªæœ‰ä¸¤ç§ï¼šèƒ¡æ¨å’Œæ¨Ÿå­æ¾ã€‚å‡è®¾åœ¨ç¬¬ä¸€ä¸ªå°æ–¹æ ¼ç§æ¤çš„æ•°æ˜¯èƒ¡æ¨çš„æ¦‚ç‡æ˜¯rã€‚åç»­çš„ç§æ ‘çš„è§„åˆ™ä¸ºï¼šå¦‚æœå‰ä¸€ä¸ªå°æ–¹æ ¼ç§çš„æ˜¯èƒ¡æ¨ï¼Œåˆ™æœ¬æ ¼ç§èƒ¡æ¨çš„æ¦‚ç‡ä¸º;å¦‚æœå‰ä¸€ä¸ªå°æ–¹æ ¼ç§çš„æ˜¯æ¨Ÿå­æ¾ï¼Œåˆ™æœ¬æ ¼ç§æ¨Ÿå­æ¾çš„æ¦‚ç‡ä¸º å‡è®¾ã€‚æ˜¯å¦å­˜åœ¨ä½¿å¾—,åœ¨ç¬¬ä¸ªå°æ–¹æ ¼ç§æ¤çš„æ ‘æ˜¯èƒ¡æ¨çš„æ¦‚ç‡éƒ½ç­‰äºä¸€ä¸ªè·Ÿæ— å…³çš„å¸¸æ•°ï¼Ÿå¦‚æœå­˜åœ¨ï¼Œè¯·ç»™å‡ºï¼Œæ»¡è¶³çš„å…³ç³»ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œè¯·è¯´æ˜ç†ç”±ã€‚ å‡è®¾ã€‚å‡è®¾æˆ‘ä»¬è§‚å¯Ÿåˆ°ç¬¬2019ä¸ªå°æ–¹æ ¼é‡Œç§æ¤çš„æ ‘æ˜¯èƒ¡æ¨ï¼Œä½†æˆ‘ä»¬è§‚å¯Ÿä¸åˆ°å…¶å®ƒå°æ–¹æ ¼é‡Œç§æ¤çš„æ˜¯å“ªç§æ ‘ã€‚è¯·é—®ç¬¬ä¸€ä¸ªå°æ–¹æ ¼é‡Œç§æ¤çš„æ ‘æ˜¯èƒ¡æ¨çš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Ÿ è¿™é“é¢˜è€ƒå¯Ÿçš„å…¶å®æ˜¯é©¬å°”ç§‘å¤«é“¾ç›¸å…³çš„çŸ¥è¯†ï¼Œç¬¬ä¸€é—®æ˜¯è¯´ä»€ä¹ˆæ¡ä»¶ä¸‹ï¼Œé¢˜ç›®ç»™å®šçš„é©¬å°”å¯å¤«é“¾åœ¨ç¬¬äºŒæ­¥å°±èƒ½è¾¾åˆ°å¹³ç¨³åˆ†å¸ƒï¼›ç¬¬äºŒé—®æ˜¯ä»ç¬¬næ­¥é€†æ¨æœ€èµ·å§‹çš„æ¦‚ç‡ã€‚å½“ç„¶ï¼Œç›´æ¥çš„å·¥å…·æ˜¯æ¡ä»¶æ¦‚ç‡å’Œå…¨æ¦‚ç‡å…¬å¼ã€‚ è§£ç­”ï¼ˆæ ¹æ®å®˜æ–¹ç­”æ¡ˆï¼Œæœ‰æ”¹åŠ¨ï¼‰ï¼š é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å°†æ–‡å­—ä¿¡æ¯è½¬æ¢ä¸ºä¾¿äºå¤„ç†çš„æ•°å­¦è®°å·ï¼Œè®°â€œEâ€è¡¨ç¤ºèƒ¡æ¨ï¼Œâ€œSâ€ è¡¨ç¤ºæ¨Ÿå­æ¾ã€‚ä»¤è¡¨ç¤ºç§åœ¨ç¬¬ä¸ªæ–¹æ ¼çš„æ ‘çš„ç§ç±»(æ ¹æ®é¢˜æ„ï¼Œè¿™æ˜¯ä¸€ä¸ªéšæœºå˜é‡)ï¼Œä»¤,åˆ™ç”±é¢˜è®¾ï¼Œæœ‰ï¼š ä¸”ç”±å…¨æ¦‚ç‡å…¬å¼ ä»¤, æˆ‘ä»¬æœ‰ï¼š è‹¥æˆç«‹ï¼Œåˆ™, æ•´ç†å¯å¾— å› ä¸ºï¼Œæ‰€ä»¥å½“æ—¶ï¼Œ é¢˜ç›®ç»™çš„ä¸æ»¡è¶³(a)ä¸­çš„æ¡ä»¶ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ±‚å‡ºä¸€èˆ¬æ¡ä»¶ä¸‹çš„æƒ…å†µã€‚ ä»¤,åˆ™éœ€è¦æ±‚çš„æ¦‚ç‡æ˜¯ï¼š (a)ä¸­å·²ç»æ±‚å‡ºäº†å¾—é€’æ¨å¼, ä»¿ç…§(a)çš„æ­¥éª¤ï¼Œæˆ‘ä»¬å¯ä»¥æ±‚å‡º è§£ä¸Šè¿°é€’æ¨å¼ï¼Œå¯å¾—ï¼š ç±»ä¼¼çš„ï¼Œç”±(2)å¯å¾— æ‰€ä»¥æœ‰ï¼š å°†ç»™å…¥æ¡ä»¶å¸¦å…¥(å…¶å®ä¸ç”¨è®¡ç®—ï¼Œå› ä¸ºï¼‰ï¼Œå¯å¾—","categories":[{"name":"math","slug":"math","permalink":"https://landau1994.github.io/categories/math/"}],"tags":[{"name":"stochastic Process","slug":"stochastic-Process","permalink":"https://landau1994.github.io/tags/stochastic-Process/"},{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"Probability","slug":"Probability","permalink":"https://landau1994.github.io/tags/Probability/"}]},{"title":"æœºå™¨å­¦ä¹ åœ¨ç”Ÿç‰©å­¦æœ‰åº”ç”¨å—","slug":"æœºå™¨å­¦ä¹ åœ¨ç”Ÿç‰©å­¦æœ‰åº”ç”¨å—","date":"2020-04-15T16:00:00.000Z","updated":"2025-01-11T17:16:31.875Z","comments":true,"path":"2020/04/16/æœºå™¨å­¦ä¹ åœ¨ç”Ÿç‰©å­¦æœ‰åº”ç”¨å—/","link":"","permalink":"https://landau1994.github.io/2020/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E7%94%9F%E7%89%A9%E5%AD%A6%E6%9C%89%E5%BA%94%E7%94%A8%E5%90%97/","excerpt":"","text":"è¯´æ˜ï¼šè½¬è‡ªç«™é•¿çŸ¥ä¹å›ç­”ã€‚ å½“ç„¶æœ‰åº”ç”¨ï¼Œè€Œä¸”æ˜¯å¾ˆå¹¿æ³›çš„åº”ç”¨ï¼Œå‘¨å¿—åè€å¸ˆçš„ã€Šæœºå™¨å­¦ä¹ ã€‹ä¸­çš„ç¬¬1ç« çš„ç»ªè®ºçš„1.6èŠ‚åº”ç”¨ç°çŠ¶ä¸­è¿™æ ·å†™åˆ°ï¼š æœºå™¨å­¦ä¹ è¿˜ä¸ºè®¸å¤šäº¤å‰å­¦ç§‘æä¾›äº†é‡è¦çš„æŠ€æœ¯æ”¯æ’‘ã€‚ä¾‹å¦‚ï¼Œâ€œç”Ÿç‰©ä¿¡æ¯å­¦â€è¯•å›¾åˆ©ç”¨ä¿¡æ¯æŠ€æœ¯æ¥ç ”ç©¶ç”Ÿå‘½ç°è±¡å’Œè§„å¾‹ï¼Œè€ŒåŸºå› ç»„è®¡åˆ’çš„å®æ–½å’ŒåŸºå› è¯ç‰©çš„ç¾å¥½å‰æ™¯è®©äººä»¬ä¸ºä¹‹å¿ƒæ½®æ¾æ¹ƒã€‚ç”Ÿç‰©ä¿¡æ¯å­¦ç ”ç©¶æ¶‰åŠä»â€œç”Ÿå‘½ç°è±¡â€åˆ°â€œè§„å¾‹å‘ç°â€çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œå…¶é—´å¿…ç„¶åŒ…æ‹¬æ•°æ®è·å–ã€æ•°æ®ç®¡ç†ã€æ•°æ®åˆ†æã€ä»¿çœŸå®éªŒç­‰ç¯èŠ‚ï¼Œè€Œâ€œæ•°æ®åˆ†æâ€æ°æ˜¯æœºå™¨å­¦ä¹ æŠ€æœ¯çš„èˆå°ï¼Œå„ç§æœºå™¨å­¦ä¹ æŠ€æœ¯å·²ç»åœ¨è¿™ä¸ªèˆå°ä¸Šå¤§æ”¾å¼‚å½©ã€‚ åœ¨æœ¬å›ç­”ä¸­ï¼Œæˆ‘ä»¬å°†ç»“åˆå…·ä½“çš„æ¡ˆä¾‹ï¼Œåˆ†ä¸‰éƒ¨åˆ†è®ºè¿°æœºå™¨å­¦ä¹ ï¼ˆåŒ…å«æ·±åº¦å­¦ä¹ ï¼‰åœ¨ç”Ÿç‰©ç ”ç©¶çš„åº”ç”¨ã€‚ç¬¬ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å…ˆå¯¹æœºå™¨å­¦ä¹ åœ¨ç”Ÿå‘½ç§‘å­¦é¢†åŸŸçš„ç ”ç©¶åšä¸€ä¸ªå…¨æ™¯çš„ä»‹ç»ã€‚ç¬¬äºŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬å†ç»“åˆå…·ä½“æ¡ˆä¾‹å¦‚ä½•åº”ç”¨æœºå™¨å­¦ä¹ æ¨åŠ¨ç›¸å…³ç”Ÿç‰©ç ”ç©¶ï¼Œä»¥åŠç›¸å…³ç”Ÿç‰©ç ”ç©¶ä¸­å‡ºç°çš„é—®é¢˜å¦‚ä½•å‚¬ç”Ÿæ–°çš„æœºå™¨å­¦ä¹ ç®—æ³•ã€‚ç¬¬ä¸‰éƒ¨åˆ†æˆ‘ä»¬å°†è¿›è¡Œå›é¡¾å’Œåæ€ï¼Œæ¢è®¨æœªæ¥çš„æœºå™¨å­¦ä¹ å°†å¦‚ä½•æ›´å¥½çš„æ¨åŠ¨ç”Ÿç‰©ç ”ç©¶ã€‚ åœ¨æ­£å¼è®¨è®ºä¹‹å‰ï¼Œæˆ‘ä»¬å€Ÿç”¨å‘¨å¿—åè€å¸ˆçš„ã€Šæœºå™¨å­¦ä¹ ã€‹ä¸€ä¹¦æ¥å¯¹æœºå™¨å­¦ä¹ ä¸‹ä¸€ä¸ªæè¿°æ€§çš„å®šä¹‰ï¼š æœºå™¨å­¦ä¹ æ­£æ˜¯è¿™æ ·ä¸€é—¨å­¦ç§‘ï¼Œå®ƒè‡´åŠ›äºç ”ç©¶å¦‚ä½•é€šè¿‡è®¡ç®—çš„æ‰‹æ®µï¼Œåˆ©ç”¨ç» éªŒæ¥ç«å–„ç³»ç»Ÿè‡ªèº«çš„æ€§èƒ½åœ¨è®¡ç®—æœºç³»ç»Ÿä¸­ï¼Œ\"ç»éªŒ\"é€šå¸¸ä»¥\"æ•°æ®\"å½¢å¼å­˜ åœ¨ï¼Œå› æ­¤æœºå™¨å­¦ä¹ æ‰€ç ”ç©¶çš„ä¸»è¦å†…å®¹ï¼Œæ˜¯å…³äºåœ¨è®¡ç®—æœºä¸Šä»æ•°æ®ä¸­äº§ç”Ÿ\"æ¨¡ å‹\" (model) çš„ç®—æ³•ï¼Œå³\"å­¦ä¹ ç®—æ³•\" (learning algorithm). æœ‰äº†å­¦ä¹ ç®—æ³•ï¼Œæˆ‘ä»¬æŠŠç»éªŒæ•°æ®æä¾›ç»™å®ƒï¼Œå®ƒå°±èƒ½åŸºäºè¿™äº›æ•°æ®äº§ç”Ÿæ¨¡å‹;åœ¨é¢å¯¹æ–°çš„æƒ…å†µæ—¶(ä¾‹å¦‚çœ‹åˆ°ä¸€ä¸ªæ²¡å‰–å¼€çš„è¥¿ç“œ)ï¼Œæ¨¡å‹ä¼šç»™æˆ‘ä»¬æä¾›ç›¸åº”çš„åˆ¤æ–­(ä¾‹å¦‚å¥½ç“œ) .å¦‚æœè¯´ è®¡ç®—æœºç§‘å­¦æ˜¯ç ”ç©¶å…³äº\"ç®—æ³•\"çš„å­¦é—®ï¼Œé‚£ä¹ˆç±»ä¼¼çš„ï¼Œå¯ä»¥è¯´æœºå™¨å­¦ä¹ æ˜¯ç ”ç©¶ å…³äº\"å­¦ä¹ ç®—æ³•\"çš„å­¦é—®. åœ¨ä¸‹é¢çš„è®ºè¿°ä¸­ï¼Œæˆ‘ä»¬å°†ä»æ¦‚å†µä»¥åŠå…·ä½“çš„ç”Ÿç‰©åœºæ™¯çœ‹åˆ°è¿™ä¸ªå®šä¹‰è¿˜æ˜¯å¾ˆåˆç†çš„ã€‚ æœ¬å›ç­”å‡å®šè¯»è€…å·²ç»äº†è§£è¿‡ä¸€äº›æœºå™¨å­¦ä¹ å’Œç”Ÿç‰©çš„æ¦‚å¿µã€‚ ä¸€. æœºå™¨å­¦ä¹ åœ¨ç”Ÿç‰©ç ”ç©¶ä¸­çš„åº”ç”¨æ¦‚è§ˆ 1. åŸºæœ¬æµç¨‹ ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨ç”Ÿç‰©ç ”ç©¶ä¸­ï¼Œä¸€é¡¹åº”ç”¨æœºå™¨å­¦ä¹ ä¸­çš„ç®—æ³•çš„ç ”ç©¶å¯ä»¥åˆ†ä¸ºå¦‚ä¸‹äº”æ­¥æµç¨‹ï¼š 1. è®¾è®¡å®éªŒï¼Œæ”¶é›†æ•°æ® 2. æ•°æ®æ¸…æ´— 3. ç‰¹å¾é€‰æ‹© 4. æ¨¡å‹æ„å»º 5. æ¨¡å‹è¯„ä¼° å¦‚ä¸‹é¢çš„æµç¨‹å›¾ï¼Œæ¥è‡ªDeep learning for computational biologyæ‰€ç¤º 2. æœ‰ç›‘ç£å­¦ä¹ ä¸æ— ç›‘ç£å­¦ä¹  æ¨¡å‹æ„å»ºçš„æ–¹æ³•ï¼ŒæŒ‰ç…§ç ”ç©¶çš„é—®é¢˜å¯ä»¥åˆ†ä¸ºï¼Œæœ‰ç›‘ç£å’Œæ— ç›‘ç£çš„ã€‚ æœ‰ç›‘ç£å­¦ä¹ æ˜¯æŒ‡ä¸€ç±»é’ˆå¯¹æœ‰æ ‡ç­¾çš„æ•°æ®æ¥é¢„æµ‹æ— æ ‡ç­¾æ•°æ®çš„æ ‡ç­¾çš„ç®—æ³•ï¼Œå¦‚æœæˆ‘ä»¬æŠŠè¿ç»­æ•°å€¼å˜é‡ä¹Ÿè§†ä¸ºæ ‡ç­¾çš„è¯ï¼Œé‚£ä¹ˆå›å½’ä¹Ÿæ˜¯æœ‰ç›‘ç£å­¦ä¹ ã€‚è€Œæ— ç›‘ç£å­¦ä¹ æ˜¯æŒ‡ä¸€ç±»é’ˆå¯¹æ— æ ‡ç­¾çš„æ•°æ®è¿›è¡Œè§„å¾‹å‘ç°çš„ç®—æ³•ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä¹Ÿæœ‰åŠç›‘ç£å­¦ä¹ ï¼Œå³åœ¨ ä¸€ä¸ªå…¸å‹çš„æœ‰ç›‘ç£çš„é—®é¢˜æ˜¯åˆ†ç±»é—®é¢˜ï¼Œä¸€ä¸ªå…¸å‹çš„æ— ç›‘ç£é—®é¢˜æ˜¯èšç±»é—®é¢˜ã€‚åœ¨è¿™ä¸ªå›ç­”æˆ‘ä»¬å°†ä»‹ç»è¿™ä¸¤ç±»é—®é¢˜çš„å…·ä½“çš„åœºæ™¯ã€‚ä¸‹å›¾æ¥è‡ªç»¼è¿°Deep learning for computational biology 3. ä¸‰ç±»åŸºæœ¬æ•°æ® å¤§å¤šæ•°ç”Ÿç‰©ç ”ç©¶ä¸»è¦å¯¹åºåˆ—æ•°æ®ï¼ŒçŸ©é˜µæˆ–è€…å¼ é‡æ•°æ®ï¼Œæˆåƒæ•°æ®è¿™ä¸‰ç±»åŸºæœ¬çš„æ•°æ®ä¸Šè¿›è¡Œæœºå™¨å­¦ä¹ ç®—æ³•çš„åº”ç”¨ã€‚ 3.1 åºåˆ—æ•°æ® æœ€åŸºæœ¬çš„ç”Ÿç‰©æ•°æ®ä¹‹ä¸€ï¼Œé€šå¸¸ä¸ºDNAåºåˆ—ï¼ŒRNAåºåˆ—ï¼Œè›‹ç™½è´¨åºåˆ—ã€‚ åœ¨äººç±»åŸºå› ç»„è®¡åˆ’æ—©æœŸçš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•å¿«é€Ÿè¿›è¡ŒåŸºå› ç»„æ³¨é‡Šï¼Œè¯¥é—®é¢˜å¯ä»¥è¡¨ç¤ºå¦‚ä¸‹,å›¾ç‰‡æ¥è‡ªMachine learning applications in genetics and genomicsï¼š åŸºå› ç»„æ³¨é‡Šæ˜¯ä¸€ä¸ªæœ‰ç›‘ç£æˆ–è€…åŠç›‘ç£çš„é—®é¢˜ï¼Œå› ä¸ºä¸€æ®µåºåˆ—æ˜¯ä¸æ˜¯åŸºå› å¯ä»¥é€šè¿‡EST(è¡¨è¾¾åºåˆ—æ ‡ç­¾)æ¥åˆ¤å®šï¼Œå…¶ä»–ç‰¹å¾å¯ä»¥é€šè¿‡ä¸€äº›ç”ŸåŒ–æˆ–è€…åˆ†å­å®éªŒæ¥æ ‡å®šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—åˆ°æ•°æ®æ ‡ç­¾ã€‚ æ­¤å¤–ï¼Œåºåˆ—æ•°æ®æ›´ä¸ºå¸¸è§çš„æ˜¯è¦åˆ†æä¸€äº›åˆ†å­æ¼”åŒ–çš„é—®é¢˜ï¼Œä¾‹å¦‚æœ€è¿‘å¤§å®¶å…³æ³¨çš„æ–°å† ç—…æ¯’çš„åˆ†å­æ¼”åŒ–ã€‚è¿™æ–¹é¢çš„æ¡ˆä¾‹å’Œç›¸å…³è®¨è®ºå¯è§ï¼šå‰‘æ¡¥å¤§å­¦ç ”ç©¶ç§°æ–°å† ç—…æ¯’åˆ†ä¸‰ä¸ªå˜ç§ï¼ŒA ç±»ç—…æ¯’ä¸ºã€Œçˆ†å‘æ ¹æºã€ï¼Œæ›´å¤šå‘ç°äºç¾å›½å’Œæ¾³æ´²ï¼Œè¿™ä¸€ç»“è®ºé è°±å—ï¼Ÿ è¿™æ˜¯ä¸€ä¸ªæ— ç›‘ç£çš„é—®é¢˜ï¼Œä¾‹å¦‚ï¼Œæˆ‘ä»¬å…¶å®å¹¶ä¸çŸ¥é“æ–°å† ç—…æ¯’å¯ä»¥åˆ†ä¸ºå‡ ä¸ªå˜ç§ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ•°æ®ä¸­çœ‹å‡ºå®ƒèƒ½åˆ†æˆå‡ ç±»ï¼Œç„¶åå†é€šè¿‡å…¶ä»–è¯æ®è¯æ˜è¿™ç§åˆ†ç±»æ˜¯åˆç†çš„ã€‚ 3.2 çŸ©é˜µæ•°æ® èŠ¯ç‰‡æŠ€æœ¯å’Œåç»­çš„é«˜é€šé‡æµ‹åºæŠ€æœ¯å¸¦æ¥äº†å¾ˆå¤šç§çŸ©é˜µæ•°æ®,è¿™ç±»çŸ©é˜µé€šå¸¸æ˜¯å¯¹æŸç±»å‹ç”Ÿç‰©ç‰¹å¾ï¼ˆåŸºå› ï¼Œè›‹ç™½ï¼Œè¡¨è§‚ä¿®é¥°ï¼ŒæŸ“è‰²è´¨äº’ä½œï¼‰çš„ä¸°åº¦æ±‡æ€»è€Œæˆçš„ã€‚æœ€å…¸å‹çŸ©é˜µæ•°æ®æ˜¯åŸºå› è¡¨è¾¾è°±ï¼ŒåŸºå› è¡¨è¾¾è°±çŸ©é˜µå¯ä»¥é€šè¿‡RNA-seqæ•°æ®è¿›è¡Œæ¯”å¯¹åçš„è½¬å½•æœ¬å®šé‡äº§ç”Ÿï¼ŒåŸºæœ¬æµç¨‹å’Œå¸¸è§åˆ†æç­–ç•¥å¦‚ä¸‹ï¼ˆå›¾ç‰‡æ¥è‡ªEnter the Matrix: Factorization Uncovers Knowledge from Omics)ï¼š è¿™ç±»æ•°æ®çš„åˆ†æé€šå¸¸æ˜¯æ— ç›‘ç£æˆ–è€…åŠç›‘ç£çš„ï¼Œæˆ‘ä»¬é€šå¸¸æƒ³é€šè¿‡çŸ©é˜µæ•°æ®å»å‘ç°ä¸€äº›å¯ç”¨äºè¯Šæ–­çš„åˆ†å­markerã€‚ 3.3 æˆåƒæ•°æ® ä»æ•°æ®å­˜å‚¨çš„æœ¬è´¨ä¸Šè®²ï¼Œæˆåƒæ•°æ®è¿˜æ˜¯çŸ©é˜µæ•°æ®ï¼ˆä¸è¿‡è€ƒè™‘åˆ°å¤šé€šé“å›¾åƒçš„å­˜åœ¨ï¼Œç§°ä¸ºå¼ é‡æ•°æ®æ›´ä¸ºè´´åˆ‡ï¼‰ï¼Œä½†æ˜¯å†…æ¶µä¸Šæ˜¯ä¸åŒçš„ï¼Œæˆåƒæ•°æ®è¡¨è¾¾æ›´å¤šçš„æ˜¯ç”Ÿç‰©ä½“å†…éƒ¨ç©ºé—´ä½ç½®ï¼ˆè¿˜æœ‰å½¢çŠ¶æˆ–è€…ç»“æ„ï¼‰çš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œä¸€å¼ è›‹ç™½äºšç»†èƒå®šä½çš„å›¾åƒï¼Œå¯ä»¥åæ˜ æŸæ ‡è®°çš„æ„Ÿå…´è¶£çš„è›‹ç™½è´¨ä½äºç»†èƒä¸­çš„ä»€ä¹ˆä½ç½®ï¼Œå¦‚æœæˆ‘ä»¬æœ‰å¾ˆå¤šè¿™æ ·çš„å›¾ç‰‡ï¼Œæ˜æ™ºçš„æ–¹æ³•æ˜¯å…ˆæ ‡è®°ä¸€éƒ¨åˆ†æ•°æ®ï¼Œè®­ç»ƒä¸€ä¸ªå·ç§¯ç¥ç»ç½‘ç»œï¼Œç„¶åå†å¯¹å‰©ä¸‹çš„å›¾ç‰‡è¿›è¡Œé¢„æµ‹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œï¼š å›¾ç‰‡æ¥è‡ªç»¼è¿°2 4. å…³äºæ·±åº¦å­¦ä¹ åŠå…¶åœ¨ç”Ÿç‰©ç ”ç©¶ä¸­çš„åº”ç”¨ æ·±åº¦å­¦ä¹ åˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼ŒæŒ‰ç…§Yann LeCun, Yoshua Bengioï¼ŒGeoffrey Hintonä¸‰ä½ä¸“å®¶åˆå†™çš„ç»¼è¿°çš„å®šä¹‰ï¼š &gt; Deep-learning methods are representation-learning methods with multiple levels of representation, obtained by composing simple but non-linear modules that each transform the representation at one level (starting with the raw input) into a representation at a higher, slightly more abstract level. With the composition of enough such transformations, very complex functions can be learned For. æ‹™è¯‘ä¸ºï¼šæ·±åº¦å­¦ä¹ æ–¹æ³•æ˜¯ä¸€ç§åŸºäºå¤šç§å±‚çº§è¿›è¡Œè¡¨ç¤ºçš„è¡¨ç¤ºå­¦ä¹ æ–¹æ³•ã€‚å…¶è¡¨ç¤ºèƒ½åŠ›æ˜¯é€šè¿‡ç»„åˆç®€å•çš„éçº¿æ€§çš„æ¨¡å—å®ç°çš„ã€‚æ¯ä¸€ä¸ªå°æ¨¡å—éƒ½å¯ä»¥æŠŠç¬¬ä¸€å±‚çš„åŸå§‹æ•°æ®è½¬æ¢ä¸ºæ›´ç¨å¾®æŠ½åƒçš„ç‰¹å¾ã€‚é€šè¿‡è¶³å¤Ÿå¤šçš„è¿™æ ·çš„è½¬æ¢è¿›è¡Œç»„åˆï¼Œå¯ä»¥å­¦ä¹ åˆ°éå¸¸å¤æ‚çš„å‡½æ•°(åŠŸèƒ½)ã€‚ ç›®å‰ï¼Œåœ¨åŸºå› ç»„å­¦çš„ä¸åŒå±‚çº§ï¼Œå‡æœ‰æ·±åº¦å­¦ä¹ çš„åº”ç”¨æ¡ˆä¾‹ï¼š å›¾ç‰‡æ¥è‡ªA primer on deep learning in genomics,æƒ³äº†è§£æ›´å¤šï¼Œè¯·é˜…è¯»è¿™ç¯‡æ–‡ç« ã€‚ 5. å¸¸è§ä¸åŒæœºå™¨ç®—æ³•çš„å®ç°è½¯ä»¶ é’ˆå¯¹ä¸åŒçš„å­¦ä¹ ç®—æ³•ï¼Œåœ¨Rä¸­çš„å¯ç”¨çš„æœºå™¨å­¦ä¹ åŒ…å¦‚ä¸‹ï¼Œå›¾ç‰‡æ¥è‡ªMachine learning for Big Data analytics in plants: pythonä¸Šçš„å¸¸ç”¨ç›¸å…³è½¯ä»¶åŒ…å¦‚ä¸‹.å›¾ç‰‡æ¥è‡ªBest Python Libraries for Machine Learning and Deep Learningï¼š Best Python Libraries for Machine Learning and Deep Learning äºŒ. æœºå™¨å­¦ä¹ åœ¨ç”Ÿç‰©ç ”ç©¶ä¸­çš„åº”ç”¨æ¡ˆä¾‹ 1. åŸºäºæœºå™¨å­¦ä¹ çš„å·®å¼‚è¡¨è¾¾ç½‘ç»œåˆ†æ ç”Ÿç‰©å­¦å®¶å¾ˆæ„Ÿå…´è¶£çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œä¸åŒæ¡ä»¶ä¸‹å“ªäº›åŸºå› è¡¨è¾¾ä¼šå‘ç”Ÿå˜åŒ–ï¼Œè¿™æ ·ä»–ä»¬å¯ä»¥æ·±å…¥ç ”ç©¶å…¶ä¸­çš„åˆ†å­æœºåˆ¶ï¼Œè¿›è€Œæ‰¾åˆ°ä¸€äº›å¯ä»¥æ‰¾åˆ°ä¸€äº›å¢å¼ºæˆ–è€…å‡å¼±ä»–ä»¬æƒ³è¦ç ”ç©¶è¡¨å‹çš„é¶ç‚¹ã€‚ å¸¸è§çš„æ€è·¯æ˜¯åšå‡å®šåŸºå› è¡¨è¾¾æœä»ä¸€ä¸ªåˆ†å¸ƒï¼Œç„¶åæ ¹æ®è¿™ä¸ªå‡è®¾æ„å»ºç»Ÿè®¡é‡ï¼Œè®¡ç®—ç»Ÿè®¡æ˜¾è‘—æ€§ï¼Œè®¾ç½®cutoffæ¥ç­›é€‰å‘ç”Ÿå·®å¼‚è¡¨è¾¾çš„åŸºå› ã€‚ ä½†æ˜¯è¿™æ ·åšå¯èƒ½å­˜åœ¨é—®é¢˜ï¼Œä¾‹å¦‚cutoffä¸º ,é‚£äº›è¢«åˆ¤å®šä¸ºç»Ÿè®¡ä¸æ˜¾è‘—çš„åŸºå› å°±çœŸçš„å’Œè¡¨å‹ç›¸å…³çš„å·®å¼‚è¡¨è¾¾åŸºå› å—ï¼Ÿæœ‰æ— æ›´å¥½çš„æ›¿ä»£æ–¹æ³•ï¼Ÿ æ–‡çŒ®Machine Learningâ€“Based Differential Network Analysis: A Study of Stress-Responsive Transcriptomes in Arabidopsisæä¾›äº†ä¸€ç§æ€è·¯ã€‚å‡å®šæˆ‘ä»¬å¯¹äºæ¨¡å¼æ¤ç‰©æ‹Ÿå—èŠ¥å“åº”å„ç§èƒè¿«æ¡ä»¶æ„Ÿå…´è¶£ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨åŸºäºæœºå™¨å­¦ä¹ çš„ç­–ç•¥å¯¹äºä¹‹å‰çš„å·®å¼‚è¡¨è¾¾æ–¹æ³•åšå‡ºæ”¹è¿›ï¼Œåˆ†ä¸ºå¦‚ä¸‹æ­¥éª¤ï¼š 1ï¼‰æ•°æ®æ”¶é›†ï¼Œæ¸…æ´—ä»¥åŠæ­£è´Ÿæ ·æœ¬æ„å»ºï¼š æ”¶é›†ä¸åŒèƒè¿«æ¡ä»¶ä¸‹çš„åŸºå› è¡¨è¾¾è°±(åŸºå› èŠ¯ç‰‡æ•°æ®ï¼‰ï¼Œè¿›è¡Œé¢„å¤„ç†å’Œæ ‡å‡†åŒ–ï¼Œæ”¶é›†ä¹‹å‰æŠ¥å¯¼è¿‡çš„å’Œç›¸å…³çš„åŸºå› ä½œä¸ºæ­£æ ·æœ¬ï¼Œå°†è¡¨è¾¾è°±ä¸­ä¸å‘ç”Ÿå˜åŒ–çš„åŸºå› ä½œä¸ºè´Ÿæ ·æœ¬ï¼Œå‰©ä¸‹çš„åŸºå› çš„è¡¨è¾¾è°±ä½œä¸ºæ— æ ‡ç­¾æ ·æœ¬ï¼› 2ï¼‰ç‰¹å¾æå–ï¼š é€šè¿‡å…±è¡¨è¾¾ç½‘ç»œçš„ç­–ç•¥ä»è¡¨è¾¾è°±ä¸­æå–ç‰¹å¾ã€‚åœ¨æ„å»ºå…±è¡¨è¾¾ç½‘ç»œçš„ä¹‹åï¼Œé‡‡ç”¨éšæœºæ£®æ—çš„æ–¹æ³•æŠŠæœªæ ‡ç­¾çš„æ ·æœ¬ä¸­çš„â€œnoninformativeâ€ genesï¼ˆä¸è¡¨è¾¾ï¼ŒæŒç»­è¡¨è¾¾ï¼Œä¸èƒè¿«æ— å…³çš„åŸºå› )è¿‡æ»¤æ‰äº†ï¼Œå‡å°‘äº†å…±è¡¨è¾¾ç½‘ç»œæ„å»ºçš„æ— ç”¨ä¿¡æ¯ã€‚è®¡ç®—æ¯ä¸ªåŸºå› åœ¨å…±è¡¨è¾¾ç½‘ç»œä¸­çš„PageRankç­‰ç»Ÿè®¡é‡ï¼Œä½œä¸ºç‰¹å¾ï¼› 3ï¼‰æ¨¡å‹æ„å»ºï¼š æ ¹æ®2ï¼‰ä¸­è®¡ç®—çš„ç‰¹å¾ï¼Œä»åˆ†å¥½çš„æ­£è´Ÿæ ·æœ¬ä¸­ï¼Œå†æ¬¡éšæœºæ£®æ—æ„å»ºæ¨¡å‹ï¼› 4ï¼‰æ¨¡å‹è¯„ä¼° å’Œlimmaç­‰æ–¹æ³•æ¯”è¾ƒï¼› 5ï¼‰æ¨¡å‹é¢„æµ‹ï¼Œå¹¶è¿›è¡ŒéªŒè¯ å°†è®­ç»ƒå¥½çš„æ¨¡å‹åº”ç”¨äºæ— æ ‡è®°çš„åŸºå› ä¸Šï¼Œé¢„æµ‹å‡ºå’Œæ–°çš„èƒè¿«ç›¸å…³çš„åŸºå› ï¼Œå¹¶é€šè¿‡TDNAæ’å…¥å®éªŒéªŒè¯ã€‚ ä¸Šè¿°æ­¥éª¤å¯ä»¥æ¦‚æ‹¬å¦‚ä¸‹ï¼Œ å›¾ç‰‡æ¥è‡ªMachine learning for Big Data analytics in plants 2. å¹²ç»†èƒåˆ†åŒ–è·¯å¾„é‡æ„ä¸æµå½¢å­¦ä¹  æ¡ˆä¾‹1æ˜¯æœ‰ç›‘ç£å­¦ä¹ çš„ä¾‹å­ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹æ— ç›‘ç£å­¦ä¹ çš„æ¡ˆä¾‹ã€‚ ç”Ÿç‰©å­¦æœ‰ä¸€ä¸ªå¾ˆè‘—åçš„æ¨¡å‹å«åšwaddington landscapeï¼Œè¯¥æ¨¡å‹æè¿°äº†å¹²ç»†èƒåœ¨åˆ†åŒ–è¿‡ç¨‹å¯ä»¥ç±»æ¯”äºä¸€ä¸ªæœ‰è´¨é‡çš„å°çƒè‡ªå‘æ²¿ç€å±±å¡ä»å±±é¡¶æ»šä¸‹å±±è°·çš„è¿‡ç¨‹ï¼Œä¸åŒçš„å±±åº•è¡¨ç¤ºäº†ç»†èƒçš„ç»ˆæœ«åˆ†åŒ–çŠ¶æ€ï¼Œè€Œä¸åŒçš„åˆ†æ”¯ç‚¹çš„å­˜åœ¨åˆ™æ˜¯ç»†èƒå‘½è¿å†³å®šçš„èŠ‚ç‚¹ã€‚è¿™ä¸ªè¿åŠ¨çš„è¿‡ç¨‹ä¸­ï¼Œç»†èƒçš„åŸºå› è¡¨è¾¾ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœæˆ‘ä»¬å‡å®šåŸºå› è¡¨è¾¾â€œç›¸è¿‘â€çš„ç»†èƒåœ¨è·¯å¾„ä¸Šä¹ŸæŒ¨å¾—å¾ˆè¿‘ï¼Œé‚£ä¹ˆåœ¨åŸºå› è¡¨è¾¾çš„é«˜ç»´æ•°æ®ä¸­åº”è¯¥åµŒå…¥äº†ä½ç»´çš„åˆ†åŒ–è·¯å¾„ï¼Œåˆ™æˆ‘ä»¬èƒ½é€šè¿‡æµå½¢å­¦ä¹ çš„æŠ€æœ¯ä»åŸºå› è¡¨è¾¾æ•°æ®ä¸­é‡æ„å‡ºåˆ†åŒ–çš„è·¯å¾„ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œ å›¾ç‰‡æ¥è‡ªManifold learning-based methods for analyzing single-cell RNA-sequencing data å…·ä½“æ¥è¯´ï¼Œæµå½¢å­¦ä¹ æ˜¯å¦‚ä½•è¿›è¡Œçš„å‘¢ï¼Ÿå¯ä»¥ç»“åˆå¦‚ä¸‹çš„æ¡ˆä¾‹è¿›è¡Œç†è§£ã€‚ç°åœ¨æœ‰ä¸¤ä¸ªå˜é‡ç»„æˆçš„ä¸€ä¸ªæ•°æ®é›†ï¼Œæˆ‘ä»¬å°†å…¶ç”»åœ¨ç›´è§’åæ ‡ç³»ä¸­ï¼Œå¯ä»¥çœ‹å‡ºæ ·æœ¬ç‚¹ä¸­å­˜åœ¨ä¸€ä¸ªèºæ—‹çš„è¶‹åŠ¿ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªäºŒç»´æ•°æ®é›†ä¸­ä¼¼ä¹åµŒå…¥äº†ä¸€ä¸ªä¸€ç»´æµå½¢ã€‚å¦‚ä½•é€šè¿‡è®¡ç®—çš„æ–¹å¼å°†å…¶æ‰¾å‡ºæ¥å‘¢ã€‚ç›´è§‰å‘Šè¯‰æˆ‘ä»¬ï¼Œå¿…é¡»å…ˆè®¡ç®—æ¯ä¸¤ä¸ªæ ·æœ¬ç‚¹ä¹‹é—´è·ç¦»ã€‚æˆ‘ä»¬åœ¨æ ·æœ¬ç‚¹ä¹‹é—´çš„è·ç¦»ä¹‹åå‘¢ï¼Œä¼šå‘ç°è¿™ä¸ªè·ç¦»é‡Œæ ·æœ¬ç‚¹çš„å±€éƒ¨é‚»è¿‘å…³ç³»å’Œæ•´ä½“é‚»è¿‘å…³ç³»æ··æ·†åœ¨äº†ä¸€èµ·ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å«åšæ ¸å‡½æ•°çš„æŠ€å·§ï¼Œå°†è·ç¦»è½¬æ¢ä¸ºé‚»è¿‘å…³ç³»ã€‚å¾—åˆ°å±€éƒ¨çš„è·ç¦»ä¹‹åå‘¢ï¼Œæˆ‘ä»¬æŠŠç›¸é‚»çš„ç‚¹è¿èµ·æ¥ï¼Œè¿™æ ·ä¾¿å¯ä»¥æœ€ç»ˆå¾—åˆ°é‚£ä¸ªæ ·æœ¬ç‚¹ä¸­åŒ…å«çš„èºæ—‹çš„ä¸€ç»´æµå½¢äº†ã€‚ å›¾ç‰‡æ¥è‡ªManifold learning-based methods for analyzing single-cell RNA-sequencing data é™„æ³¨ï¼šç²—æµ…çš„æ¥è¯´ï¼Œæ‰€è°“æµå½¢å°±æ˜¯ä¸€ä¸ªå±€éƒ¨çœ‹èµ·æ¥åƒæ˜¯æ¬§å‡ é‡Œå¾—ç©ºé—´çš„æ‹“æ‰‘ç©ºé—´ã€‚æ¯ä¸ªå±äºè¿™ä¸ªnç»´æµå½¢çš„ç‚¹çš„é‚»åŸŸéƒ½å¯ä»¥ä¸ä¸€ä¸ªnç»´æ¬§æ°ç©ºé—´å»ºç«‹ä¸€ä¸€æ˜ å°„çš„å…³ç³»ã€‚ï¼ˆæ›´ä¸ºä¸¥è°¨çš„å®šä¹‰è¯·çœ‹æ‹“æ‰‘å­¦æ•™æï¼‰ã€‚æµå½¢å­¦ä¹ ä¸€èˆ¬æ˜¯ç”¨æ¥å­¦ä¹ é«˜ç»´æ•°æ®å†…éƒ¨çš„ä½ç»´ç»“æ„ã€‚æœ€åŸºç¡€æµå½¢å­¦ä¹ ç®—æ³•æ˜¯PCAã€‚ ä»¥æœ€è¿‘å‘è¡¨çš„ä¸€ç§åŒæ—¶å®ç°ç”Ÿç‰©é«˜ç»´æ•°æ®å¯è§†åŒ–å’Œè·¯å¾„æ¨æ–­çš„ç®—æ³•PHATEä¸ºä¾‹ï¼Œè¯¥ç®—æ³•çš„æµç¨‹å¦‚ä¸‹ï¼Œï¼ˆå›¾ç‰‡æ¥è‡ªåŸæ–‡çŒ®ï¼‰ï¼š è¯¥ç®—æ³•çš„åŸºæœ¬æµç¨‹å’Œå…¶ä»–çš„æµå½¢å­¦ä¹ æ–¹æ³•å¤§è‡´ç±»ä¼¼ï¼Œä½†æ˜¯ä»–ä»¬çš„åˆ›æ–°ä¹‹å¤„æ˜¯å¼•å…¥äº†éšæœºæ¸¸èµ°ï¼Œè®¡ç®—æ‰©æ•£æ¦‚ç‡ï¼Œä»¥åŠæœ€ç»ˆè®²æ¬§å¼è·ç¦»è½¬åŒ–ä¸ºä¿¡æ¯è·ç¦»æ¥è¿›è¡Œembedingã€‚ ç¯‡å¹…æ‰€é™ï¼Œæˆ‘ä»¬ä¸ä¼šåœ¨è¿™é‡Œè°ˆå¾ˆå¤šè¯¥ç®—æ³•çš„è®¡ç®—ç»†èŠ‚ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯çœ‹çŸ¥ä¹ä¸Šä¸­æ–‡çš„ä»‹ç»ï¼šNat. Biotechnol | PHATEï¼šé«˜ç»´ç”Ÿç‰©æ•°æ®çš„å¯è§†åŒ–æ–¹æ³•ï¼Œæˆ–è€…ç›´æ¥é˜…è¯»åŸå§‹æ–‡çŒ®ã€‚ 3.å†·å†»ç”µé•œä¸­çš„å›¾åƒå¤„ç† è¿™éƒ¨åˆ†ï¼Œç¬”è€…ä¸æ˜¯ä¸“å®¶ï¼Œåªæ˜¯ä¸ºäº†æ‹“å±•è§†é‡åœ¨é‡Œè®°å½•ã€‚ åŸºç¡€çŸ¥è¯†æ¨èå¤§å®¶çœ‹ä¸‹courseraä¸Šé¢çš„åŠ å·ç†å·¥çš„å†·å†»ç”µé•œçš„è¯¾ç¨‹ï¼Œå°¤å…¶æ˜¯Tomographyé‚£ä¸€èŠ‚ã€‚ å…³äºå†·å†»ç”µé•œçš„èƒŒæ™¯å¤§å®¶è¯·çœ‹ ä¸ºä»€ä¹ˆå†·å†»ç”µé•œ (Cryo-EM) å»å¹´çªç„¶ç«äº†ï¼Ÿæ˜¯æœ‰ä»€ä¹ˆæŠ€æœ¯çªç ´å—ï¼Ÿ ä»¥åŠä»€ä¹ˆæ˜¯2015å¹´æœ€å—ç§‘å­¦ç•Œå…³æ³¨çš„æ–°æŠ€æœ¯ï¼Ÿ å½“ç„¶è¿˜æœ‰natureçš„æ–°é—»ç¨¿ æ ¹æ®natureè¿™ç¯‡æ–°é—»ç¨¿ï¼Œå†·å†»ç”µé•œå–å¾—çªç ´æ€§è¿›å±•ä¸»è¦è¦å½’åŠŸäºä¸¤ä¸ªäººï¼šRichard Hendersonå’ŒSjors Scheresè¿˜æœ‰ä»–ä»¬æ‰€åœ¨çš„å®éªŒå®¤ï¼šUK Medical Research Council Laboratory of Molecular Biology (LMB)ã€‚Richard Hendersonå’Œä»–çš„åŒäº‹ Nigel Unwin åœ¨1975å¹´çš„ä¸€ç‰‡æ–‡ç« ï¼ˆMolecular structure determination by electron microscopy of unstained crystalline specimensï¼‰ä¸­ä¸ºå†·å†»ç”µé•œæŠ€æœ¯åšå‡ºäº†å¥ åŸºæ€§çš„è´¡çŒ®ã€‚è€Œæ–°å‘å±•çš„ç›´æ¥ç”µå­æ¢æµ‹å™¨ä½¿å¾—å¯¹å¤§åˆ†å­çš„é«˜é€ŸåŠ¨æ€æˆåƒæˆä¸ºå¯èƒ½ã€‚æ–°æŠ€æœ¯å¸¦æ¥çš„å¤§æ•°æ®ä½¿å¾—Sjors Scheresæœ‰äº†åœ¨æ–¹æ³•å­¦å’Œè½¯ä»¶ä¸Šçš„çªç ´ã€‚ é‚£ä¹ˆï¼Œå†·å†»ç”µé•œå¸¦æ¥çš„ç»“æ„ç”Ÿç‰©å­¦çš„é©å‘½æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿç­”æ¡ˆæ˜¯å€Ÿç”¨åˆ°æœºå™¨å­¦ä¹ çš„æ€æƒ³ä¸æ–¹æ³•çš„ï¼Œå¦‚ä¸‹é¢è¿™å¼ å›¾æ‰€ç¤ºï¼š ï¼ˆæ¥è‡ªHow cryo-EM is revolutionizing structural biology) ç¬¬ä¸€æ­¥ï¼Œå°†è¦è§£æçš„è›‹ç™½åˆ†ç¦»çº¯åŒ–åˆ¶æ ·ä¹‹åï¼Œç”¨é«˜é€ŸåŠ¨æ€æˆåƒçš„è®°å½•è›‹ç™½çš„å„ç§æ„è±¡; ç¬¬äºŒæ­¥ï¼Œå¤„ç†å›¾åƒæ•°æ®ï¼ŒæŠŠå–å‘ç›¸åŒçš„å°é¢—ç²’re-alignï¼Œå€Ÿç”¨è´å¶æ–¯çš„æ€æƒ³ï¼›ä»è€Œå°†ç²—é¢—ç²’çš„æ¨¡å‹ç²¾ç»†åŒ–; ç¬¬ä¸‰æ­¥ï¼Œå¦‚æœæ˜¯æ··æ ·çš„æƒ…å†µï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨åˆ†ç±»æˆ–è€…èšç±»çš„æ–¹æ³•ï¼Œå°†æ··æ ·ä¸­å­˜åœ¨çš„ä¸åŒç»“æ„çš„è›‹ç™½æ„åƒè§£æå‡ºæ¥ã€‚ ç¬¬äºŒæ­¥çš„åŸºäºè´å¶æ–¯çš„re-alignå’Œç²¾ç»†åŒ–å¯ä»¥æ¦‚æ‹¬å¦‚ä¸‹ï¼š ï¼ˆå›¾ç‰‡æ¥è‡ªA Bayesian View on Cryo-EM Structure Determinationï¼‰ ç­–ç•¥ä¸ºé€šè¿‡å‚…é‡Œå¶å˜æ¢çš„æ–¹æ³•ç”¨è®¡ç®—æœºé‡æ„å‡ºç²—ç•¥çš„ç»“æ„æ¨¡å‹ç„¶åæŠŠè¿™ä¸ªç²—ç•¥çš„ç»“æ„æ¨¡å‹ä¸æˆåƒä¸Šä¸‡çš„æˆåƒæ•°æ®æ¯”å¯¹ï¼Œå¾—åˆ°æ¯ä¸ªå›¾åƒä¹‹é—´çš„ç›¸å¯¹ä½ç½®ã€‚é€šè¿‡ä½œè€…æ”¹è¿›çš„æœºå™¨å­¦ä¹ ä¸­å¸¸ç”¨çš„è´å¶æ–¯æ–¹æ³•ï¼Œå°†ç²—ç•¥çš„ç»“æ„æ¨¡å‹è°ƒæ•´ä¸ºæ–°çš„ä¸€ä¸ªæ›´ç²¾ç¡®çš„ç»“æ„ï¼Œå¦‚æ­¤è¿­ä»£ä»¥ç²¾ç‚¼æˆ‘ä»¬çš„æ¨¡å‹ï¼Œæ–‡ç« æåˆ°å¯¹äºæ ¸ç³–ä½“çš„ç»“æ„çš„è§£æä»–ä»¬è¿­ä»£äº†25æ¬¡ã€‚è¿™æ•´ä¸ªçš„è¿‡ç¨‹å°±æ˜¯æ‰€è°“çš„å–â€œå¹³å‡â€äº†ï¼Œä¸è¿‡æ˜¯åŸºäºæœºå™¨å­¦ä¹ çš„æ–¹æ³•ï¼Œç»“åˆå…ˆéªŒçš„çŸ¥è¯†æ¥å–å¾—â€œå¹³å‡â€å’Œè¿›è¡Œå…‰æ»‘ï¼Œå–å¾—ç²¾ç»†ç»“æ„ã€‚ è¿™éƒ¨åˆ†ä¸æ˜¯å¾ˆæ‡‚ï¼Œå†™çš„ä¸å¥½ï¼Œæ¬¢è¿æˆåƒå’Œå›¾åƒå¤„ç†æ–¹é¢çš„ä¸“å®¶æŒ‡æ­£ã€‚ ä¸‰. å›é¡¾åæ€ åœ¨ä¸Šè¿°è®ºè¿°ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»çš„æœºå™¨å­¦ä¹ åœ¨ç”Ÿç‰©ç ”ç©¶åº”ç”¨æ¡ˆä¾‹éƒ½åªåœ¨é—®è¿™æ ·ä¸€ç±»å‹é—®é¢˜ï¼šâ€æŸä¸€ç”Ÿç‰©ç°è±¡æ˜¯ä»€ä¹ˆï¼Ÿâ€œï¼Œä¸è¿‡å¯¹äºäººç±»ç¤¾ä¼šå‘å±•è€Œè¨€æ›´æœ‰ç›´æ¥æ„ä¹‰çš„é—®é¢˜æ˜¯ï¼Œâ€è®¤è¯†è¿™ä¸€ç”Ÿç‰©ç°è±¡å¯èƒ½çš„æ¨¡å¼ä¹‹åæˆ‘ä»¬è¯¥æ€ä¹ˆåŠâ€œï¼Œé—®è¿™ç±»é—®é¢˜çš„äººä¸€èˆ¬éƒ½æ˜¯åŒ»ç”Ÿæˆ–è€…è¯ä¼çš„ç§‘å­¦å®¶ã€‚å½“ç„¶ï¼Œç›®å‰ä¹Ÿæœ‰è¿™æ–¹é¢çš„æˆç†Ÿæµç¨‹å¯ä»¥å‚è€ƒ: ï¼ˆå›¾ç‰‡æ¥è‡ªApplications of machine learning in drug discovery and development æœ€è¿‘ä¹Ÿæœ‰ç§‘å­¦å®¶ç”¨æ·±åº¦å­¦ä¹ çš„æ–¹æ³•ï¼Œå‘ç°äº†æ–°çš„æŠ—ç”Ÿç´ ï¼š æ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥çœ‹è¿™ç¯‡æ–‡çŒ®ã€‚ æ­¤å¤–ï¼Œä¸ªäººç†è§£ï¼Œæœºå™¨å­¦ä¹ å°±æ˜¯ä¸€ç§æ™ºèƒ½çš„æ•°æ®æŒ–æ˜æŠ€æœ¯ï¼Œå®ƒä¾æ®å…ˆéªŒçš„çŸ¥è¯†å»ºç«‹é¢„æµ‹æ¨¡å‹æ¥è¯†åˆ«å¤§æ•°æ®ä¸­çš„æœ‰ç”¨ä¿¡æ¯ã€‚æ‰€ä»¥åªè¦æœ‰å¤§æ•°æ®å’Œå‰æœŸç§¯ç´¯çš„å…ˆéªŒçŸ¥è¯†ï¼Œå°±æœ‰æœºå™¨å­¦ä¹ æ–¹æ³•ç”¨æ­¦ä¹‹åœ°ã€‚ è¯´å‡ å¥ä¸é¢˜ç›®æ— å…³çš„è¯ï¼Œä¸ªäººæ„Ÿè§‰å…¶å®è¿™ä¸ªé¢˜ç›®ä¹Ÿå¯ä»¥å›ç­”å­¦ç”Ÿç‰©çš„äººå¤šå­¦ç‚¹åŸºç¡€çš„æ•°å­¦å’Œç‰©ç†çŸ¥è¯†æœ‰ç”¨å—ï¼Ÿæˆ‘è§‰å¾—æ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚ä½ æƒ³ææ¸…æ¥šå†·å†»ç”µé•œæˆåƒçš„åŸç†ï¼Œä½ å¿…é¡»æ‡‚ç‚¹ç‰©ç†çŸ¥è¯†ï¼ˆå¹²æ¶‰è¡å°„ä¹‹ç±»çš„ï¼‰è¿˜å¾—æ‡‚ç‚¹æ•°å­¦ç‰©ç†æ–¹æ³•ï¼ˆå¦‚å‚…é‡Œå¶å˜æ¢ä¸å®ƒçš„é€†ï¼‰ã€‚å½“ç„¶æƒ³è¦è¿›è¡Œæœºå™¨å­¦ä¹ ï¼Œå½“ç„¶å¾—æœ‰ç»Ÿè®¡å­¦å’Œæ•°æ®çš„å¯è§†åŒ–æ–¹æ³•çš„æ•°å­¦åŸºç¡€å’Œè®¡ç®—æœºç¼–ç¨‹åŸºç¡€ï¼ˆPythonæˆ–è€…Rï¼‰äº†ã€‚å­¦ç§‘ä¹‹é—´å…¶å®æ˜¯å¯ä»¥äº’é€šæœ‰æ— çš„ï¼Œç„¶è€Œè¿™ç‚¹å¸¸å¸¸è¢«ç›®å…‰çŸ­æµ…çš„ä¸€äº›äººå¿½ç•¥äº†ï¼Œå¸Œæœ›å…³æ³¨è¿™ä¸ªé—®é¢˜çš„äººå¯ä»¥èƒ½å¤šä»è¿™ä¸ªè§’åº¦æ¥å­¦ä¹ ï¼Œæ€è€ƒé—®é¢˜ï¼Œè§£å†³é—®é¢˜ã€‚ é™„ï¼šæ—¥å¿— 2016.3 åˆ›å»ºå›ç­” 2016.4.14 ç”¨å‘¨å¿—åè€å¸ˆã€Šæœºå™¨å­¦ä¹ ã€‹è¡¥å……å‰è¨€ 2020.4.12 åŸå›ç­”å› ã€Œè¿åçŸ¥ä¹ç¤¾åŒºç®¡ç†è§„å®šã€è¢«åˆ é™¤ã€‚ 2020.4.13-15 æŒ‰ç…§çŸ¥ä¹ç¤¾åŒºç®¡ç†è§„å®šåšå‡ºä¿®è®¢ã€‚é‡æ–°æäº¤ã€‚ 2020.04.16 ä¿®æ”¹æ’ç‰ˆé”™è¯¯","categories":[{"name":"reference","slug":"reference","permalink":"https://landau1994.github.io/categories/reference/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"machine learning","slug":"machine-learning","permalink":"https://landau1994.github.io/tags/machine-learning/"}]},{"title":"è¯»å…³äºå¢å¼ºå­ç ”ç©¶çš„ç°çŠ¶ä¸æœªæ¥çš„ä¸€ç¯‡ç»¼è¿°","slug":"è¯»å…³äºå¢å¼ºå­ç ”ç©¶çš„ç°çŠ¶ä¸æœªæ¥çš„ä¸€ç¯‡ç»¼è¿°","date":"2020-04-08T13:10:48.000Z","updated":"2025-01-11T17:16:31.880Z","comments":true,"path":"2020/04/08/è¯»å…³äºå¢å¼ºå­ç ”ç©¶çš„ç°çŠ¶ä¸æœªæ¥çš„ä¸€ç¯‡ç»¼è¿°/","link":"","permalink":"https://landau1994.github.io/2020/04/08/%E8%AF%BB%E5%85%B3%E4%BA%8E%E5%A2%9E%E5%BC%BA%E5%AD%90%E7%A0%94%E7%A9%B6%E7%9A%84%E7%8E%B0%E7%8A%B6%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0/","excerpt":"","text":"æ–‡ç« ä¿¡æ¯ é¢˜ç›®ï¼šTowards a comprehensive catalogue of validated and target- linked human enhancers å†…å®¹ å›é¡¾äº†Enhancer biologyçš„ç ”ç©¶å†å²ï¼Œæ¦‚è¿°äº†ç°æœ‰çš„ç ”ç©¶æŠ€æœ¯ï¼Œæå‡ºäº†target-linkedçš„ç ”ç©¶æ¡†æ¶ã€‚ æ–‡ç« æœ€æœ‰æ„æ€çš„ä¸€ä¸ªæ€»ç»“å›¾å¦‚ä¸‹: æ€»ç»“ä¸è¯„è¿°ï¼š åƒEnhancer biologyè¿™æ ·çš„åˆ†å­æœºåˆ¶ï¼Œå¸¦æœ‰å¾ˆå¼ºçš„å„æ–¹é¢çš„å¼‚è´¨æ€§ï¼Œä¸å…¶å¯»æ±‚ä¸€ä¸ªcomprehensive çš„ç†è§£ï¼Œä¸å¦‚åšé€å½»åœ¨æŸä¸€ç§éå¸¸é‡è¦çš„ç–¾ç—…ï¼Œä¾‹å¦‚Cancerä¸­çš„è°ƒæ§ä½œç”¨ï¼ŸEnhancer+single cellï¼Œç»†èƒå†…éƒ¨è°ƒæ§ä¸ç»†èƒé—´è°ƒæ§çš„ç ”ç©¶éƒ½å¾ˆé‡è¦ã€‚ é‡Œé¢å…³äºENCODEçš„å„ç§ç»„å­¦æŠ€æœ¯ï¼Œä»¥åŠ3D genomeçš„æŠ€æœ¯å’ŒCRISPR-screençš„ä¼˜ç¼ºç‚¹ä»‹ç»å¾ˆå¥½ã€‚","categories":[{"name":"reference","slug":"reference","permalink":"https://landau1994.github.io/categories/reference/"}],"tags":[{"name":"sc-seq","slug":"sc-seq","permalink":"https://landau1994.github.io/tags/sc-seq/"},{"name":"genomics","slug":"genomics","permalink":"https://landau1994.github.io/tags/genomics/"},{"name":"genetics","slug":"genetics","permalink":"https://landau1994.github.io/tags/genetics/"},{"name":"ENCODE","slug":"ENCODE","permalink":"https://landau1994.github.io/tags/ENCODE/"},{"name":"HiC","slug":"HiC","permalink":"https://landau1994.github.io/tags/HiC/"},{"name":"ChIP-seq","slug":"ChIP-seq","permalink":"https://landau1994.github.io/tags/ChIP-seq/"},{"name":"ATAC-seq","slug":"ATAC-seq","permalink":"https://landau1994.github.io/tags/ATAC-seq/"}]},{"title":"å…³äºè‚¿ç˜¤çš„å…ç–«æ²»ç–—é¶ç‚¹","slug":"å…³äºè‚¿ç˜¤çš„å…ç–«æ²»ç–—é¶ç‚¹","date":"2020-04-08T12:58:13.000Z","updated":"2025-01-11T17:16:31.865Z","comments":true,"path":"2020/04/08/å…³äºè‚¿ç˜¤çš„å…ç–«æ²»ç–—é¶ç‚¹/","link":"","permalink":"https://landau1994.github.io/2020/04/08/%E5%85%B3%E4%BA%8E%E8%82%BF%E7%98%A4%E7%9A%84%E5%85%8D%E7%96%AB%E6%B2%BB%E7%96%97%E9%9D%B6%E7%82%B9/","excerpt":"","text":"ä»Šå¤©è¯»åˆ°ä¸€ä¸ªå¾ˆæ¸…æ¥šçš„ç»¼è¿°çš„ç¿»è¯‘ç¬”è®°ï¼Œè®²è‚¿ç˜¤å…ç–«æ²»ç–—é¶ç‚¹çš„ï¼Œè¯»è€…å¯ä»¥ç§»æ­¥åˆ° ç”Ÿç‰©ä¿¡æ¯å­¦ä¸“ä¸šéœ€è¦ä»€ä¹ˆæ ·çš„ç”Ÿç‰©çŸ¥è¯†ï¼Ÿé˜…è¯»ã€‚ åŸæ–‡çŒ®é‡Œæœ‰å¼ æ€»ç»“çš„å›¾å¾ˆä¸é”™ï¼š å¯ä»¥ä½œä¸ºæœ¬æ–‡çš„æ€»ç»“ã€‚","categories":[{"name":"reference","slug":"reference","permalink":"https://landau1994.github.io/categories/reference/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"biology","slug":"biology","permalink":"https://landau1994.github.io/tags/biology/"},{"name":"immunology","slug":"immunology","permalink":"https://landau1994.github.io/tags/immunology/"}]},{"title":"quote_20200405","slug":"quote-20200405","date":"2020-04-05T13:52:53.000Z","updated":"2025-01-11T17:16:31.845Z","comments":true,"path":"2020/04/05/quote-20200405/","link":"","permalink":"https://landau1994.github.io/2020/04/05/quote-20200405/","excerpt":"","text":"æ—¶é—´å°±åƒä¸€æ¡æ²³æµï¼Œ åœ¨è¿™æˆ‘ä»¬é¡ºæµè€Œä¸‹ï¼Œ é‡åˆ°ç°å®ï¼Œ éœ€è¦å†³ç­–ï¼Œ ä½†æˆ‘ä»¬æ— æ³•åœç•™ï¼Œä¹Ÿæ— æ³•å›é¿ï¼Œ åªèƒ½ä»¥æœ€å¥½çš„æ–¹å¼åº”ä»˜ã€‚â€”â€”ã€ŠåŸåˆ™ã€‹","categories":[{"name":"others","slug":"others","permalink":"https://landau1994.github.io/categories/others/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"cxt_Chap6_Cytokines","slug":"cxt-Chap6-Cytokines","date":"2020-04-05T13:44:02.000Z","updated":"2025-01-11T17:16:31.834Z","comments":true,"path":"2020/04/05/cxt-Chap6-Cytokines/","link":"","permalink":"https://landau1994.github.io/2020/04/05/cxt-Chap6-Cytokines/","excerpt":"","text":"å¦‚æ— ç‰¹åˆ«è¯´æ˜ï¼Œå¼•ç”¨éƒ¨åˆ†å‡ºè‡ªã€ŠåŒ»å­¦å…ç–«å­¦ã€‹ï¼ˆç¬¬ä¸ƒç‰ˆï¼Œæ›¹é›ªæ¶›ä¸»ç¼–ï¼Œäººå«ç¤¾å‡ºç‰ˆï¼‰ç¬¬å…­ç« ï¼Œç»†èƒå› å­ã€‚ 1. ç»†èƒå› å­çš„å®šä¹‰ ç»†èƒå› å­æ˜¯ç”±å…ç–«ç»†èƒåŠç»„ç»‡ç»†èƒåˆ†æ³Œçš„åœ¨ç»†èƒé—´å‘æŒ¥ç›¸äº’è°ƒæ§ä½œç”¨çš„çš„ä¸€ç±»å°åˆ†å­å¯æº¶æ€§è›‹ç™½è´¨ï¼Œé€šè¿‡ç»“åˆå“åº”å—ä½“è°ƒèŠ‚ç»†èƒç”Ÿé•¿åˆ†åŒ–å’Œæ•ˆåº”ï¼Œè°ƒæ§å…ç–«åº”ç­”ï¼Œåœ¨ä¸€å®šæ¡ä»¶ä¸‹ä¹Ÿå‚ä¸ç‚ç—‡ç­‰å¤šç§ç–¾ç—…çš„å‘ç”Ÿã€‚ ä½œç”¨æ–¹å¼ï¼šè‡ªåˆ†æ³Œæ–¹å¼ï¼Œæ—åˆ†æ³Œæ–¹å¼ï¼Œå†…åˆ†æ³Œæ–¹å¼ï¼› åŠŸèƒ½ç‰¹ç‚¹ï¼šå¤šæ•ˆæ€§ï¼Œé‡å æ€§ï¼ŒååŒæ€§ï¼Œæ‹®æŠ—æ€§ï¼› 2. ç»†èƒå› å­çš„ç§ç±» æ ¹æ®ç»“æ„å’ŒåŠŸèƒ½å¯ä»¥åˆ†ä¸ºå¦‚ä¸‹å…­å¤§ç±»ï¼š - ç™½ç»†èƒä»‹ç´ (interleukin, IL)ï¼ŒIL1-IL38ã€‚ - é›†è½åˆºæ¿€å› å­(colony-stimulating factor, CSF)ï¼Œæ˜¯æŒ‡èƒ½å¤Ÿåˆºæ¿€å¤šèƒ½é€ è¡€å¹²ç»†èƒå’Œä¸åŒåˆ†åŒ–é˜¶æ®µçš„é€ è¡€ç¥–ç»†èƒåˆ†åŒ–å’Œå¢æ®–çš„ç»†èƒå› å­ã€‚ä¸»è¦åŒ…æ‹¬ç²’ç»†èƒ-å·¨å™¬ç»†èƒé›†è½åˆºæ¿€å› å­(GM-CSF), å·¨å™¬ç»†èƒé›†è½åˆºæ¿€å› å­ï¼ˆM-CSF)ï¼Œçº¢ç»†èƒç”Ÿæˆç´ (EPO)ï¼Œå¹²ç»†èƒå› å­(SCF)å’Œè¡€å°æ¿ç”Ÿæˆç´ (TPO)ç­‰ã€‚åˆ†åˆ«è¯±å¯¼é€ è¡€å¹²ç»†èƒæˆ–ç¥–ç»†èƒåˆ†åŒ–å¢æ®–ä¸ºç›¸åº”çš„ç»†èƒã€‚ - å¹²æ‰°ç´ ï¼ˆinterferon, IFN), å› å…·æœ‰å¹²æ‰°ç—…æ¯’å¤åˆ¶çš„åŠŸèƒ½è€Œå¾—åã€‚IFNæ ¹æ®å…¶ç»“æ„ç‰¹å¾åŠç”Ÿç‰©å­¦æ´»æ€§å¯åˆ†ä¸ºIå‹ã€IIå‹å’ŒIIIå‹ã€‚Iå‹IFNä¸»è¦åŒ…æ‹¬IFN-ã€IFN-, ä¸»è¦ç”±ç—…æ¯’æ„ŸæŸ“çš„ç»†èƒã€pDCç»†èƒç­‰äº§ç”Ÿï¼›IIå‹IFNå³IFN-ï¼Œä¸»è¦ç”±æ´»åŒ–Tç»†èƒå’ŒNKç»†èƒäº§ç”Ÿã€‚IIIå‹IFNåŒ…æ‹¬IFN-(IL-29)ï¼ŒIFN-(IL-28A)å’ŒIFN-(IL-28B)ï¼Œä¸»è¦ç”±DCç»†èƒäº§ç”Ÿã€‚IFNå…·æœ‰æŠ—ç—…æ¯’ã€æŠ—ç»†èƒå¢æ®–ã€æŠ—è‚¿ç˜¤å’Œå…ç–«è°ƒèŠ‚ç­‰ä½œç”¨ã€‚ - è‚¿ç˜¤åæ­»å› å­(tumor necrosis factor, TNF)å®¶æ—ã€‚è‚¿ç˜¤åæ­»å› å­å› æœ€åˆè¢«å‘ç°å…¶èƒ½é€ æˆè‚¿ç˜¤ç»„ç»‡åæ­»è€Œå¾—åï¼ŒåŒ…æ‹¬TNF-å’ŒTNF-ï¼Œå‰è€…ä¸»è¦ç”±æ´»åŒ–çš„å•æ ¸/å·¨å™¬ç»†èƒäº§ç”Ÿï¼Œåè€…ä¸»è¦ç”±æ´»åŒ–çš„Tç»†èƒäº§ç”Ÿï¼Œåˆç§°æ·‹å·´æ¯’ç´ (lymphotoxin, LT)ã€‚TNFå®¶æ—ç›®å‰å·²ç»å‘ç°TRAIL(TNF related apoptosis-inducing ligand)ã€FasLã€CD40Lç­‰30ä½™ç§ç»†èƒå› å­ã€‚TNFå®¶æ—æˆå‘˜åœ¨è°ƒèŠ‚å…ç–«åº”ç­”ã€æ€ä¼¤é¶ç»†èƒå’Œè¯±å¯¼ç»†èƒå‡‹äº¡ç­‰è¿‡ç¨‹ä¸­å‘æŒ¥é‡è¦ä½œç”¨ã€‚ - ç”Ÿé•¿å› å­ï¼ˆgrowth factorï¼ŒGF)æ³›æŒ‡ä¸€ç±»å¯ä¿ƒè¿›ç›¸åº”ç»†èƒç”Ÿé•¿å’Œåˆ†åŒ–çš„ç»†èƒå› å­ã€‚å…¶ç§ç±»è¾ƒå¤šï¼ŒåŒ…æ‹¬è½¬åŒ–ç”Ÿé•¿å› å­-(transforming growth factor-,TGF-)ã€è¡€ç®¡å†…çš®ç»†èƒç”Ÿé•¿å› å­(VEGF)ã€è¡¨çš®ç”Ÿé•¿å› å­(EGF)ã€æˆçº¤ç»´ç»†èƒç”Ÿé•¿å› å­(FGF)ã€ç¥ç»ç”Ÿé•¿å› å­(NGF)ã€è¡€å°æ¿ç”Ÿé•¿å› å­(PDGF)ç­‰ã€‚ - è¶‹åŒ–å› å­(chemokine) æ˜¯ä¸€ç±»ç»“æ„ç›¸ä¼¼ï¼Œåˆ†å­é‡çº¦812kDï¼Œå…·æœ‰è¶‹åŒ–åŠŸèƒ½çš„ç»†èƒå› å­ã€‚å‡ ä¹æ‰€æœ‰çš„è¶‹åŒ–å› å­éƒ½å«æœ‰ç”±2å¯¹æˆ–ä¸€å¯¹ä¿å®ˆçš„åŠèƒ±æ°¨é…¸æ®‹åŸº(C)å½¢æˆçš„åˆ†å­å†…äºŒç¡«åŒ–é”®ã€‚å¯ä»¥æ ¹æ®é è¿‘æ°¨åŸºç«¯çš„Cçš„ä¸ªæ•°ä»¥åŠæ’åˆ—é¡ºåºå°†è¶‹åŒ–å› å­åˆ†ä¸ºå››ä¸ªå®¶æ—ï¼š1ï¼‰Cäºšå®¶æ—ï¼šæ°¨åŸºé…¸ç«¯åªæœ‰1ä¸ªCï¼Œè¯¥åˆ†å­å†…åªæœ‰ä¸€ä¸ªåˆ†å­å†…äºŒç¡«åŒ–é”®ï¼›2ï¼‰CCäºšå®¶æ—ï¼šæ°¨åŸºç«¯2ä¸ªCç›¸é‚»ï¼›3ï¼‰CXCäºšå®¶æ—ï¼šæ°¨åŸºé…¸2ä¸ªCè¢«1ä¸ªæ°¨åŸºé…¸æ®‹åŸºéš”å¼€ï¼›4ï¼‰CX3Cäºšå®¶æ—ï¼šæ°¨åŸºç«¯2ä¸ªCè¢«3ä¸ªæ°¨åŸºé…¸æ®‹åŸºéš”å¼€ï¼Œç¾§åŸºç«¯è·¨ç»†èƒè†œã€‚ å·²ç»å‘ç°çš„è¶‹åŒ–å› å­æœ‰ï¼ŒCXCL116ï¼ŒCCL128ï¼ŒXCL12ï¼ŒCX3CL1. 3. ç»†èƒå› å­å—ä½“ ç»†èƒå› å­å—ä½“å¯ä»¥æ ¹æ®å…¶ç»“æ„ç‰¹ç‚¹è¢«åˆ†ä¸ºå¦‚ä¸‹å…­ä¸ªå®¶æ—ï¼š - Iå‹ç»†èƒå› å­å—ä½“å®¶æ—ï¼Œä¹Ÿç§°ä¸ºè¡€ç»†èƒç”Ÿè¾°ç´ å—ä½“å®¶æ—(hematopoietin receptor family)ï¼Œ é€šè¿‡ JAK-STATé€šè·¯è½¬å¯¼ä¿¡å·ï¼› - IIå‹ç»†èƒå› å­å—ä½“å®¶æ—ï¼Œä¹Ÿç§°ä¸ºå¹²æ‰°ç´ å—ä½“å®¶æ—(interferon receptor family)ï¼Œä¹Ÿæ˜¯é€šè¿‡JAK-STATé€šè·¯è½¬å¯¼ä¿¡å·ï¼› - è‚¿ç˜¤åæ­»å› å­å—ä½“å®¶æ—(tumor necrosis factor family)ï¼Œä¸»è¦é€šè¿‡TRAF-NF-kBï¼ŒTRAF-AP-1 é€šè·¯è½¬å¯¼ä¿¡å·ï¼› - å…ç–«çƒè›‹ç™½è¶…å®¶æ—å—ä½“(Ig superfamily receptor, IgSFR)ï¼Œä¼šç»“åˆé›†è½åˆºæ¿€å› å­ï¼› - IL-17å—ä½“å®¶æ—(IL-17 receptor family)ï¼Œä¸»è¦é€šè¿‡TRAF-NF-kBé€šè·¯è½¬å¯¼ä¿¡å·ï¼› - è¶‹åŒ–å› å­å—ä½“å®¶æ—(chemokine receptor family) ï¼Œå±äºGPCRä¸­çš„ä¸€å‘˜ã€‚ 4.remark å¯å¦ä»åŸºå› è¡¨è¾¾è°ƒæ§å‡ºå‘ï¼Œæ¥æè¿°ç»†èƒå› å­çš„åŠŸèƒ½ï¼Ÿ","categories":[{"name":"genomics","slug":"genomics","permalink":"https://landau1994.github.io/categories/genomics/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"biology","slug":"biology","permalink":"https://landau1994.github.io/tags/biology/"},{"name":"immunology","slug":"immunology","permalink":"https://landau1994.github.io/tags/immunology/"}]},{"title":"HCL papar","slug":"HCL-papar","date":"2020-04-05T13:32:40.000Z","updated":"2025-01-11T17:16:31.813Z","comments":true,"path":"2020/04/05/HCL-papar/","link":"","permalink":"https://landau1994.github.io/2020/04/05/HCL-papar/","excerpt":"","text":"é¢˜ç›®ï¼šConstruction of human cell landscape at single-cell level ç§‘å­¦é—®é¢˜ï¼šå¦‚ä½•æ„å»ºäººç±»ç»†èƒå›¾è°± å®éªŒï¼šç”¨å…¶è‡ªå·±å¼€å‘çš„Microwell-seqï¼Œè¯¥ç ”ç©¶å……åˆ†åˆ©ç”¨Microwell-seqæˆæœ¬ä½å»‰ï¼ŒåŒç»†èƒæ±¡æŸ“ç‡ä½å’Œç»†èƒæ™®é€‚æ€§å¹¿ç­‰ä¼˜åŠ¿ï¼Œå»ºç«‹äº†70å¤šä¸‡ä¸ªå•ç»†èƒçš„è½¬å½•ç»„æ•°æ®åº“ï¼Œé‰´å®šäº†äººä½“100ä½™ç§ç»†èƒå¤§ç±»å’Œ800ä½™ç§ç»†èƒäºšç±»ã€‚åŸºäºè¯¥æ•°æ®åº“ï¼Œå›¢é˜Ÿå¼€å‘äº†scHCLå•ç»†èƒæ¯”å¯¹ç³»ç»Ÿç”¨äºäººä½“ç»†èƒç±»å‹çš„è¯†åˆ«ï¼Œå¹¶æ­å»ºäº†äººç±»ç»†èƒè“å›¾ç½‘ç«™http://bis.zju.edu.cn/HCL/ï¼ˆå›½å®¶åŸºå› åº“é•œåƒhttps://db.cngb.org/HCL/ï¼‰ã€‚ åˆ†æï¼šâ€œtSNE+å›¾èšç±»â€ï¼ˆfig1b,fig1c,fig1d); EC,Epi, Stromal cellåˆ†æ³ŒLigandçš„èƒ½åŠ›ï¼ˆFig2c)ä¸»è¦æ˜¯Adultçš„ç»†èƒï¼ˆå¾®ç¯å¢ƒï¼Ÿï¼‰ï¼›è·¯å¾„åˆ†æï¼ˆFig3)ï¼›è°ƒæ§åˆ†æï¼ˆFig4) è®¨è®ºï¼šå›¾è°±å¼å·¥ä½œï¼›è¯æ˜äº†æ¦‚å¿µçš„å¯è¡Œæ€§ï¼›ä½†æ˜¯ä¸å¦‚HCAé‚£ä¹ˆæ¿€åŠ¨äººå¿ƒï¼Ÿ","categories":[{"name":"reference","slug":"reference","permalink":"https://landau1994.github.io/categories/reference/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"scRNA-seq","slug":"scRNA-seq","permalink":"https://landau1994.github.io/tags/scRNA-seq/"},{"name":"biology","slug":"biology","permalink":"https://landau1994.github.io/tags/biology/"}]},{"title":"Dobrow-chap2","slug":"Dobrow-chap2","date":"2020-04-05T13:17:46.000Z","updated":"2025-01-11T17:16:31.801Z","comments":true,"path":"2020/04/05/Dobrow-chap2/","link":"","permalink":"https://landau1994.github.io/2020/04/05/Dobrow-chap2/","excerpt":"","text":"å¯¹äº Introduction to stochastic processes with Rä¸€ä¹¦çš„ç¬”è®° Let us finish the article and the whole book with a good example of dependent trials, which approximately can be considered as a simple chain. â€“Andrei Andreyevich Markov Chap2: Markov Chains: First steps æœ¬ç« è®²é©¬å°”å¯å¤«é“¾ Introduction å¼•å…¥çš„æ¡ˆä¾‹ï¼š è¿™ä¸€èŠ‚ï¼Œç”¨ä¸€ä¸ªç±»ä¼¼å¤§å¯Œç¿çš„æ¸¸æˆæ¥å¼•å…¥é©¬å°”å¯å¤«å¤«æ€§ã€‚ é©¬å°”å¯å¤«é“¾çš„å½¢å¼åŒ–å®šä¹‰ä¸º &gt; Markov Chain &gt; Let be a discrete set. A Markov chain is a sequence of random variables taking values in with the property that &gt; &gt; for all The set is the state space of the Markov chain. ã€ ç§°ä¸ºåœ¨æ—¶åˆ»nåˆ°è¾¾çŠ¶æ€iã€‚ æ—¶é—´é½æ€§é©¬å°”å¯å¤«é“¾ï¼š transition matrix: næ­¥è½¬ç§»çŸ©é˜µè®¡ç®—ï¼ˆçŸ©é˜µä¹˜æ³•ï¼‰ è‹¥å¹²ä¾‹å­ï¼š æ”¶æ•›äºä¸€ä¸ªå„è¡Œç›¸ç­‰çš„çŸ©é˜µï¼› ä¸æ”¶æ•›ï¼Œè¿›å…¥è·³è·ƒçš„çŠ¶æ€ï¼› æ”¶æ•›äºä¸€ä¸ªå„è¡Œä¸ç›¸ç­‰çš„çŸ©é˜µ ç¬¬äº”éƒ¨åˆ†ä»ç›´è§‚ä¸Šä¸ºä¸‹ä¸€ç« é“ºè·¯ã€‚","categories":[{"name":"math","slug":"math","permalink":"https://landau1994.github.io/categories/math/"}],"tags":[{"name":"stochastic Process","slug":"stochastic-Process","permalink":"https://landau1994.github.io/tags/stochastic-Process/"},{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"Dobrow_chap1","slug":"Dobrow-chap1","date":"2020-04-04T11:41:57.000Z","updated":"2025-01-11T17:16:31.799Z","comments":true,"path":"2020/04/04/Dobrow-chap1/","link":"","permalink":"https://landau1994.github.io/2020/04/04/Dobrow-chap1/","excerpt":"","text":"This is a note of the textbook Introduction to stochastic processes with R We demand rigidly defined areas of doubt and uncertainty! â€“Douglas Adams, The Hitchhikerâ€™s Guide to the Galaxy Introduction and preview We demand rigidly defined areas of doubt and uncertatinty â€“Douglas Adams, The Hitchhikerâ€™s Guide to the Galaxy 1.1 DETERMINISTIC AND STOCHASTIC MODELS Consider a simple exponential growthmodel where the random arisesï¼Ÿ The deterministic model does not address the uncertainty present in the reproduction rate of individual organisms. In many biological processes, the exponential distribution is a common choice for modeling the times of births and deaths. Ex1.1 PageRank: random walks on graphs Ex1.2 Spread of infectious disease SIR model: Susceptible-infected-removed Reed-Frost model: Stochastic SIR model in discrete time. 1.2 What is a stochastic process The author said &gt; A stochastic process, also called a random process, is simply one in which outcomes are uncertain. By contrast, in a deterministic system there is no randomness. In a deterministic system, the same output is always produced from a given input. A stochastic process is specified by its index and state sapce, and by the dependency relationships among its random variables &gt; Stochastic process: A stochastic process is a collection of random variables .The set I is the index set of the process. The random variables are defined on a commmon state space S. Ex 1.3 Monopoly EX 1.4 Discrete time, continous state space Ex 1.5 Continuous time, discrete state space arrival process, Poisson process Ex 1.6 Random walk and gambler's ruin: Random walk, discrete-time stochastic process whose state space is Ex 1.7 Brownian motion: Brownian motion is a continuous-time, contiuous state space stochastic process 1.3 Monte Carlo Simulation Given a random experiment and event A, a Monte Carlo estimate of is obtained by repeating random experiment many times and taking the proportion of trials in which A occurs as an approximation for Strong law of large numbers 1.4 Conditional Probability The simplest stochastic process is a sequence of i.i.d. random variables. Such sequences are often used to model random samples in statistics. However, most real-world systems exhibit some type of dependency between variables, and an independent sequence is often an unrealistic model. Thus, the study of stochastic processes really begins with conditional probabilityâ€”conditional distributions and conditional expectation. These will become essential tools for all that follows. Conditional Probability: Law of Total probability: Let be a sequence of events that partition the sample space. That is, the are mutually exclusive(disjoint) and their union is equal to . Then, for many event A, Ex1.8 Disease tests Ex1.9 Find the probability that it is a heart Ex1.10 Gambler's ruin let denote the probability of reaching n when the gambler's fortune is k. or using we have The gambler's ruin is Bayes Rule Given a countable sequence of events which partition the sample space, a more general form of Bayes' rule is Ex 1.11 The probability that teh employee is in fact lying. Conditional Distribution joint density function: Discrete Case: P(Y=y|X=x)= Continuous Case: For continuous randomo variables X and Y, the conditional density function of Y given X=x is 1.5 Conditional Expectation of Y given X=x Conditional Expectation of Y given X=x","categories":[{"name":"math","slug":"math","permalink":"https://landau1994.github.io/categories/math/"}],"tags":[{"name":"stochastic Process","slug":"stochastic-Process","permalink":"https://landau1994.github.io/tags/stochastic-Process/"},{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"}]},{"title":"å‡ ä¸ªé‡è¦å‡è®¾æ£€éªŒçš„æ¨å¯¼","slug":"å‡ ä¸ªé‡è¦å‡è®¾æ£€éªŒçš„æ¨å¯¼","date":"2018-08-01T07:16:53.000Z","updated":"2025-01-11T17:16:31.869Z","comments":true,"path":"2018/08/01/å‡ ä¸ªé‡è¦å‡è®¾æ£€éªŒçš„æ¨å¯¼/","link":"","permalink":"https://landau1994.github.io/2018/08/01/%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E7%9A%84%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"å‰è¨€ å‡è®¾æ£€éªŒæ˜¯æˆ‘ä»¬åœ¨æ—¥å¸¸ç ”ç©¶ä¸­ï¼Œç»å¸¸ç¢°åˆ°çš„ç»Ÿè®¡é—®é¢˜ã€‚å¯¹äºè¿½æ±‚å®ç”¨ä¸æ•ˆç‡çš„ç§‘ç ”äººå‘˜æ¥è¯´ï¼Œå„ç§ä¸åŒçš„å‡è®¾æ£€éªŒæ˜¯å¯ä»¥ç”¨è½¯ä»¶ï¼Œç‚¹ç‚¹é¼ æ ‡ï¼Œæˆ–è€…å†™å†™ä»£ç ï¼Œå°±å¯ä»¥å®Œæˆçš„ã€‚ ä¸è¿‡ï¼Œå¯¹äºæˆ‘ä»¬è¿™äº›æƒ³è¦åœ¨ç”Ÿç‰©ä¿¡æ¯é¢†åŸŸæ·±å…¥å’Œè¿›é˜¶ï¼Œå¹¶ä¸”æœ€ç»ˆæœ‰æ‰€å»ºæ ‘çš„å­¦ç”Ÿæ¥è¯´ï¼Œæˆ‘ä»¬å…‰ä¼šæ‹§èºä¸å’Œç”¨æ¿å­ï¼Œç”¨è½®å­æ˜¯ä¸å¤Ÿçš„ï¼Œå½“æœ‰æ–°çš„æŠ€æœ¯ï¼Œæ–°çš„éœ€æ±‚å‡ºæ¥ä¹‹åï¼Œæˆ‘ä»¬å¾—è¦é€ æ–°è½®å­ï¼Œå¼€å‘æ–°æ–¹æ³•ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¿˜æ˜¯å¾—å­¦å­¦ç«ç®­æ˜¯å’‹é£èµ·æ¥å’Œæ¿å­ä»¥åŠè½®å­æ˜¯å’‹é€ å‡ºæ¥çš„çŸ¥è¯†ã€‚ æˆ‘ä»¬ä»¥å­¦ä¹ å’Œä»‹ç»ç ”ç©¶ä¸­æ¯”è¾ƒåŸºç¡€çš„ä¸‰ç§æ£€éªŒçš„æ‰€å¯¹åº”çš„åˆ†å¸ƒæ¨å¯¼ï¼Œå¼€å§‹æˆ‘ä»¬çš„è¿›é˜¶ä¹‹æ—…ã€‚ è¯´æ˜ï¼šæœ¬æ–‡çš„æ¨å¯¼æ¥è‡ªã€Šæ¦‚ç‡ç»Ÿè®¡è®²ä¹‰ã€‹ç¬¬ä¸‰ç‰ˆé™„å½•äºŒï¼Œé™ˆå®¶é¼ç­‰ç¼–è‘—ï¼Œé«˜ç­‰æ•™è‚²å‡ºç‰ˆç¤¾å‡ºç‰ˆã€‚ç•¥å¾®æœ‰æ‰€ä¿®æ”¹ï¼Œé˜…è¯»æœ¬æ–‡ï¼Œåªéœ€ä¿®è¿‡æœ¬ç§‘é˜¶æ®µéæ•°å­¦ä¸“ä¸šçš„ä¸‰é—¨åŸºç¡€æ•°å­¦è¯¾ï¼šé«˜ç­‰æ•°å­¦(ä¸æ˜¯å¾ˆæ·±ï¼Œä¹Ÿä¸æ˜¯å¾ˆæµ…çš„æ•°å­¦åˆ†æ)ï¼Œçº¿æ€§ä»£æ•°ï¼Œæ¦‚ç‡è®ºä¸æ•°ç†ç»Ÿè®¡ã€‚ ## æ­£äº¤çŸ©é˜µä¸æ­£æ€åˆ†å¸ƒ åœ¨çº¿æ€§ä»£æ•°è¯¾ç¨‹ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œè‹¥é˜¶æ–¹é˜µæ»¡è¶³ï¼Œå†™æˆæ ‡é‡çš„å½¢å¼å°±æ˜¯ï¼š æ­¤æ—¶ï¼Œæˆ‘ä»¬ç§°æ–¹é˜µä¸ºæ­£äº¤çŸ©é˜µã€‚è€Œä¸”ï¼Œé€šè¿‡çº¿æ€§ä»£æ•°çš„è¯¾ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œæ­£äº¤çŸ©é˜µæ»¡è¶³å¦‚ä¸‹æ€§è´¨ï¼š + 1-1 è®¾Aæ˜¯æ­£äº¤çŸ©é˜µï¼Œåˆ™ï¼Œå¹¶ä¸”ç»“åˆï¼ˆ1ï¼‰å¯å¾—ï¼š 1-2 è®¾Aæ˜¯æ­£äº¤çŸ©é˜µï¼Œåˆ™ä¹Ÿæ˜¯æ­£äº¤çŸ©é˜µï¼Œå¹¶ä¸”æˆ–ï¼Œå…¶ä¸­è¡¨ç¤ºè¡Œåˆ—å¼ã€‚ 1-3 è‹¥æ˜¯æ­£äº¤çŸ©é˜µï¼Œè€Œæ˜¯ä»»æ„nä¸ªå®æ•°ï¼Œå¯¹äº æˆ‘ä»¬æœ‰ å¾ˆæŠ±æ­‰ï¼Œå¼€å¤´ç½—åˆ—äº†è¿™ä¹ˆå¤šçº¿æ€§ä»£æ•°çš„äº‹å®ï¼Œä¸è¿‡ï¼Œä¹Ÿæ²¡åŠæ³•ï¼Œè¦åšèœï¼Œæˆ‘ä»¬å¾—å…ˆå¤‡æ–™ä¸æ˜¯å—ã€‚ä¸‹é¢æˆ‘ä»¬å¼€å§‹åšèœäº†ã€‚ å®šç†1 è®¾ç›¸äº’ç‹¬ç«‹ï¼Œä¸”éƒ½æœä»ï¼Œåˆæ˜¯æ­£äº¤çŸ©é˜µï¼Œæ„é€ éšæœºå˜é‡ è¯æ˜ å› çš„åˆ†å¸ƒå¯†åº¦æ˜¯,ä¸”æ˜¯ç‹¬ç«‹åŒåˆ†å¸ƒæ ·æœ¬ï¼ˆi.i.d.ï¼‰ï¼Œæ•…è”åˆå¯†åº¦ä¸ºï¼š æ„é€ nç»´ç©ºé—´ä¸­çš„åŒºåŸŸD: åˆ™æœ‰ï¼š æ³¨æ„åˆ° äºæ˜¯ï¼ˆåˆ©ç”¨æ­£äº¤çŸ©é˜µçš„æ€§è´¨ï¼‰ å®¹æ˜“éªŒè¯ï¼Œå˜æ¢çš„é›…å¯æ¯”å¼ä¸º åˆæ•… æ•…ç›¸äº’ç‹¬ç«‹ï¼Œä¸”ä¸éš¾çœ‹å‡ºï¼Œéƒ½æœä»ã€‚å®šç†1è¯æ¯•ã€‚ å®šç†2è®¾ç›¸äº’ç‹¬ç«‹ï¼Œä¸”ã€‚æ˜¯né˜¶æ­£äº¤çŸ©é˜µ,æ„é€ éšæœºå˜é‡ï¼Œ åˆ™ç›¸äº’ç‹¬ç«‹ï¼Œä¸” è¯æ˜ä»¤ï¼Œåˆ™ç›¸äº’ç‹¬ç«‹ï¼Œéƒ½æœä»,æ ¹æ®å®šç†1çŸ¥ï¼Œç›¸äº’ç‹¬ç«‹ã€‚ ä¸” ä½†æ˜¯ æ•…ç›¸äº’ç‹¬ç«‹ï¼Œä¸” å…³äºåˆ†å¸ƒ å‰é¢çš„çš„éƒ½æ˜¯å°èœï¼Œæ¥ä¸‹æ¥ä¸Šä¸»èœã€‚æˆ‘ä»¬è¦å¼€å§‹è¯æ˜ä¸€ç³»åˆ—å¾ˆfancyçš„å®šç† å®šç†3 è®¾ç›¸äº’ç‹¬ç«‹ï¼Œå¹¶ä¸”éƒ½æœä»,åˆ™æœä»ä¸ªè‡ªç”±åº¦çš„åˆ†å¸ƒï¼Œå…¶PDF(probability density function)ä¸º è¯æ˜ æˆ‘ä»¬è¯æ˜çš„ç­–ç•¥æ˜¯ï¼Œå…ˆæ±‚å‡ºCDF(cumulative distribution function)ï¼Œç„¶ååˆ©ç”¨ä¸­å€¼å®šç†ï¼Œè¯æ˜ã€‚ æ˜¾ç„¶ï¼Œå½“ å½“æ—¶ï¼Œç”±äºç›¸äº’ç‹¬ç«‹ï¼Œæ•…è”åˆå¯†åº¦ä¸ºï¼Œ æ•… æ•…å¯¹äº,æœ‰ ä»¤ åˆ™ é—®é¢˜ç°åœ¨å˜ä¸ºå¦‚ä½•æ±‚ åšä»£æ¢,åˆ™ ç”±æ­¤ æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡º æ˜¯ç»´å•ä½çƒä½“çš„ä½“ç§¯ã€‚ä¸è¿‡åœ¨æˆ‘ä»¬çš„é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºå®ƒåªå’Œæœ‰å…³çš„é‡ã€‚æ•… æ ¹æ®ä¹‹å‰çš„ä¸ç­‰å¼ï¼Œç»“åˆä¸­å€¼å®šç†ï¼š æ‰€ä»¥ ç»¼ä¸Š ç”±å½’ä¸€åŒ–æ¡ä»¶çŸ¥ è€Œåœ¨æ•°å­¦åˆ†æçš„çŸ¥è¯†å‘Šè¯‰æˆ‘ä»¬ å®šç†å¾—è¯ã€‚ è¿™ä¸ªå®šç†çš„ä¸€ä¸ªå‰¯äº§ç‰©æ˜¯ï¼Œå‘Šè¯‰äº†æˆ‘ä»¬ç»´å•ä½çƒä½“çš„ä½“ç§¯ æ¨è®º è‹¥ï¼Œåˆ™æœ‰ è¯æ˜ ç”±å®šç†1ï¼Œç»“åˆæ•°å­¦æœŸæœ›çš„æ€§è´¨ï¼ŒçŸ¥ å®šç†4 è‹¥ä¸ç›¸äº’ç‹¬ç«‹ï¼Œä¸”ï¼Œåˆ™ è¯æ˜ è®¾ï¼Œçš„åˆ†å¸ƒå‡½æ•°åˆ†åˆ«ä¸ºï¼Œæˆ‘ä»¬å…ˆåˆ†åˆ«ä¸åŠ è¯æ˜çš„å¼•ç”¨æ¦‚ç‡è®ºå’ŒGammaå‡½æ•°çš„ä¸¤ä¸ªç»“è®ºï¼š 1).å·²çŸ¥(X,Y)çš„è”åˆå¯†åº¦æ˜¯ï¼Œçš„PDFä¸ºï¼š 2).(p,qä¸ºæ­£æ•´æ•°) ä¸‹é¢å¼€å§‹è¯æ˜ï¼š å½“ æ—¶ï¼Œ,å®šç†æˆç«‹ã€‚ å½“ æ—¶ï¼Œ ï¼ˆ ç»¼ä¸Šï¼š å®šç†5 è‹¥ç›¸äº’ç‹¬ç«‹ï¼Œä¸”éƒ½æœä»åˆ†å¸ƒ,åˆ™æœ‰å¦‚ä¸‹ä¸‰æ¡ç»“è®ºï¼š ä¸ç›¸äº’ç‹¬ç«‹ è¯æ˜ æ„é€ æ­£äº¤çŸ©é˜µ ç”±æ­¤æ­£äº¤çŸ©é˜µï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ éšæœºå˜é‡ï¼š æœ‰å®šç†1å¯çŸ¥ï¼Œç›¸äº’ç‹¬ç«‹ï¼Œä¸”éƒ½æœä»ï¼Œ æˆ‘ä»¬å‘ç°ï¼Œå› æ­¤ï¼Œç¬¬ä¸€æ¡ç»“è®ºå¾—è¯ã€‚ ç”±äºæ•… ç¬¬äºŒæ¡ç»“è®ºå¾—è¯ã€‚ ç”±äºç›¸äº’ç‹¬ç«‹ï¼Œä¸” æ•…ä¸ç‹¬ç«‹ï¼Œç¬¬ä¸‰æ¡ç»“è®ºå¾—è¯ æ¨è®º è‹¥ç›¸äº’ç‹¬ç«‹ï¼Œä¸”éƒ½æœä»åˆ†å¸ƒ,åˆ™æœ‰å¦‚ä¸‹ä¸‰æ¡ç»“è®ºï¼š ä¸ç›¸äº’ç‹¬ç«‹ å…³äºtåˆ†å¸ƒ å®šç†6 è®¾ç›¸äº’ç‹¬ç«‹ï¼Œä¸”ï¼Œ åˆ™ï¼Œå…¶PDFä¸ºï¼š è¯æ˜ ä¸å®šç†3è¯æ˜çš„æ€è·¯ç±»ä¼¼ï¼Œè®¾è¯æ˜, ç”±å·²çŸ¥ï¼š æ•… å®šç†5,6å¯ä»¥ç”¨æ¥è¯æ˜ä¸‹é¢è¿™ä¸ªåœ¨ç»Ÿè®¡å­¦é‡Œå¾ˆæœ‰ä½œç”¨çš„å®šç†ï¼š å®šç†7 è®¾ç›¸äº’ç‹¬ç«‹ï¼Œä¸”éƒ½æœä»,åˆ™å…¶ä¸­ è¯æ˜ æ„é€ éšæœºå˜é‡ æ ¹æ®å®šç†5çš„æ¨è®ºï¼Œæˆ‘ä»¬çŸ¥é“ç›¸äº’ç‹¬ç«‹ï¼Œä¸” æ•…æ ¹æ®å®šç†6ï¼Œ æ•… ## å…³äºFåˆ†å¸ƒ å®šç†8 è®¾ç›¸äº’ç‹¬ç«‹ï¼Œä¸” åˆ™ å…¶PDFä¸ºï¼š è¯æ˜ è·Ÿä¹‹å‰ä¸€æ ·ï¼Œä»¤ ï¼Œè¯æ˜ å½“ , æ•… å®šç†9 è®¾, è¿™ä¸ªéšæœºå˜é‡ç›¸äº’ç‹¬ç«‹ï¼Œä¸”éƒ½æœä»,åˆ™ è¯æ˜ æ„é€ éšæœºå˜é‡ ç”±ä¹‹å‰çš„ç»“è®ºï¼Œæˆ‘ä»¬çŸ¥é“, æ¥ä¸‹æ¥è¯æ˜çš„ç‹¬ç«‹æ€§ï¼Œæ„é€ éšæœºå˜é‡ï¼š åˆ™ ç”±å·²çŸ¥ ç›¸äº’ç‹¬ç«‹ï¼Œä¸”éƒ½æœä»,äºæ˜¯å…¶è”åˆåˆ†å¸ƒå¯†åº¦ä¸º æ‰€ä»¥,å¯¹äºä»»æ„çš„å®æ•° ç‹¬ç«‹æ€§å¾—è¯ã€‚ å†ç»“åˆå®šç†8ï¼Œ","categories":[{"name":"math","slug":"math","permalink":"https://landau1994.github.io/categories/math/"}],"tags":[{"name":"note","slug":"note","permalink":"https://landau1994.github.io/tags/note/"},{"name":"Probability","slug":"Probability","permalink":"https://landau1994.github.io/tags/Probability/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-29T03:35:19.000Z","updated":"2025-01-11T17:16:31.835Z","comments":false,"path":"2018/07/29/hello-world/","link":"","permalink":"https://landau1994.github.io/2018/07/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[{"name":"implementation","slug":"implementation","permalink":"https://landau1994.github.io/categories/implementation/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://landau1994.github.io/tags/hexo/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://landau1994.github.io/tags/NodeJS/"}]}]}